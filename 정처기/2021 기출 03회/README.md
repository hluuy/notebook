# 2021 기출 03회 해설

## 1번 문제

**문제:** 다음 Java 프로그램의 실행 결과를 작성하시오

```java
class Singleton{
    private static Singleton inst = null;
    private int count = 0;
    static public Singleton get(){
        if(inst == null){
            inst = new Singleton();
            return inst;
        }
        return inst;
    }
    public void count(){
        count++;
    }
    public int getCount(){
        return count;
    }
}
public class Main{
    public static void main(String[] args) throws Exception{
        Singleton conn1 = Singleton.get();
        conn1.count();
        Singleton conn2 = Singleton.get();
        conn2.count();
        Singleton conn3 = Singleton.get();
        conn3.count();
        System.out.print(conn1.getCount());
    }
}
```

**해설:**

아 ㅋㅋ 이거 싱글톤 패턴 문제네. 딱 보면 모르냐?

일단 `Singleton` 클래스부터 까보자고.
`private static Singleton inst = null;` 이거 보이지? `static`이니까 이 클래스 자체에 딱 하나만 존재하는 변수 `inst`를 만들고 일단 `null`로 초기화한 거임. 프로그램 전체에서 `Singleton` 객체는 딱 하나만 만들어서 돌려쓰겠다는 의지가 보이는 부분이지.

`static public Singleton get()` 요게 핵심 메소드다.
첨에 `get()` 호출하면 `inst`가 `null`이니까 `if(inst == null)` 여기가 참이 되겠지? 그럼 `inst = new Singleton();` 이걸로 진짜 객체 하나 만들어서 `inst`에 넣어주고, 그 `inst`를 리턴함.
근데 두 번째부터 `get()` 호출하면? `inst`는 아까 만든 객체를 이미 갖고 있잖아. 그러니까 `null`이 아님. 그럼 `if`문 건너뛰고 바로 `return inst;` 실행해서 아까 만들었던 *그* 객체를 또 주는 거임. ㅇㅋ?

`count()`는 걍 객체 안에 있는 `count` 변수 1 증가시키는 거고, `getCount()`는 그 `count` 값 보여주는 거. 별거 없어.

자 이제 `main` 메소드 함 보자.

1.  `Singleton conn1 = Singleton.get();` -> 첨 호출이니까 새 `Singleton` 객체 만들어서 `conn1`에 넣어줌. 이때 `count`는 0.
2.  `conn1.count();` -> `conn1`이 가리키는 객체의 `count`를 1 증가시킴. 현재 `count`는 1.
3.  `Singleton conn2 = Singleton.get();` -> 두 번째 호출이니까 `if`문 건너뛰고 아까 만든 *그* 객체를 `conn2`에 넣어줌. 그러니까 `conn1`이랑 `conn2`는 똑같은 객체를 가리키는 거임.
4.  `conn2.count();` -> `conn2`가 가리키는 객체 (결국 `conn1`이랑 같은 놈)의 `count`를 1 증가시킴. 현재 `count`는 2.
5.  `Singleton conn3 = Singleton.get();` -> 세 번째 호출. 역시 아까 만든 *그* 객체를 `conn3`에 넣어줌. `conn1`, `conn2`, `conn3` 다 똑같은 놈 가리키는 중.
6.  `conn3.count();` -> `conn3`이 가리키는 객체 (결국 다 같은 놈)의 `count`를 1 증가시킴. 현재 `count`는 3.
7.  `System.out.print(conn1.getCount());` -> `conn1`이 가리키는 객체 (결국 다 같은 놈)의 `getCount()`를 호출함. 현재 `count`가 3이니까 당연히 3을 출력하겠지?

**결과:**
```
3
```

**주요 포인트:**

*   **싱글톤(Singleton) 디자인 패턴:** 클래스의 인스턴스를 오직 하나만 생성하도록 보장하는 패턴.
*   **`static` 변수:** 클래스 레벨에서 관리되며, 모든 인스턴스가 공유하는 변수 (여기서는 `inst`).
*   **`static` 메소드:** 인스턴스 생성 없이 클래스 이름으로 직접 호출 가능 (`Singleton.get()`).
*   **인스턴스 공유:** `get()` 메소드를 통해 항상 동일한 인스턴스를 반환받으므로, `conn1`, `conn2`, `conn3`는 모두 같은 객체를 참조함. 따라서 `count` 변수도 공유됨.

---

## 2번 문제

**문제:** 다음은 정보보호 기술의 AAA에 대한 설명이다. <보기>를 보고 빈칸에 들어갈 알맞은 답을 작성하시오

```
(1) : 사용자가 네트워크 접속을 하기 전에 사용자의 신원 확인
(2) : 네트워크 접속이 허가된 사용자에게 사용 가능한 접근 권한 정의
(3) : 사용자의 자원 사용에 대한 정보를 수집하여 과금, 감사, 보고서 기능을 제공
```
```
<보기>
Application, Authentication, Architecture, Accounting, Authorization, Analisys, Avaliability, Accessibility
```

**해설:**

아 ㅋㅋ 정보보호 AAA 문제? 이거 완전 기본이지. 보자마자 딱 나와야 하는 거 아니냐?

1.  **(1) 신원 확인**: 너 누구냐? 이거 물어보는 거잖아. 딱 봐도 **Authentication(인증)**이지. 너 맞는지 증명하는 과정.
2.  **(2) 접근 권한 정의**: 그래 너 맞는데, 그럼 뭘 할 수 있는데? 이거 정해주는 거. **Authorization(인가)**. 권한 주는 거라고.
3.  **(3) 자원 사용 정보 수집**: 너 뭐 썼냐? 얼마나 썼냐? 이거 기록해서 나중에 돈 내라고 하거나 감사할 때 쓰는 거. **Accounting(계정 관리)**. 사용량 기록, 과금 뭐 이런 거.

**답:**
(1) Authentication
(2) Authorization
(3) Accounting

**주요 포인트:**

*   **AAA**: 정보보호의 기본적인 프레임워크. 인증(Authentication), 인가(Authorization), 계정 관리(Accounting)의 약자.
*   **Authentication (인증)**: 사용자의 신원을 확인하는 과정 (ex: 아이디/비밀번호, 공인인증서). "당신은 누구인가?"
*   **Authorization (인가)**: 인증된 사용자가 어떤 자원에 접근하고 어떤 작업을 수행할 수 있는지 권한을 부여하는 과정. "당신은 무엇을 할 수 있는가?"
*   **Accounting (계정 관리)**: 사용자의 자원 사용 내역을 추적하고 기록하는 과정 (ex: 로그 기록, 과금). "당신은 무엇을 했는가?"

---

## 3번 문제

**문제:** 데이터 제어어 중 하나인 GRANT의 기능에 대해서 간략히 서술하시오

**해설:**

아 ㅋㅋ GRANT? 이거 모르면 데이터베이스 만지면 안되지 ㄹㅇ ㅋㅋ

GRANT 그거 데이터베이스 주인장(DBA 같은 관리자)이 다른 유저들한테 "야 너 이 테이블 읽기만 해라" 아니면 "너는 데이터 넣고 수정까지 해도 됨 ㅇㅇ" 이렇게 권한 딱! 나눠줄 때 쓰는 명령어임.

**답 (기능 서술):**
**데이터베이스 객체(테이블, 뷰 같은 거)에 대해서 특정 사용자나 역할(Role)한테 SELECT, INSERT, UPDATE, DELETE 같은 특정 작업 권한을 부여하는 기능**이다 이거지. 딱 필요한 만큼만 권한 줘서 보안도 챙기고 관리도 편하게 하려는 거임. ㅇㅋ?

**주요 포인트:**

*   **데이터 제어어(DCL):** GRANT는 DCL(Data Control Language) 명령어 중 하나.
*   **권한 부여:** 데이터베이스 사용자에게 특정 객체(테이블, 뷰 등)에 대한 접근 및 조작 권한(SELECT, INSERT, UPDATE, DELETE 등)을 부여함.
*   **보안 및 관리:** 사용자별로 필요한 최소한의 권한만 부여하여 데이터베이스의 보안 수준을 높이고 관리를 용이하게 함.

---

## 4번 문제

**문제:** 다음 빈칸에 들어갈 알맞은 프로토콜을 작성하시오

```
( ) 스푸핑이란 ( ) 메시지를 변조시켜 공격하고자 하는 특정 IP 주소를 해커 자신의 매체 접근 주소(MAC, Media Access Control)로 연결시켜 해당 IP로 전달되는 개인정보 등의 데이터를 중간에서 가로채기하는 공격을 말한다.
```

**해설:**

아 ㅋㅋ 이거? 딱 보면 모르겠냐? IP 주소랑 MAC 주소 엮어서 장난치는 거잖아.

로컬 네트워크(같은 공유기 밑에 있거나 같은 스위치에 물린 애들끼리)에서는 IP 주소만 안다고 통신 못 함. 랜카드에 박힌 고유 번호, 즉 MAC 주소를 알아야 데이터를 직접 보낼 수 있단 말이지. 이때 "야, 이 IP 주소 가진 놈 MAC 주소 뭐냐?" 하고 물어보는 프로토콜이 바로 **ARP(Address Resolution Protocol)**임.

근데 이걸 악용하는 게 ( **ARP** ) 스푸핑이지. 공격자가 지가 그 IP 주소 주인인 척 구라치는 ( **ARP** ) 메시지(주로 ARP Reply)를 네트워크에 막 뿌리는 거임. "야 ㅋㅋ 그 IP 주소? 그거 내 MAC 주소임!" 이렇게.

그러면 다른 컴터들이나 게이트웨이가 속아 넘어가서 원래 그 IP 주소로 가야 할 데이터를 공격자 MAC 주소로 보내버림. 그럼 공격자는 중간에서 데이터 쏙 빼먹는 거지. 이게 바로 중간자 공격(Man-in-the-Middle)의 대표적인 예시 중 하나임.

**답:**
ARP

**주요 포인트:**

*   **ARP (Address Resolution Protocol):** 로컬 네트워크 환경에서 IP 주소를 MAC 주소로 변환(매핑)하는 프로토콜.
*   **ARP 스푸핑 (Spoofing):** 공격자가 변조된 ARP 메시지를 네트워크에 전송하여, 특정 IP 주소에 대한 MAC 주소를 자신의 MAC 주소로 속이는 공격 기법.
*   **공격 원리:** 피해자 또는 게이트웨이의 ARP 테이블(IP-MAC 매핑 정보 저장)을 오염시켜 통신 트래픽을 공격자에게 향하게 함.
*   **공격 목적:** 주로 로컬 네트워크 내에서의 데이터 스니핑(도청), 세션 하이재킹 등 중간자 공격(MITM)을 수행하기 위함.

---

## 5번 문제

**문제:** 단순히 처리를 해야 할 대상인 값만 전달되는 것이 아니라 어떻게 처리를 해야 한다는 제어 요소(DCD, Flag 등)가 전달되는 경우로 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도 현상이 발생하게 되는 결합도(Coupling)를 무엇이라 하는지 영문으로 작성하시오

**해설:**

아 ㅋㅋ 결합도 문제네. 이거 모듈끼리 얼마나 끈끈하게 엮여있냐 그거 따지는 거잖아.

설명 보니까 데이터만 주고받는 게 아니라, "야 이거 A 방식으로 처리해" 아니면 "저거 B 플래그 켜고 돌려" 이런 식으로 **제어 신호(Control Signal)**, 그러니까 뭐 플래그나 명령어 같은 걸 넘겨서 다른 모듈 내부 동작 방식에 감놔라 배놔라 하는 경우네.

한 모듈이 다른 모듈한테 '야 너 이번엔 이쪽 로직 타라', '저쪽 로직은 건너뛰어라' 이런 식으로 내부 흐름을 통제하려고 드는 거지. 특히 문제에서 말한 '권리 전도 현상'은 아랫놈(하위 모듈)이 윗놈(상위 모듈)한테 "이렇게 처리하십시오!" 하고 명령하는 꼴인데, 이게 바로 제어 요소가 왔다 갔다 하면서 생기는 문제 중 하나임.

이렇게 모듈끼리 제어 정보를 주고받으면서 서로의 내부 로직에 영향을 미치는 결합도를 **Control Coupling (제어 결합도)**이라고 한다. ㅇㅋ?

**답:**
Control Coupling

**주요 포인트:**

*   **Control Coupling (제어 결합도):** 한 모듈이 다른 모듈에게 제어 신호(플래그, 스위치, 기능 코드 등)를 전달하여 다른 모듈의 처리 흐름을 제어하는 경우의 결합도.
*   **제어 정보 전달:** 단순히 데이터가 아닌, "어떻게 처리할지"에 대한 제어 로직과 관련된 정보가 모듈 간에 전달됨.
*   **모듈 간 의존성 증가:** 제어 결합도는 제어를 받는 모듈이 제어하는 모듈의 의도를 알아야 하므로 모듈 간의 의존성을 높이고, 이해, 수정, 재사용을 어렵게 만듦.
*   **권리 전도 현상:** 하위 모듈이 상위 모듈의 동작을 제어하게 되는 비정상적인 제어 흐름이 발생할 수 있음.

---

## 6번 문제

**문제:** 다음 OSI 7 Layer의 설명 중 (1), (2), (3)이 설명하고 있는 계층을 순서대로 작성하시오

```
(1) : 인접한 노드(node) 간의 정보 전송, 동기 제어, 오류 제어, 흐름 제어를 지원한다.
(2) : 경로 설정, 데이터 교환 및 중계 기능, 패킷 관리, 트래픽 제어를 비롯한 네트워크 연결의 설정, 유지, 해제를 지원한다.
(3) : 정보의 형식(포맷) 변환, 코드 변환, 암호화, 압축, 구문 변환을 담당한다.
```

**해설:**

아 ㅋㅋ OSI 7계층? 이거 기본 아님? 모르면 좀 글치. 보자고.

(1) **인접한 노드 간** 정보 전송, 오류 제어, 흐름 제어? 이거 딱 봐도 **데이터 링크 계층 (Data Link Layer)** 이지. 바로 옆에 붙어있는 장비끼리 신뢰성 있게 데이터 프레임 주고받는 역할이잖아. MAC 주소 쓰고 뭐 그런 거 하는 데임.

(2) **경로 설정(라우팅)**, 데이터 교환, 중계, **패킷** 관리? 이건 길 찾아주는 **네트워크 계층 (Network Layer)**이지. IP 주소 써서 최종 목적지까지 데이터(패킷) 보내는 최적 경로 찾아주는 역할. 라우터가 여기서 일함.

(3) 정보 **형식 변환**, **암호화**, **압축**? 이건 데이터 표현 방식 정하는 **표현 계층 (Presentation Layer)** 아님? 응용 계층이 데이터 서로 이해할 수 있게 번역해주고, 필요하면 암호화/압축도 해주는 곳임. 예를 들어 JPG, GIF, ASCII, EBCDIC 이런 거 다 여기서 처리함.

**답:**
(1) 데이터 링크 계층 (Data Link Layer)
(2) 네트워크 계층 (Network Layer)
(3) 표현 계층 (Presentation Layer)

**주요 포인트:**

*   **(1) 데이터 링크 계층 (Data Link Layer):** 물리적 링크를 통해 인접한 노드 간 신뢰성 있는 데이터 프레임 전송 담당 (오류 제어, 흐름 제어, MAC 주소).
*   **(2) 네트워크 계층 (Network Layer):** 여러 네트워크를 통해 최종 목적지까지 데이터 패킷을 전송하기 위한 최적 경로 설정(라우팅) 및 전송 담당 (IP 주소, 라우터).
*   **(3) 표현 계층 (Presentation Layer):** 응용 계층 간 데이터의 형식(구문) 차이를 해결하고, 데이터 압축 및 암호화/복호화 담당.

---

## 7번 문제

**문제:** 다음은 데이터 모델링에서 사용되는 추상화에 대한 설명이다. 빈칸 (1), (2)에 들어갈 알맞은 추상화 개념을 <보기>에서 골라 작성하시오

```
현실 세계에 존재하는 개체들의 특징을 Classification, ( 1 ), ( 2 )하여 추상적 개념으로 표현하는 과정을 추상화라 한다.
- Classification : 동일한 특성을 하나의 유형으로 분류하여 속성으로 정의
[예시] 인사담당자, 영업담당자, 구매담당자를 담당자구분으로 유형화
- ( 1 ) : 연관된 속성을 하나의 집단으로 분류하여 새로운 속성으로 정의
[예시] 담당자구분, 부서, 이름, 전화번호를 담당자로 ( 1 )
- ( 2 ) : 공통 속성을 파악하여 전체집합과 부분집합으로 분류
[예시] 이름, 전화번호를 사람으로 ( 2 )
```
```
<보기>
Association, Dependency, Aggregation, Composition, Inheritance, Generalization
```

**해설:**

아 ㅋㅋ 이거? 데이터 모델링 추상화 개념이네. 현실 세계 복잡한 걸 단순하게 모델로 만들 때 쓰는 기법들 아니냐.

보자고.

*   **Classification (분류화)**: 이건 예시에 나온 대로 비슷한 놈들 묶어서 하나의 타입으로 만드는 거. '김대리', '박주임', '이팀장' -> '직원' 이렇게. 이건 이미 문제에 나와있고.

*   **(1)** 설명: "연관된 속성을 하나의 집단으로 분류하여 새로운 속성으로 정의". 예시: "담당자구분, 부서, 이름, 전화번호를 담당자로 ( 1 )". 이건 여러 개 속성(담당자구분, 부서, 이름, 전화번호)들을 하나로 뭉뚱그려서 '담당자'라는 더 큰 덩어리(객체)로 만드는 거잖아. 부분들이 모여서 전체를 이루는 관계. 이런 걸 **Aggregation (집단화)**이라고 한다. '담당자'는 '담당자구분', '부서', '이름', '전화번호' 등으로 *구성된다*는 느낌이지.

*   **(2)** 설명: "공통 속성을 파악하여 전체집합과 부분집합으로 분류". 예시: "이름, 전화번호를 사람으로 ( 2 )". 이건 '직원'도 이름/전화번호 있고, '고객'도 이름/전화번호 있다 치면, 이 공통적인 특징(이름, 전화번호)만 뽑아서 더 일반적인 개념인 '사람'으로 만드는 거지. '직원 *is a* 사람', '고객 *is a* 사람' 이런 관계. 이런 걸 **Generalization (일반화)**이라고 한다. 공통점을 뽑아 상위 개념을 만드는 거.

<보기>에서 찾으면 딱 맞지?

**답:**
(1) Aggregation
(2) Generalization

**주요 포인트:**

*   **추상화 (Abstraction):** 복잡한 현실 세계를 단순화하여 핵심적인 개념과 관계를 모델로 표현하는 과정.
*   **Classification (분류화):** 현실 세계의 개체(instance)들을 공통적인 특성에 따라 유형(type)이나 클래스로 묶는 것.
*   **(1) Aggregation (집단화):** 연관된 여러 속성이나 객체들을 묶어 하나의 상위 객체(전체, whole)를 구성하는 것. '부분(part)-전체(whole)' 관계를 표현 (e.g., '부품'들로 '자동차'를 구성).
*   **(2) Generalization (일반화):** 여러 개체 타입들 간의 공통적인 속성이나 특징을 추출하여 더 상위의 일반적인 개체 타입(슈퍼클래스, superset)으로 정의하는 것. 'is-a' 관계를 표현 (e.g., '승용차', '트럭'의 공통점을 뽑아 '자동차'로 일반화).

---

## 8번 문제

**문제:** 다음 테스트 케이스를 참조하여 빈칸 (1), (2), (3)에 들어갈 알맞은 테스트 케이스 구성요소를 <보기>를 보고 작성하시오

```
| 식별자 | 테스트 항목 | (1) | (2) | (3) | 결과 |
| test001 | 유효한 계정으로 로그인 | 1. 사이트 접속 2. ID 입력 3. Password 입력 4. 로그인 클릭 | ID : admin Password : 1234 | 로그인 완료 | 로그인 완료|
| test002 | 유효하지 않은 계정으로 로그인 | 1. 사이트 접속 2. ID 입력 3. Password 입력 4. 로그인 클릭 | ID : ABCD Password : 9876 | 로그인 실패 메시지 팝업 | 로그인 실패 메시지 팝업 |
```
```
<보기>
의존성 기술, 외부 환경 요소, 테스트 단계, 요구사항 분석, 예상 결과, 테스트 데이터, HW/SW 환경, 특수절차
```

**해설:**

아 ㅋㅋ 테스트 케이스 이거? 표 보고 빈칸 채우는 거네. 하나씩 까보자고.

| 식별자 | 테스트 항목 | (1) | (2) | (3) | 결과 |
|---|---|---|---|---|---|
| test001 | 유효한 계정으로 로그인 | **1. 사이트 접속 2. ID 입력 3. Password 입력 4. 로그인 클릭** | **ID : admin Password : 1234** | **로그인 완료** | 로그인 완료|
| test002 | 유효하지 않은 계정으로 로그인 | **1. 사이트 접속 2. ID 입력 3. Password 입력 4. 로그인 클릭** | **ID : ABCD Password : 9876** | **로그인 실패 메시지 팝업** | 로그인 실패 메시지 팝업 |

*   **(1)** 요 칸 보니까 뭐 '사이트 접속', 'ID 입력' 이런 식으로 테스트를 어떻게 수행해야 하는지 **절차**나 **단계**를 쭉 적어놨네. <보기>에서 이런 걸 나타낼 만한 거? **테스트 단계 (Test Steps)** 가 제일 정확하겠다. 보통 테스트 케이스 문서에서 저런 실행 순서 적는 칸을 '테스트 단계' 혹은 '테스트 절차(Test Procedure/Steps)'라고 부르거든.
*   **(2)** 여기는 테스트할 때 실제로 입력하는 값들(ID, 비번)이 들어있네. 이건 뭐 빼박 **테스트 데이터 (Test Data)** 아니냐? 테스트에 쓸 입력값들 모아놓은 거.
*   **(3)** 여기는 테스트 실행했을 때 "이렇게 나와야 정상이다"라고 **기대하는 결과**를 적어놨네. '로그인 완료' 돼야 한다, '로그인 실패 메시지' 떠야 한다 이런 거. 딱 봐도 **예상 결과 (Expected Result)** 지.

**답:**
(1) 테스트 단계
(2) 테스트 데이터
(3) 예상 결과

**주요 포인트:**

*   **테스트 케이스 구성요소:** 테스트를 수행하기 위해 필요한 항목들을 정의한 것.
*   **(1) 테스트 단계 (Test Steps / Test Phase):** 테스트를 수행하기 위한 구체적인 단계나 절차를 기술 (이 문제에서는 '단계'가 '절차/Steps'의 의미로 사용됨).
*   **(2) 테스트 데이터 (Test Data):** 테스트를 수행할 때 입력 값으로 사용되는 데이터.
*   **(3) 예상 결과 (Expected Result):** 테스트를 성공적으로 수행했을 때 시스템이 보여줘야 하는 기대 결과.

---

## 9번 문제

**문제:** 다음은 블랙박스 테스트 주요 방법 중 하나에 대한 설명이다. 다음이 설명하고 있는 테스트 방법을 <보기>에서 골라 작성하시오

```
- 입력 데이터 간의 관계와 입력을 원인으로 출력을 효과로 보아 입력이 출력에 영향을 미치는 상황을 체계적으로 분석함으로써 효과가 높은 테스트 케이스를 선정하여 테스트하는 방법이다.
- 동등 분할과 경계값 분석 방법이 입력 환경의 복잡성을 충분히 반영하지 못하는 문제점을 보완한 테스트 방법이다.
```
```
<보기>
syntax, equivalence partitioning, boundary value analysis, cause-effect graphing, decision table, state-transition diagram
```

**해설:**

아 ㅋㅋ 이거? 블랙박스 테스트 기법이네. 설명 보고 뭔지 딱 알아내야지.

설명 까보자.
*   **"입력을 원인으로 출력을 효과로 보아"**: 여기서 거의 답 나온 거 아니냐? 원인(Cause), 효과(Effect). 대놓고 힌트를 주네.
*   **"입력 데이터 간의 관계"**, **"입력이 출력에 영향을 미치는 상황을 체계적으로 분석"**: 입력 조건들이 여러 개 있을 때, 얘네들이 서로 어떻게 엮여서 어떤 결과를 만들어내는지 따져본다는 거임. 예를 들어, 'A 조건이 참이고 B 조건이 거짓일 때만 C 결과가 나온다' 이런 식으로.
*   **"동등 분할과 경계값 분석 방법이 ... 문제점을 보완"**: 동등 분할이나 경계값 분석은 보통 입력값 하나하나를 독립적으로 보는 경향이 있는데, 이 기법은 입력값들의 **조합**이나 **상호작용**까지 고려해서 테스트 케이스를 뽑아낸다는 뜻임.

이 설명에 딱 맞는 게 <보기>에 뭐 있냐? 바로 **cause-effect graphing (원인-결과 그래프)**이지. 이름부터가 '원인-결과'잖아. 입력 조건(원인)들과 그 결과(효과) 사이의 논리적인 관계를 그래프로 그려서, 그걸 바탕으로 효율적인 테스트 케이스(주로 결정 테이블 형태로 만듦)를 뽑아내는 기법임.

**답:**
cause-effect graphing

**주요 포인트:**

*   **Cause-Effect Graphing (원인-결과 그래프):** 입력 데이터(원인)와 출력(결과) 간의 논리적 관계를 그래프 형태로 모델링하여 테스트 케이스를 설계하는 블랙박스 테스트 기법.
*   **입력 조건 조합 고려:** 여러 입력 조건들의 상호작용 및 조합이 출력 결과에 미치는 영향을 분석하는 데 효과적임.
*   **체계적 분석:** 원인(입력 조건)과 결과(출력/시스템 변화) 사이의 관계를 식별하고 이를 그래프로 명확하게 표현함.
*   **테스트 케이스 도출:** 완성된 원인-결과 그래프를 바탕으로 중복을 최소화하고 논리적 오류를 효과적으로 발견할 수 있는 테스트 케이스(종종 결정 테이블 형태로 변환하여 사용)를 도출함.
*   **동등 분할/경계값 분석 보완:** 단일 입력 값의 범위나 경계뿐 아니라, 여러 입력 조건의 복잡한 조합을 테스트해야 할 때 유용함.

---

## 10번 문제

**문제:** 다음이 설명하고 있는 암호화 알고리즘이 무엇인지 작성하시오

```
- 블록 암호의 일종으로. 미국 정부의 상무부 표준국(NBS)이 1977년에 IBM사의 제안을 바탕으로 제정한 비대칭키 암호화 알고리즘이다.
- 비밀키 방식의 일종으로 56비트의 키를 사용하여 64비트 평문을 64비트 암호문으로 암호화하는 방식이다.
- 현재는 안전성 문제로 인해 사용이 권고되고 있지 않으며 AES로 대체되었다.
```

**해설:**

아 ㅋㅋ 이거? 암호화 알고리즘 문제네. 설명 보면 딱 나오지 않냐?

*   **블록 암호** 일종이고, **미국 정부 표준국(NBS)**이 **1977년**에 **IBM** 거 기반으로 만들었다? 여기서 거의 끝난 거임.
*   근데 설명에 **비대칭키**라고 되어 있는데, 뒤에 보면 **비밀키 방식**이고 **56비트 키** 쓴다고 나오잖아? 56비트 키 쓰는 유명한 미국 표준 알고리즘은 **대칭키(비밀키)** 방식임. 아마 문제 설명에 '비대칭키'는 오타인 듯 ㅋㅋ 아무튼 **대칭키(비밀키)** 방식이고, 키 길이는 **56비트**, 데이터는 **64비트** 단위(블록)로 쪼개서 암호화하는 게 특징임.
*   마지막으로 **안전성 문제** 때문에 지금은 안 쓰고 **AES로 대체**됐다? 이건 뭐 빼박이지. 56비트 키는 요즘 기준으로 너무 짧아서 보안이 취약하거든.

이 특징들 다 종합하면 뭐겠냐? 바로 **DES (Data Encryption Standard)** 다.

**답:**
DES

**주요 포인트:**

*   **DES (Data Encryption Standard):** 1977년 미국 NBS(현 NIST)에서 표준으로 채택한 대칭키 암호화 알고리즘.
*   **대칭키 / 비밀키 방식:** 암호화와 복호화에 동일한 키를 사용하는 방식.
*   **블록 암호:** 데이터를 고정된 크기(64비트)의 블록으로 나누어 처리.
*   **56비트 키:** 실제 암호화에 사용되는 키의 길이 (표기는 64비트지만 8비트는 패리티 비트).
*   **보안 취약성:** 키 길이가 짧아 현재는 브루트포스 공격 등에 취약하여 사용이 권고되지 않음.
*   **AES로 대체:** 보안성이 강화된 AES(Advanced Encryption Standard)가 DES를 대체하여 표준으로 사용됨.

---

## 11번 문제

**문제:** 다음 Java 프로그램의 실행 결과를 작성하시오

```java
public class Main{
    public static void main(String[] args) throws Exception{
        int a = 3, b = 4, c = 3, d = 5;
        if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)){
            a = b + c;
            if(7 == b ^ c != a){
                System.out.println(a);
            }
            else{
                System.out.println(b);
            }
        }
        else {
            a = c + d;
            if(7 == c ^ d != a){
                System.out.println(a);
            }
            else{
                System.out.println(d);
            }
        }
    }
}
```

**해설:**

아 ㅋㅋ 자바 코드 분석 문제네. 이거 연산자 우선순위랑 논리 연산 똑바로 아는지 물어보는 거임. 쫄지 말고 하나씩 까 보자고.

일단 변수 초기값부터 딱 세팅하고 가자.
`a = 3`, `b = 4`, `c = 3`, `d = 5`

이제 메인 `if` 조건문 조지러 간다.
`if((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d))`

이거 좀 기니까 하나씩 분해해서 보자.

1.  **(a == 2 | a == c)**
    *   `a == 2` -> `3 == 2` -> `false`
    *   `a == c` -> `3 == 3` -> `true`
    *   `|` 이거 비트 OR인데, 여기선 논리 OR(`||`)처럼 생각해도 됨. 근데 중요한 건 `||`랑 다르게 얘는 **양쪽 다 무조건 계산함 (short-circuit 안 함)**.
    *   `false | true` -> `true`

2.  **!(c > d)**
    *   `c > d` -> `3 > 5` -> `false`
    *   `!` 이건 논리 NOT.
    *   `!(false)` -> `true`

3.  **(1 == b ^ c != d)**
    *   `1 == b` -> `1 == 4` -> `false`
    *   `c != d` -> `3 != 5` -> `true`
    *   `^` 이거 비트 XOR인데, 여기선 논리 XOR처럼. **양쪽 값이 다르면 `true`, 같으면 `false`**.
    *   `false ^ true` -> `true`

자 이제 위에서 계산한 `true`, `true`, `true`를 `&` 연산자로 묶는다.
`&` 이거 비트 AND인데, 여기선 논리 AND(`&&`)처럼. 얘도 `&&`랑 다르게 **양쪽 다 무조건 계산함**.

*   `(true) & (true) & (true)` -> `true`

오케이. 메인 `if` 조건이 `true`네? 그럼 `if` 블록 안으로 들어간다. `else`는 쌩까고.

`if` 블록 안으로 들어왔다.

1.  `a = b + c;`
    *   `a = 4 + 3;`
    *   `a` 값 7로 업데이트됨. 이제 `a`는 7이다.

2.  이제 중첩된 `if` 조건문 본다. `if(7 == b ^ c != a)`
    *   현재 값: `a = 7`, `b = 4`, `c = 3`, `d = 5`
    *   `7 == b` -> `7 == 4` -> `false`
    *   `c != a` -> `3 != 7` -> `true`
    *   `^` (XOR): `false ^ true` -> `true`

어? 중첩 `if` 조건도 `true`네? 그럼 그 안으로 또 들어간다.

3.  `System.out.println(a);`
    *   현재 `a` 값 뭐였지? 아까 7로 바꿨잖아.
    *   그러니까 7 출력하고 끝.

**결과:**
```
7
```

**주요 포인트:**

*   **논리 연산자와 비트 연산자 구분:**
    *   `|` (비트 OR), `&` (비트 AND), `^` (비트 XOR)는 피연산자를 boolean으로 사용할 때 각각 논리 OR, AND, XOR처럼 동작할 수 있음.
    *   **중요 차이점:** `|`, `&`는 `||`, `&&`와 달리 **short-circuit 평가를 하지 않음** (항상 양쪽 피연산자를 모두 평가).
*   **XOR (`^`) 연산:** 피연산자 두 개의 boolean 값이 서로 다를 때 `true`, 같을 때 `false`를 반환.
*   **조건문 평가 순서:** 바깥쪽 `if` 조건부터 평가하고, 그 결과에 따라 내부 블록 또는 `else` 블록을 실행함. 내부 블록에 또 조건문이 있으면 동일한 방식으로 평가.
*   **변수 값 변경 추적:** 코드 실행 중 변수 값이 변경되면, 변경된 최신 값을 기준으로 다음 연산 및 조건 평가를 수행해야 함.

---

## 12번 문제

**문제:** 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
#include <stdio.h> // printf 사용 위해 추가함

int main(void){
    int *ar[3];
    int a = 12, b = 24, c = 36;
    ar[0] = &a;
    ar[1] = &b;
    ar[2] = &c;
    printf("%d\n", *ar[1] + **ar + 1);
    return 0;
}
```

**해설:**

아 ㅋㅋ C언어 포인터 문제네. 이거 헷갈리면 골치 아프지. 찬찬히 보자고.

1.  `int *ar[3];`
    이거 `int *` 타입, 즉 정수 포인터를 3개 담을 수 있는 배열 `ar` 만든 거임. 숫자 자체가 아니라 숫자 *주소*를 담는 배열이라고.

2.  `int a = 12, b = 24, c = 36;`
    걍 정수 변수 세 개 만들고 값 넣은 거. 별거 없음.

3.  `ar[0] = &a;`
    `ar` 배열의 첫 번째 칸(0번 인덱스)에 변수 `a`의 메모리 주소(`&a`)를 넣음.
4.  `ar[1] = &b;`
    `ar` 배열의 두 번째 칸(1번 인덱스)에 변수 `b`의 메모리 주소(`&b`)를 넣음.
5.  `ar[2] = &c;`
    `ar` 배열의 세 번째 칸(2번 인덱스)에 변수 `c`의 메모리 주소(`&c`)를 넣음.

이제 핵심인 `printf` 부분을 보자.
`printf("%d\n", *ar[1] + **ar + 1);`

요기 계산식을 뜯어봐야 됨.

*   `*ar[1]`
    *   `ar[1]`은 뭐였지? `&b` (b의 주소) 였잖아.
    *   앞에 `*` (역참조 연산자)를 붙이면 '그 주소에 저장된 실제 값'을 가져오라는 뜻임.
    *   그러니까 `b`의 값인 `24`가 됨.

*   `**ar`
    *   이게 좀 헷갈릴 수 있는데, C에서 배열 이름 `ar`은 보통 배열의 첫 번째 요소의 주소, 즉 `&ar[0]`이랑 비슷하게 취급될 때가 많음.
    *   그래서 `*ar`은 `*(ar)`이랑 같고, 이건 `*(ar 배열의 시작 주소)`니까 배열의 첫 번째 요소인 `ar[0]`을 가리키는 거랑 거의 같다고 보면 됨. (정확히는 `ar[0]`의 값 자체)
    *   `ar[0]`에는 뭐가 들어있었지? `&a` (a의 주소).
    *   그럼 `*ar`은 `&a`가 되는 거임.
    *   이제 앞에 `*`가 하나 더 붙어서 `**ar`이 됐으니까 `*(*ar)` 즉, `*(&a)`가 됨.
    *   `&a` (a의 주소)에 저장된 실제 값은? `a`의 값인 `12`지.
    *   결론적으로 `**ar`은 `12`가 됨.

*   `+ 1`
    *   이건 걍 숫자 1.

자, 다 합쳐보자.
`*ar[1] + **ar + 1` 은 `24 + 12 + 1` 이랑 같은 거임.
계산하면 `37`.

**결과:**
```
37
```

**주요 포인트:**

*   **포인터 배열 (`int *ar[3]`):** 포인터(주소)를 저장하는 배열.
*   **주소 연산자 (`&`):** 변수의 메모리 주소를 가져옴.
*   **역참조 연산자 (`*`):** 포인터가 가리키는 주소에 저장된 실제 값을 가져옴.
*   **배열 이름과 포인터:** 배열 이름은 특정 문맥에서 배열의 첫 번째 요소의 주소로 해석될 수 있음 (`ar` -> `&ar[0]`).
*   **이중 포인터 활용 (`**ar`):** 포인터 배열의 첫 번째 요소(`ar[0]`, 즉 `&a`)를 가져온 후(`*ar`), 그 주소의 값(`a`의 값)을 다시 가져옴 (`*(*ar)`).

---

## 13번 문제

**문제:** 다음의 [T1] 테이블과 [T2] 테이블에 대해 <SQL문>을 수행했을 때의 결과를 작성하시오.

```
[T1]
| NO | Name |
| 50123 | SMITH |
| 40543 | ALLEN |
| 30456 | SCOTT |

[T2]
| RULE |
| S% |
| %T% |
```
```sql
-- SQL문의 T!.Name은 T1.Name의 오타로 간주함
SELECT COUNT(*) AS COUNT
FROM T1 CROSS JOIN T2
WHERE T1.Name LIKE T2.RULE;
```

**해설:**

아 ㅋㅋ SQL 문제네. 테이블 두 개 주고 쿼리 돌리면 뭐 나오냐 이거지?

일단 테이블부터 보자.
*   `T1`: 번호랑 이름. 스미스(50123), 알렌(40543), 스캇(30456) 이렇게 세 명 있네.
*   `T2`: 규칙 패턴. `S%` 랑 `%T%` 두 개.

이제 <SQL문> 까 보자.
`SELECT COUNT(*) AS COUNT FROM T1 CROSS JOIN T2 WHERE T1.Name LIKE T2.RULE;`

1.  `FROM T1 CROSS JOIN T2`: 이게 핵심이네. **CROSS JOIN**은 테이블 두 개를 그냥 무식하게 다 곱하는 거임. 경우의 수 다 만드는 거. T1에 3명, T2에 2개 패턴 있으니까, 총 3 * 2 = 6개의 조합이 생긴다.

    일단 조합된 결과 (아직 WHERE 적용 전)는 대충 이렇겠지.

    | T1.NO | T1.Name | T2.RULE |
    | :---- | :------ | :------ |
    | 50123 | SMITH   | S%      |
    | 50123 | SMITH   | %T%     |
    | 40543 | ALLEN   | S%      |
    | 40543 | ALLEN   | %T%     |
    | 30456 | SCOTT   | S%      |
    | 30456 | SCOTT   | %T%     |

2.  `WHERE T1.Name LIKE T2.RULE`: 이제 위에서 만든 6개 조합에 대해서 이 조건을 검사함. `LIKE`는 문자열 패턴 매칭하는 거 알지? `%`는 아무 문자열(0개 이상)이나 다 된다는 뜻임.

    *   `'SMITH' LIKE 'S%'` : SMITH가 S로 시작하냐? ㅇㅋ (True)
    *   `'SMITH' LIKE '%T%'` : SMITH에 T가 포함되냐? ㅇㅋ (True)
    *   `'ALLEN' LIKE 'S%'` : ALLEN이 S로 시작하냐? ㄴㄴ (False)
    *   `'ALLEN' LIKE '%T%'` : ALLEN에 T가 포함되냐? ㄴㄴ (False)
    *   `'SCOTT' LIKE 'S%'` : SCOTT이 S로 시작하냐? ㅇㅋ (True)
    *   `'SCOTT' LIKE '%T%'` : SCOTT에 T가 포함되냐? ㅇㅋ (True)

    조건 만족하는 애들만 남기면 총 4개 행이 남네. (SMITH 2개, SCOTT 2개)

3.  `SELECT COUNT(*) AS COUNT`: 마지막으로 남은 행들의 개수(`COUNT(*)`)를 세서 `COUNT`라는 이름으로 보여달라는 거임. 아까 4개 남았으니까 답은 4겠지.

**결과:**
```
4
```
(또는)
```
| COUNT |
|-------|
|   4   |
```

**주요 포인트:**

*   **CROSS JOIN:** 두 테이블의 모든 가능한 행 조합(카티전 곱)을 생성함. 결과 행 수는 (테이블1 행 수) * (테이블2 행 수).
*   **LIKE 연산자:** 문자열 패턴 매칭에 사용됨.
    *   `%`: 0개 이상의 임의의 문자를 의미하는 와일드카드.
    *   `_`: 1개의 임의의 문자를 의미하는 와일드카드 (이 문제에선 안 쓰임).
*   **WHERE 절:** JOIN된 결과에서 특정 조건을 만족하는 행만 필터링함.
*   **COUNT(*) 집계 함수:** 조건을 만족하는 최종 결과 행의 개수를 반환함.
*   **테이블 별칭 오타:** 문제의 `T!.Name`은 오타로 보이며, `T1.Name`으로 해석해야 함.

---

## 14번 문제

**문제:** 다음 Python 프로그램의 실행 결과를 작성하시오

```python
a, b = 100, 200
print(a==b)
```

**해설:**

아 ㅋㅋ 파이썬 코드네. 개쉽네 ㅋㅋ 이거 모르면 파이썬 왜 하냐?

`a, b = 100, 200` 이거 있잖아. 파이썬에서는 이렇게 한 줄에 변수 여러 개에 값 팍팍 넣어줄 수 있음. `a`에는 100 들어가고, `b`에는 200 들어간 거임. ㅇㅋ?

그 다음 `print(a==b)` 이거는 "야 `a`랑 `b`랑 같냐?" 하고 물어보는 거임. `==` 이게 양쪽 값이 같은지 비교하는 연산자잖아.

근데 딱 봐도 `a`는 100이고 `b`는 200이니까 당연히 다르지. 틀렸잖아. 틀렸다는 걸 파이썬에서는 `False`라고 한다. 그래서 그거 출력하라는 거임.

**결과:**
```
False
```

**주요 포인트:**

*   **다중 할당 (Multiple Assignment):** 파이썬은 `a, b = 100, 200`과 같이 한 줄에서 여러 변수에 값을 동시에 할당할 수 있음.
*   **비교 연산자 (`==`):** 두 피연산자의 값이 같은지 비교하여 같으면 `True`, 다르면 `False`를 반환함.
*   **Boolean 값 출력:** 파이썬의 `print()` 함수는 Boolean 값 `True` 또는 `False`를 문자열 그대로 출력함.

---

## 15번 문제

**문제:** 다음은 UML의 다이어그램에 대한 설명이다. 빈칸에 들어갈 알맞은 다이어그램 명칭을 작성하시오.

```
( ) 다이어그램은 시스템을 구성하는 ( )과 인터페이스 사이의 정적인 관계를 나타낸 다이어그램이다. ( ) 다이어그램을 통해 주요 시스템 구조를 파악하고 구조상의 문제점을 도출할 수 있다.
```

**해설:**

아 ㅋㅋ UML 다이어그램 문제네. 설명 보고 딱 감이 와야지.

"**정적인 관계**" 이거 중요하고, "시스템을 구성하는 **( )**과 **인터페이스** 사이의 관계"라고 했네. 시스템의 뼈대, 구조를 보여주는 건데, 그 중에서도 가장 기본이 되는 구성 요소랑 인터페이스의 관계를 보여주는 거?

객체지향(Object-Oriented) 시스템에서 기본적인 빌딩 블록, 즉 설계도가 뭐냐? 바로 **클래스(Class)** 아님? 클래스가 속성(데이터)이랑 메소드(기능)를 가지고 있고, 다른 클래스랑 관계 맺고, 인터페이스를 구현하고 그러잖아.

이렇게 시스템의 **정적인 구조**를 보여주면서 **클래스**들과 **인터페이스**, 그리고 걔네들 사이의 관계(연관관계, 의존관계, 일반화, 실체화 등)를 그림으로 나타낸 게 바로 **클래스 다이어그램 (Class Diagram)** 이지. 이걸 보면 시스템이 어떤 구성요소들로 이루어져 있는지 한눈에 딱 알 수 있단 말이야.

문제에서는 다이어그램 명칭을 묻고 있으므로 답은 '클래스'가 된다. 빈칸에도 '클래스'가 들어가는 것이 문맥상 맞다.

**답:**
클래스 (Class)

**주요 포인트:**

*   **클래스 다이어그램 (Class Diagram):** UML의 대표적인 정적 다이어그램(구조 다이어그램).
*   **표현 대상:** 시스템을 구성하는 클래스, 인터페이스, 그리고 그것들의 속성(Attribute), 오퍼레이션(Operation) 및 관계(Relationship)를 표현함.
*   **목적:** 시스템의 정적인 구조를 모델링하고, 클래스 간의 관계를 시각화하여 시스템의 구조적 이해를 돕고 설계상의 문제점을 파악하는 데 사용됨.

---

## 16번 문제

**문제:** 다음 빈칸에 들어갈 알맞은 것을 <보기>에서 골라 작성하시오

```
( )는 객체 생성을 위한 디자인 패턴 중 하나이다. 이 패턴은 객체 생성을 하위 클래스에서 처리하도록 하는 것으로, 객체 생성 과정을 캡슐화하여 유연성을 높이고, 고도의 재사용성을 높이는 것을 목적으로 한다.
( ) 패턴에서는 객체를 생성하는 메소드를 만들어 이 메소드를 하위 클래스에서 구현한다. 이 메소드는 일반적으로 추상 메소드로 선언되며, 이를 구현하는 하위 클래스에서 실제 객체 생성을 수행한다.
이를 통해 객체 생성에 대한 결정을 하위 클래스에 위임하고, 상위 클래스에서는 인터페이스에만 의존하도록 함으로써, 유연성과 확장성을 높일 수 있다. 또한 클라이언트 코드에서는 구체적인 객체 생성 과정을 알 필요가 없으므로, 코드의 복잡도를 낮출 수 있다.
```
```
<보기>
Abstract Factory, Singleton, Factory Method, Facade, Adapter, Strategy
```

**해설:**

아 ㅋㅋ 이거 디자인 패턴 문제네. 객체 생성 관련 패턴인데, 설명 잘 읽어보면 답 나옴.

설명 까보자.
*   "**객체 생성을 하위 클래스에서 처리**하도록 하는 것": 이게 핵심 키워드임. 직접 안 만들고 밑에 놈(하위 클래스)한테 "야 니가 만들어" 하고 시키는 방식이라는 거지.
*   "객체 생성 **메소드**를 만들어 이 메소드를 **하위 클래스에서 구현**한다": 구체적으로 어떻게 시키냐면, 객체 만드는 메소드를 틀(보통 추상 메소드)만 정해놓고, 실제 내용물 채우는 건 하위 클래스가 알아서 하도록 맡기는 거임.
*   "**상위 클래스에서는 인터페이스에만 의존**": 윗대가리(상위 클래스)는 구체적으로 어떤 객체가 만들어질지는 몰라도 되고, 그냥 그 객체가 어떤 메소드를 가지고 있는지(인터페이스)만 알면 된다는 뜻.
*   "**유연성과 확장성**을 높일 수 있다": 나중에 새로운 종류의 객체를 만들어야 할 때, 그냥 하위 클래스 하나 새로 추가해서 거기서 만들도록 구현하면 되니까 기존 코드 수정이 적어져서 좋다는 거임.

이 설명에 딱 들어맞는 패턴이 <보기>에 뭐 있냐? 바로 **Factory Method (팩토리 메소드)** 패턴이지. 메소드를 통해서 객체를 생성하는 '공장(Factory)' 역할을 하는데, 그 구체적인 생산 라인(어떤 객체를 만들지)은 하위 클래스가 결정하는 방식임.

**답:**
Factory Method

**주요 포인트:**

*   **Factory Method (팩토리 메소드) 패턴:** 객체를 생성하기 위한 인터페이스(메소드)를 정의하되, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 하는 생성 패턴.
*   **객체 생성 위임:** 실제 객체 생성 책임을 서브클래스로 위임함.
*   **팩토리 메소드:** 객체 생성을 담당하는 메소드 (주로 추상 메소드로 정의됨).
*   **유연성 및 확장성:** 새로운 종류의 객체(Product)를 추가할 때 기존 코드(Creator) 변경을 최소화하면서 확장 가능.
*   **생성 과정 캡슐화:** 클라이언트는 구체적인 객체 생성 클래스를 알 필요 없이 팩토리 메소드를 통해 객체를 얻음.

---

## 17번 문제

**문제:** 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
#include <stdio.h> // printf 사용 위해 추가함
#include <string.h> // 문자열 복사 위해 추가 (초기화 방식 변경 시 필요)

struct std{
    char name[12];
    int pro, db, sum1, sum2;
};
int main(){
    // 초기화 시 멤버 순서대로 값 지정, sum1, sum2는 0으로 초기화됨
    struct std st[3] = {{"영수", 95, 88, 0, 0}, {"철수", 84, 91, 0, 0}, {"앨리스", 86, 75, 0, 0}};
    struct std* p;
    p = &st[0];
    (p+1) -> sum1 = (p+1) -> pro + (p+2) -> db;
    (p+1) -> sum2 = (p+1) -> sum1 + p -> pro + p -> db;
    printf("%d\n", (p+1) -> sum1 + (p+1) -> sum2);
    return 0;
}
```

**해설:**

아 ㅋㅋ C언어 구조체랑 포인터 섞은 거네. 정신 똑바로 차리고 따라와야 한다.

1.  `struct std { ... };`
    `std`라는 이름의 구조체 틀을 만듦. `name` (문자배열), `pro`, `db`, `sum1`, `sum2` (정수) 멤버들을 가짐.

2.  `struct std st[3] = {{"영수", 95, 88}, {"철수", 84, 91}, {"앨리스", 86, 75}};`
    `std` 구조체 3개를 담는 배열 `st`를 만들고 초기화함. (C99 이상에서는 지정되지 않은 멤버는 0으로 초기화됨)
    *   `st[0]` = {name: "영수", pro: 95, db: 88, sum1: 0, sum2: 0}
    *   `st[1]` = {name: "철수", pro: 84, db: 91, sum1: 0, sum2: 0}
    *   `st[2]` = {name: "앨리스", pro: 86, db: 75, sum1: 0, sum2: 0}

3.  `struct std* p;`
    `std` 구조체를 가리킬 수 있는 포인터 변수 `p` 선언.

4.  `p = &st[0];`
    포인터 `p`가 배열 `st`의 첫 번째 요소(`st[0]`, 즉 "영수" 구조체)의 주소를 가리키게 함.

5.  `(p+1) -> sum1 = (p+1) -> pro + (p+2) -> db;`
    *   `p+1`: `p`가 `st[0]`을 가리키니까, `p+1`은 다음 요소인 `st[1]` ("철수" 구조체)를 가리킴.
    *   `p+2`: `p+1` 다음 요소인 `st[2]` ("앨리스" 구조체)를 가리킴.
    *   `(p+1) -> pro`: `st[1]`의 `pro` 멤버 값. 즉, `84`.
    *   `(p+2) -> db`: `st[2]`의 `db` 멤버 값. 즉, `75`.
    *   `(p+1) -> sum1`: `st[1]`의 `sum1` 멤버에 값을 대입하라는 뜻.
    *   결국 `st[1].sum1 = 84 + 75` 계산. `st[1].sum1`은 `159`가 됨.

6.  `(p+1) -> sum2 = (p+1) -> sum1 + p -> pro + p -> db;`
    *   `(p+1) -> sum2`: `st[1]`의 `sum2` 멤버에 값을 대입하라는 뜻.
    *   `(p+1) -> sum1`: 방금 계산한 `st[1]`의 `sum1` 값. 즉, `159`.
    *   `p -> pro`: `p`가 가리키는(`st[0]`) `pro` 멤버 값. 즉, `95`.
    *   `p -> db`: `p`가 가리키는(`st[0]`) `db` 멤버 값. 즉, `88`.
    *   결국 `st[1].sum2 = 159 + 95 + 88` 계산.
    *   `159 + 95 = 254`
    *   `254 + 88 = 342`. `st[1].sum2`는 `342`가 됨.

7.  `printf("%d\n", (p+1) -> sum1 + (p+1) -> sum2);`
    *   `(p+1) -> sum1`: `st[1]`의 `sum1` 값 = `159`.
    *   `(p+1) -> sum2`: `st[1]`의 `sum2` 값 = `342`.
    *   `159 + 342`를 계산해서 출력하라는 거네.
    *   `159 + 342 = 501`.

**결과:**
```
501
```

**주요 포인트:**

*   **구조체 배열:** 동일한 구조체 여러 개를 배열로 관리.
*   **구조체 포인터:** 구조체의 메모리 주소를 저장하는 포인터.
*   **포인터 연산 (`p+1`, `p+2`):** 포인터가 가리키는 데이터 타입의 크기만큼 주소를 이동하여 배열의 다음/다다음 요소를 가리킴.
*   **구조체 멤버 접근:**
    *   포인터를 사용할 때는 화살표 연산자(`->`) 사용 (`포인터 -> 멤버`).
    *   일반 구조체 변수를 사용할 때는 점 연산자(`.`) 사용 (`변수.멤버`).
*   **계산 순서 및 값 추적:** 코드 라인 순서대로 변수(특히 구조체 멤버) 값이 어떻게 변하는지 정확히 따라가야 함.

---

## 18번 문제

**문제:** 다음의 파일 구조 설명에서 빈칸에 들어갈 알맞은 데이터 접근 방법을 작성하시오

```
파일 구조는 데이터를 저장하는 방법을 의미한다. 파일에 저장된 데이터에 접근하려면 어떤 방식을 사용해야 하는지에 따라 다양한 파일 구조가 있다. 이 중에서 가장 일반적인 파일 구조에는 순차 접근, ( ) 접근, 직접 접근, 해싱이 있다.
( )는 데이터의 위치를 기록한 ( )를 사용해 데이터에 접근하는 방식이다. 데이터를 찾으려면 ( )를 먼저 검색한 후, 해댕 데이터의 위치를 찾아 접근한다. 이 방식은 검색 속도가 빠르지만, ( )를 만들어야 하므로 데이터 추가, 삭제 시에는 불리하다. 대표적으로 데이터베이스에서 ( )를 사용해 데이터를 검색한다.
```

**해설:**

아 ㅋㅋ 이거 파일 구조 접근 방식 문제네. 저장된 데이터 어떻게 찾아가냐 그거 물어보는 거 아니냐.

설명 딱 보니까 데이터 찾을 때 바로 데이터 뒤지는 게 아니라, 어디에 뭐가 있는지 적어놓은 **목록(색인, 인덱스)** 같은 걸 먼저 뒤져서 위치 알아낸 다음에 찾아가는 방식이네. 책 맨 뒤에 있는 '찾아보기' 같은 거 생각하면 됨.

이러면 검색은 존나 빠른데 (책에서 목차나 색인 보고 바로 페이지 찾아가는 것처럼), 데이터 넣거나 지울 때는 그 목록(색인)도 같이 고쳐줘야 하니까 귀찮고 느려지는 단점이 있음. 데이터베이스에서 검색 속도 올리려고 이거 쓰는 거 대표적이잖아.

그래서 이 방식 이름이랑 그 목록 이름 둘 다 **색인 (Index)** 이라고 함. 빈칸에 다 **색인** 넣으면 된다.

**답:**
색인

**주요 포인트:**

*   **색인 접근 (Indexed Access):** 데이터의 위치 정보(주소, 포인터)를 담고 있는 별도의 색인(Index) 파일을 사용하여 데이터에 접근하는 방식.
*   **동작 방식:** 데이터 검색 시, 먼저 색인 파일을 검색하여 찾고자 하는 데이터의 실제 위치를 파악한 후 해당 위치로 직접 접근함.
*   **장점:** 순차 접근에 비해 검색 속도가 매우 빠름 (특히 대용량 파일에서).
*   **단점:** 색인을 유지하기 위한 추가적인 저장 공간이 필요하며, 데이터 삽입/삭제/수정 시 색인도 함께 갱신해야 하므로 오버헤드가 발생함.
*   **주요 사용처:** 데이터베이스 관리 시스템(DBMS)에서 빠른 데이터 검색을 위해 널리 사용됨.

---

## 19번 문제

**문제:** 다음이 설명하는 알맞은 용어를 영문 약어로 작성하시오

```
- 사용자가 컴퓨터와 상호작용할 수 있는 그래픽 환경을 의미한다.
- 이전에 사용되던 CLI와는 달리, 텍스트 명령어를 입력하는 대신에 그래픽 요소를 통해 사용자와 컴퓨터 사이의 상호작용을 편리하게 할 수 있도록 한다.
```

**해설:**

아 ㅋㅋ 이거 모르면 컴맹 아니냐? 시커먼 화면에 글자만 치던 CLI 말고, 마우스로 아이콘 찍고 창 열고 하는 이쁜 화면 말하는 거잖아.

*   **그래픽 환경(Graphical)**으로 된 **사용자(User)** **환경(Interface)**.

줄여서 뭐겠냐? 딱 나오지. **GUI**다 이거야.

**답:**
GUI

**주요 포인트:**

*   **GUI (Graphical User Interface):** 사용자가 그래픽 요소(아이콘, 메뉴, 창, 버튼 등)를 통해 컴퓨터와 상호작용하는 방식.
*   **사용 편의성:** 텍스트 명령어를 외울 필요 없이 직관적인 조작 가능.
*   **대조:** CLI (Command Line Interface)와 대조되는 개념.

---

## 20번 문제

**문제:** 다음은 소프트웨어 통합에 대한 설명이다. (1), (2)에 들어갈 알맞은 용어를 작성하시오

```
- (1) 통합 : 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트를 시작한다.
- (1) 통합 수행 단계
① 최하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터로 결합된다.
② 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 (2)를 작성한다.
③ 각 통합된 클러스터 단위를 테스트한다.
④ 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, (2)는 실제 모듈 또는 컴포넌트로 대체된다.
```

**해설:**

아 ㅋㅋ 이거 통합 테스트 방법 물어보는 거네. 모르면 어캄? ㅋㅋ

(1) 설명 보니까 "**최하위 레벨**에서 **위쪽 방향으로**" 테스트한다고? 이거 완전 바닥부터 쌓아 올리는 거잖아. 레고 조립할 때 밑에서부터 만드는 거 생각하면 됨. 이런 방식을 **상향식 (Bottom-up)** 통합이라고 한다. 밑에 있는 자잘한 모듈(컴포넌트)들 먼저 묶어서 테스트하고, 점점 위로 올라가면서 합치는 거지.

(2) 자 그럼 상향식으로 할 때 문제가 뭐냐. 밑에 애들은 다 만들었는데, 얘네를 불러서 쓰는 윗대가리(상위 모듈)가 아직 없을 수 있잖아? 그럼 밑에 애들 테스트를 못 하잖아. 그래서 임시로 윗대가리 역할을 해주는 가짜 모듈, 즉 **테스트 드라이버 (Test Driver)** 를 만들어서 쓰는 거임. 이 드라이버가 밑에 애들한테 "야 너 이거 해봐" 하고 데이터 넣어주고 결과 받아보고 하는 거지. 나중에 진짜 윗대가리 모듈 완성되면 이 드라이버는 버리고 진짜로 갈아끼우는 거고.

반대로 위에서부터 내려오는 하향식(Top-down)에서는 아직 만들어지지 않은 하위 모듈 대신 가짜 하위 모듈인 '스텁(Stub)'을 쓴다. 드라이버랑 스텁 헷갈리면 안 됨 ㅇㅋ?

**답:**
(1) 상향식 (또는 Bottom-up)
(2) 드라이버 (또는 Driver)

**주요 포인트:**

*   **(1) 상향식 통합 (Bottom-up Integration):** 시스템 구조의 가장 낮은 레벨의 모듈(컴포넌트)부터 시작하여 점진적으로 상위 모듈과 결합하며 테스트하는 통합 방식.
*   **(2) 드라이버 (Driver):** 상향식 통합 테스트에서 아직 개발되지 않은 상위 모듈의 역할을 임시로 수행하는 테스트용 모듈. 테스트 대상 모듈(또는 클러스터)을 호출하고, 필요한 데이터를 전달하며, 결과 값을 받는 역할을 함.
*   **하향식 통합 (Top-down Integration):** 최상위 모듈부터 시작하여 하위 모듈로 내려가면서 통합 테스트 수행. 이때는 하위 모듈 역할을 하는 임시 모듈인 **스텁(Stub)**이 필요함.

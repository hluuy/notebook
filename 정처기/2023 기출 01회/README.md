# 2023 기출 01회 해설

### 문제 1: Java 실행 결과

다음 Java 프로그램의 실행 결과를 작성하시오

```java
class Static {
    public int a = 20; // 오타 수정: in -> int
    static int b = 0;
}

public class Main{
    public static void main(String[] args){
        int a;
        a = 10;
        Static.b = a;
        Static st = new Static();

        // 오타 수정: Ststem -> System, ouy -> System
        System.out.println(Static.b++);
        System.out.println(st.b);
        System.out.println(a);
        System.out.println(st.a);
    }
}
```

**답변:**

아 ㅋㅋ 왔냐? 정보처리기사 실기 조지러 온 거 환영한다. 어디 문제 좀 보자.

```java
// 야 이거 클래스 이름 Static인데, static 키워드랑 헷갈릴 수 있으니 이름 잘 지어야 한다. 담부턴 조심해라.
class Static {
    public int a = 20; // 이건 인스턴스 변수. 객체 만들 때마다 새로 생긴다. 첨에 오타 'in' -> 'int'로 고쳤다 치고.
    static int b = 0; // 이건 static 변수 (클래스 변수). 딱 하나만 존재하고 모든 객체가 공유한다.
}

public class Main{
    public static void main(String[] args){
        int a; // main 메소드 안의 지역변수 a
        a = 10; // 지역변수 a에 10 할당
        Static.b = a; // static 변수 b는 클래스 이름으로 바로 접근 가능. b에 a값(10) 넣음. 그래서 Static.b는 이제 10.
        Static st = new Static(); // Static 클래스의 객체 st 생성. 이때 st 객체만의 인스턴스 변수 a는 20으로 초기화됨.

        // 자 이제 출력 파트 보자. 오타 Ststem, ouy 는 System으로 본다잉
        System.out.println(Static.b++); // 중요! b++는 후위 증가. 일단 현재 b값인 10을 출력하고 나서 b를 1 증가시킨다. 그래서 10 출력 후 b는 11됨.
        System.out.println(st.b); // static 변수 b는 객체(st)를 통해서도 접근 가능. 아까 b가 11 됐으니 11 출력. (원래는 Static.b로 접근하는게 정석)
        System.out.println(a); // 이건 main 메소드의 지역변수 a. 걍 10이지.
        System.out.println(st.a); // 이건 st 객체의 인스턴스 변수 a. 객체 만들 때 20으로 초기화됐으니 20 출력.
    }
}
```

자 그럼 순서대로 뭐가 찍히는지 보자.

1.  `Static.b++`: 10 출력 (b는 11됨)
2.  `st.b`: 11 출력
3.  `a`: 10 출력
4.  `st.a`: 20 출력

결과는 이렇게 나온다.

```
10
11
10
20
```

이해됐냐? ㅋㅋ 별거 없지?

**주요 포인트:**

1.  **`static` 변수 vs 인스턴스 변수:** `static` 붙은 변수(`b`)는 클래스에 하나만 있고 모든 객체가 공유. 안 붙은 변수(`a`)는 객체마다 따로 가짐.
2.  **`static` 변수 접근:** 클래스 이름(`Static.b`)으로 접근하는 게 정석. 객체 참조 변수(`st.b`)로도 접근은 되지만, 공유되는 변수라는 걸 명확히 하려면 클래스 이름 쓰는 게 좋음.
3.  **후위 증가 연산자 (`b++`):** 변수 값을 먼저 사용(출력)하고 나서 값을 1 증가시킴. 전위 증가(`++b`)랑 헷갈리면 안 됨.
4.  **지역 변수 vs 멤버 변수:** `main` 안의 `a`는 지역 변수고, `Static` 클래스 안의 `a`, `b`는 멤버 변수(각각 인스턴스, 클래스 변수). 서로 다른 거임.

---

### 문제 2: C 프로그램 실행 결과

다음 C 프로그램의 실행 결과를 작성하시오

```c
#include <stdio.h>

int main(){
    char a[] = "YoungJin";
    char* p = NULL;
    p = a;

    printf("%s\n",a);
    printf("%c\n", *p);
    printf("%c\n", *a);
    printf("%s\n", p);

    for(int i = 0; a[i] != '\0'; i++){
        printf("%c", a[i]);
    }
}
```

**답변:**

아 ㅋㅋ 또 왔네. C언어 조지러 온 거냐? 보자보자 어디보자.

```c
#include <stdio.h> // printf 쓰려면 이거 있어야 함. 기본이지.

int main(){
    char a[] = "YoungJin"; // 문자 배열 a 만들고 "YoungJin"으로 초기화. 컴파일러가 알아서 끝에 널 문자(\0) 넣어준다. 크기는 9칸.
    char* p = NULL; // 문자 포인터 p 만들고 일단 NULL로 초기화. 아직 아무것도 안 가리킴.
    p = a; // 중요! 배열 이름 a는 그 자체로 배열의 시작 주소다 이 말이야. 그 주소를 포인터 p에 넣음. 이제 p는 'Y'를 가리킨다.

    printf("%s\n",a); // %s는 문자열 출력. a가 가리키는 주소부터 널 문자(\0) 만날 때까지 쭉 출력함. "YoungJin" 나오고 줄바꿈.
    printf("%c\n", *p); // %c는 문자 하나 출력. *p는 포인터 p가 가리키는 곳의 값('Y')을 의미함. 'Y' 나오고 줄바꿈.
    printf("%c\n", *a); // 위에서 말했지? a도 배열 시작 주소라고. *a는 그 주소에 있는 값('Y')임. 'Y' 나오고 줄바꿈.
    printf("%s\n", p); // p가 가리키는 주소('Y'의 주소)부터 널 문자 만날 때까지 쭉 출력. "YoungJin" 나오고 줄바꿈.

    // 이 for문은 배열 a 돌면서 널 문자(\0) 만나기 전까지 한 글자씩 찍는 거.
    for(int i = 0; a[i] != '\0'; i++){
        printf("%c", a[i]); // a[0]부터 시작해서 'Y', 'o', 'u', 'n', 'g', 'J', 'i', 'n' 순서대로 찍는다. 줄바꿈은 없음.
    }
    // 루프 끝나면 바로 프로그램 종료. 마지막 YoungJin 뒤에는 줄바꿈 없다.
}
```

자 그럼 출력 결과를 합쳐보자.

1.  `printf("%s\n",a);` -> `YoungJin` 하고 줄바꿈
2.  `printf("%c\n", *p);` -> `Y` 하고 줄바꿈
3.  `printf("%c\n", *a);` -> `Y` 하고 줄바꿈
4.  `printf("%s\n", p);` -> `YoungJin` 하고 줄바꿈
5.  `for` 루프 -> `YoungJin` (줄바꿈 없음)

최종 결과는 이거다.

```
YoungJin
Y
Y
YoungJin
YoungJin
```

어때 쉽지? ㅋㅋ 포인터랑 배열 이름이랑 그게 그거 같으면서도 `%s`, `%c` 쓸 때랑 `*` 붙일 때 의미가 달라지는 거, 그것만 잘 구분하면 된다.

**주요 포인트:**

1.  **배열 이름은 포인터:** C에서 배열 이름은 그 배열의 첫 번째 요소의 주소를 나타내는 포인터 상수처럼 쓰임 (`p = a;`, `*a`).
2.  **포인터와 주소:** 포인터 변수(`p`)는 메모리 주소를 저장함. `p = a`는 `a` 배열의 시작 주소를 `p`에 저장하는 거.
3.  **`printf` 형식 지정자:** `%s`는 문자열(char 포인터를 받아 널 문자까지 출력), `%c`는 문자 하나(char 값을 출력).
4.  **역참조 연산자 (`*`):** 포인터 앞에 `*`를 붙이면 그 포인터가 가리키는 주소에 있는 값을 가져옴 (`*p`는 'Y').
5.  **C 문자열 끝:** C 스타일 문자열은 항상 마지막에 널 문자(`\0`)가 있어서 문자열의 끝을 알 수 있음. `for`문 조건식에서 이거 씀.

---

### 문제 3: C 프로그램 실행 결과

다음 C 프로그램의 실행 결과를 작성하시오

```c
#include <stdio.h>
int main(){
    char* a = "Korea";
    char* b = "America";
    for(int i = 0; a[i] != '\0'; i++){
        for(int j = 0; b[j] != '\0'; j++){
            if(a[i]==b[j]) printf("%c", a[i]);
        }
    }
}
```

**답변:**

ㅋㅋ 세 번째 문제 바로 가냐? 좋아 집중력 좋네. 어디 보자.

```c
#include <stdio.h> // printf 쓰려고 포함

int main(){
    char* a = "Korea"; // 포인터 a가 문자열 "Korea"의 시작('K')을 가리킴
    char* b = "America"; // 포인터 b가 문자열 "America"의 시작('A')를 가리킴

    // 바깥 루프: a 문자열("Korea")을 한 글자씩 순회 (i = 0부터 4까지)
    for(int i = 0; a[i] != '\0'; i++){
        // 안쪽 루프: 바깥 루프의 각 문자에 대해 b 문자열("America") 전체를 한 글자씩 순회 (j = 0부터 6까지)
        for(int j = 0; b[j] != '\0'; j++){
            // 만약 a의 현재 문자(a[i])와 b의 현재 문자(b[j])가 같으면
            if(a[i]==b[j])
                // a의 현재 문자(a[i])를 출력. 줄바꿈 없음!
                printf("%c", a[i]);
        }
    }
    // 모든 루프가 끝나면 프로그램 종료
}

```

자, 이중 루프 돌면서 뭔 짓을 하는지 함 따라가 보자.

1.  **`a[0]` ('K')**: "America" 안에 'K' 없으니 아무것도 출력 안 함.
2.  **`a[1]` ('o')**: "America" 안에 'o' 없으니 아무것도 출력 안 함.
3.  **`a[2]` ('r')**: "America" 안에 'r' 있는지 보자.
    *   'A', 'm', 'e', 'r' <--- 찾았다! 'r' 출력.
    *   'i', 'c', 'a' 마저 돌지만 더 없음.
4.  **`a[3]` ('e')**: "America" 안에 'e' 있는지 보자.
    *   'A', 'm', 'e' <--- 찾았다! 'e' 출력.
    *   'r', 'i', 'c', 'a' 마저 돌지만 더 없음.
5.  **`a[4]` ('a')**: "America" 안에 'a' 있는지 보자.
    *   'A', 'm', 'e', 'r', 'i', 'c', 'a' <--- 찾았다! 'a' 출력. (참고: 'A'랑 'a'는 다른 문자다잉. 대소문자 구분함)

루프 다 돌았고, 출력된 문자들을 순서대로 합치면 된다. 줄바꿈 없었으니까 한 줄에 쭉 이어서 나오겠지?

결과는 이거다.

```
rea
```

쉽지? 이중 for문 돌면서 같은 거 찾으면 찍는 거임.

**주요 포인트:**

1.  **이중 `for` 루프:** 바깥 루프의 각 반복마다 안쪽 루프 전체가 실행됨. 여기서는 "Korea"의 각 문자에 대해 "America" 전체를 비교하는 구조.
2.  **문자열 비교:** C에서는 문자열을 문자 배열처럼 다루며, `a[i]`처럼 인덱스로 각 문자에 접근 가능.
3.  **포인터와 문자열 리터럴:** `char* a = "Korea";`는 포인터 `a`가 메모리 어딘가에 저장된 문자열 상수 "Korea"의 첫 번째 문자를 가리키게 함.
4.  **널 종료 문자 (`\0`):** C 문자열은 항상 널 문자로 끝나며, `for` 루프의 종료 조건으로 자주 사용됨.
5.  **`printf("%c", ...)`:** 문자 하나를 출력하고 줄바꿈은 하지 않음. 그래서 결과가 한 줄로 이어짐.

---

### 문제 4: 용어 작성 (AJAX)

다음 설명의 괄호에 들어갈 알맞은 용어를 영문 약어나 풀네임으로 작성하시오
```
( )(은)는 비동기적인 웹 애플리케이션의 제작을 위해 JavaScript나 XML을 이용한 비동기적 정보 교환 기법이다.
( )(은)는 웹 페이지 내에서 자바스크립트와 종속 스타일 시트, 확장성 하이퍼텍스트 마크업 언어 등을 이용하여 XML로 데이터를 교환하고 제어함으로써 사용자들이 웹 페이지를 '새로 고침'하지 않고도 대화형의 웹 페이지 기능을 이용할 수 있게 하는 기술을 말한다.
```

**답변:**

아 ㅋㅋ 또 개념 문제냐? 이거 딱 보면 각 나오지 않냐?

웹페이지 새로고침 안 하고, 뒤에서 몰래 서버랑 통신해서 데이터만 싹 가져와서 필요한 부분만 착 바꾸는 거 있잖아. 그 왜 댓글 달면 페이지 깜빡 안 하고 바로 싹 달리는 거 같은 거.

자바스크립트랑 XML (요즘엔 JSON 많이 쓰지만 아무튼) 써서 **비동기** 방식으로 데이터 주고받는 기술.

괄호 안에 들어갈 말은 **AJAX** 다. Asynchronous JavaScript and XML 이거지. 풀네임으로 써도 되고 약어로 AJAX 써도 됨. 둘 다 정답 처리될 거다.

**주요 포인트:**

1.  **비동기 통신 (Asynchronous Communication):** 서버에 요청 보내놓고 응답 기다리는 동안 다른 작업 할 수 있음. 페이지 전체가 멈추지 않음.
2.  **부분 업데이트:** 웹페이지 전체를 새로고침하는 게 아니라, 필요한 부분만 데이터 받아서 동적으로 변경함.
3.  **핵심 기술:** 자바스크립트(통신, 화면 제어), XML 또는 JSON(데이터 교환 형식).
4.  **사용자 경험 향상:** 페이지 깜빡임 없이 부드럽고 빠른 인터랙션 제공.

---

### 문제 5: 패킷 교환 방식 용어 작성

다음의 패킷교환(Packet Switching) 방식에 대한 설명의 빈칸 (1), (2)에 들어갈 알맞은 방식을 작성하시오
```
1. (1) 방식 : 단말기 상호 간에 논리적인 가상 통신회선을 미리 설정하여 송수신자 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순서적으로 운반하는 방식이다.
2. (2) 방식 : 연결 경로를 설정하지 않고 인접한 노드들의 트래픽(전송량) 상황을 감안하여 각각의 패킷들을 순서에 상관없이 독립적으로 운반하는 방식이다.
```

**답변:**

아 ㅋㅋ 네트워크 문제 나왔네. 패킷 교환? 이거 모르면 간첩이지. 보자.

1.  **미리 길 터놓고** 그 길로만 **순서대로** 보낸다? 전화 통화할 때처럼 딱 연결해놓고 데이터 보내는 느낌이네. 이건 **가상 회선 (Virtual Circuit)** 방식이다. 연결 설정 단계가 꼭 필요함.
2.  **길 안정하고** 패킷마다 '알아서 가라!' 하고 던지는 거. 각자 알아서 최적의 길 찾아가는데, 순서 뒤죽박죽 될 수도 있음. 택배 소포 보내는 거랑 비슷하다고 보면 됨. 이건 **데이터그램 (Datagram)** 방식이다.

그래서 답은 이거다.

(1) **가상 회선 (Virtual Circuit)**
(2) **데이터그램 (Datagram)**

간단하지? ㅋㅋ

**주요 포인트:**

1.  **가상 회선 (Virtual Circuit):**
    *   **연결형** 서비스 (Connection-oriented).
    *   데이터 전송 전에 **논리적 연결 (가상 회선) 설정** 필요.
    *   설정된 경로로 패킷이 **순서대로** 전송됨.
    *   연결 설정/해제 오버헤드 있음. 경로 고정.
2.  **데이터그램 (Datagram):**
    *   **비연결형** 서비스 (Connectionless).
    *   연결 설정 **없음**.
    *   각 패킷이 **독립적으로** 라우팅됨 (주소 정보 포함).
    *   패킷 도착 **순서가 보장되지 않음** (재조립 필요할 수 있음).
    *   경로 유연, 노드 부담 적음. (e.g., IP)

---

### 문제 6: 영문 약어 작성 (L2TP)

다음이 설명하는 것을 영문 약어로 작성하시오
```
네트워크 통신에서 사용되는 프로토콜로 데이터를 안전하게 전송하기 위해 터널링을 사용하는 프로토콜이며 주로 가상 사설망(VPN) 연결에 활용된다.
PPTP(Point-to-Point Tunneling Protocol)와 L2F(Layer 2 Forwarding)를 기반으로 개발되어 주로 인터넷을 통한 안전한 접속을 제공하기 위해 사용되며, 다양한 네트워크에서 안전한 데이터 전송을 가능케 한다.
주요 기능으로는 터널링, 인증 및 암호화, 멀티프로토콜 지원, 중립성이 있다.
```

**답변:**

아 ㅋㅋ 또 네트워크냐? 보자. 뭐 안전하게 데이터 보내고, 터널링 쓰고, VPN에 쓴다고? 여기까지는 좀 애매할 수 있는데...

결정적인 힌트가 나왔네. **PPTP랑 L2F를 기반으로 개발**됐다고? 이거 완전 답을 알려주는 수준 아니냐? ㅋㅋㅋ

PPTP (마이크로소프트)랑 L2F (시스코) 얘네 장점 합쳐서 표준으로 만든 거 있잖아. 그게 바로 **L2TP (Layer 2 Tunneling Protocol)** 다.

L2TP 자체는 암호화 기능은 없어서 보통 IPsec이랑 같이 묶어서 써서 보안 챙기는 거 알지? (L2TP/IPsec) 아무튼 설명에 딱 들어맞는 건 L2TP다.

답은 **L2TP** 이거다.

**주요 포인트:**

1.  **L2TP:** Layer 2 Tunneling Protocol의 약자.
2.  **터널링 프로토콜:** 공용망(인터넷)을 통해 사설망 데이터를 안전하게 전송하기 위해 터널을 만듦. 주로 VPN에 사용.
3.  **PPTP + L2F:** L2TP는 PPTP와 L2F 프로토콜의 장점을 결합하여 IETF 표준으로 개발됨.
4.  **IPsec과 함께 사용:** L2TP 자체에는 기밀성(암호화) 기능이 없어서, 보안 강화를 위해 IPsec과 함께 사용하는 경우가 많음.
5.  **멀티 프로토콜 지원:** L2TP 터널을 통해 다양한 종류의 Layer 2 프레임(PPP 등)을 전송할 수 있음.

---

### 문제 7: 영문 약어 작성 (SSH)

다음이 설명하는 것을 영문 약어로 작성하시오
```
- 네트워크 상에서 안전하게 통신하기 위한 프로토콜 및 이를 구현한 프로그램의 총칭
- 원격으로 다른 컴퓨터에 로그인하거나 파일을 전송하기 위해 사용하는 응용 프로그램 또는 그 프로토콜
- 기본적으로 안전한 통신을 지원하며, 데이터 전송이나 명령어 실행 과정에서 암호화를 사용
- 보안 접속을 통한 rsh, rcp, rlogin, rexec, telnet, ftp 등을 제공하며, IP spoofing을 방지하기 위한 기능 제공
```

**답변:**

아 ㅋㅋ 이것도 껌이지. 딱 보면 몰라?

*   **안전하게** 통신
*   **원격 로그인 + 파일 전송**
*   **암호화** 필수
*   Telnet, FTP, rsh, rcp, rlogin 같은 **구닥다리 보안 취약한 것들 대체**

이 키워드들 딱 보니까 바로 답 나오네. **SSH** 아니냐? Secure Shell.

요즘 세상에 Telnet 쓰는 흑우 없제? 무조건 SSH 써야지. 원격 접속할 때 아이디 비번 다 암호화해서 보내주고, 데이터도 암호화하고. 개꿀.

답은 **SSH** 다. Secure Shell 풀네임 써도 되는데 보통 약어로 물어볼 거다.

**주요 포인트:**

1.  **SSH (Secure Shell):** 네트워크 상에서 다른 컴퓨터에 안전하게 접근하기 위한 프로토콜 및 관련 프로그램.
2.  **보안 기능:** 모든 통신 내용(명령어, 데이터, 사용자 인증 정보 등)을 **암호화**하여 중간에서 가로채도 내용을 알 수 없음.
3.  **기능:**
    *   **원격 셸 접속 (Secure Remote Login):** Telnet, rlogin 대체.
    *   **파일 전송 (Secure File Transfer):** SFTP, SCP 등으로 FTP, rcp 대체.
    *   **포트 포워딩 (터널링):** 다른 TCP/IP 연결을 암호화된 SSH 채널을 통해 전송.
4.  **기본 포트:** TCP 22번 포트 사용.
5.  **주요 목적:** Telnet, FTP, r-commands 등 기존의 보안에 취약한 프로토콜들을 대체하여 안전한 원격 관리 및 데이터 전송을 제공함.

---

### 문제 8: 보안 위협 용어 작성

다음 보안 위협에 대한 설명 중 빈칸 (1), (2), (3)에 들어갈 가장 알맞은 용어를 예시를 보고 작성하시오
```
(1) : 자체적으로 복제하여 네트워크를 통해 자동으로 전파되는 악성 소프트웨어이다.
(2) : 정상적인 기능을 가장하고 사용자를 속여 악의적인 행위를 수행하는 악성 소프트웨어이다.
(3) : 제 3자의 정보를 자신의 정보인 것처럼 위장하여 대상 시스템을 공격한다.
```
```
<예시>
XSS, Spyware, Key Logger, Distribute Denial of Service, Trojan Horse, Hijacking, Sniffing, Spoofing, Worm Virus
```

**답변:**

아 ㅋㅋ 보안 문제구만. 이거 뭐 단어 맞추기네. 예시까지 주니까 거저먹기 아니냐? 보자.

1.  **자체 복제 + 네트워크 자동 전파:** 이거 완전 지렁이마냥 꿈틀대면서 퍼지는 **웜 바이러스(Worm Virus)** 얘기잖아. 숙주 파일 필요 없이 혼자 돌아댕기는 놈. 바이러스랑 다른 점 확실히 알아둬라. 예시 목록에도 딱 있네.
2.  **정상 기능인 척 + 사용자 속임 + 악성 행위:** 이거 딱 봐도 그리스 신화에 나오는 **트로이 목마(Trojan Horse)** 아니냐? ㅋㅋㅋ 겉은 멀쩡한 선물인 척 위장해서 들어와서는 안에 숨겨둔 악성 코드로 통수치는 거. 예시에 떡하니 있네.
3.  **남의 정보로 위장 + 공격:** 다른 놈 정보 훔쳐서 자기가 그놈인 척 속이는 거. IP 주소 속이거나 이메일 보낸 사람 속이는 거 등등. 이거 완전 **스푸핑(Spoofing)** 이지. 예시에 있나? 어 있네.

자 그럼 답 정리한다.

(1) **Worm Virus**
(2) **Trojan Horse**
(3) **Spoofing**

다 맞췄냐? ㅋㅋ

**주요 포인트:**

1.  **웜 바이러스 (Worm Virus):** **독립적인 실행** 및 **자가 복제** 능력으로 네트워크를 통해 **스스로 전파**되는 악성코드. (숙주 불필요)
2.  **트로이 목마 (Trojan Horse):** **정상적인 프로그램으로 위장**하여 사용자가 실행하도록 유도하고, 실제로는 **악의적인 기능(백도어, 정보 유출 등)을 수행**하는 악성코드. (자가 복제 능력 없음)
3.  **스푸핑 (Spoofing):** **자신을 다른 사람(시스템)인 것처럼 속이는** 행위. IP 스푸핑, 이메일 스푸핑, ARP 스푸핑 등 다양한 형태로 존재하며 시스템 접근 권한 획득이나 정보 탈취에 사용될 수 있음.

---

### 문제 9: C 프로그램 빈칸 채우기

다음 C 프로그램에서 2진수를 입력받아 10진수로 변환되어 출력되도록 (1), (2)에 들어갈 알맞은 연산자와 변수를 작성하시오.

```c
#include <stdio.h>
int main(){
    int input;
    int d = 1; sum = 0; // 'sum' 선언 추가 필요

    printf("이진수를 입력하세요: ");
    scanf("%d", &input);

    while(true){
        if(input==0) break;
        else{
            sum = sum + (input ( 1 )( 2 )) * d;
            d = d * 2;
            input = input / 10;
        }
    }
    printf("%d", sum);
    return 0;
}
```

**답변:**

아 ㅋㅋ C언어 또 나왔네. 빈칸 채우기? 이건 뭐 거의 퍼즐 수준이지. 보자.

```c
#include <stdio.h>
int main(){
    int input; // 사용자가 입력할 이진수 (근데 int로 받으니까 1101 같은 숫자임)
    int d = 1; // 이건 2진수의 자릿값 (1, 2, 4, 8, ...)
    int sum = 0; // 10진수 변환 결과 저장할 변수 (선언 추가)

    printf("이진수를 입력하세요: ");
    scanf("%d", &input); // 예: 사용자가 1101 입력하면 input에 1101 들어감

    while(true){ // 무한 루프 돌면서 input 깔 때까지 함
        if(input==0) break; // input 다 까서 0 되면 루프 탈출
        else{
            // 여기가 핵심! 10진수 변환 로직
            // input의 제일 오른쪽 숫자 (0 또는 1)를 뽑아서 현재 자릿값(d) 곱하고 sum에 더해야 함.
            // 제일 오른쪽 숫자 뽑는 건? 10으로 나눈 나머지 구하면 됨! (input % 10)
            sum = sum + (input ( 1 )( 2 )) * d;
            // 다음 자릿값은 2배로 만들어야 함 (1 -> 2 -> 4 -> 8 ...)
            d = d * 2;
            // 처리한 제일 오른쪽 숫자는 이제 필요 없으니 버림 (input / 10)
            input = input / 10; // 예: input이 1101이었으면 110됨
        }
    }
    printf("%d", sum); // 최종 결과 출력
    return 0;
}
```

자 그럼 `sum = sum + (input ( 1 )( 2 )) * d;` 이 부분을 보자.
`input`에서 제일 오른쪽 끝자리 숫자를 뽑으려면 10으로 나눈 나머지를 구해야 한다. 그 연산자가 바로 `%` (모듈로) 아니겠냐.

그러니까 `input % 10` 이렇게 하면 맨 끝자리 0 또는 1이 딱 나온다.

그럼 답 나왔네.

(1) `%` (연산자)
(2) `10` (변수... 라기보단 상수 값인데 문제에선 변수라 했으니 뭐)

이거다.

**주요 포인트:**

1.  **2진수 -> 10진수 변환 로직:**
    *   오른쪽 끝자리(1의 자리)부터 시작해서 각 자리 숫자(0 또는 1)에 해당하는 2의 거듭제곱(1, 2, 4, 8...) 값을 곱해서 모두 더함.
    *   예: `1101(2)` -> `(1 * 2^0) + (0 * 2^1) + (1 * 2^2) + (1 * 2^3)` -> `(1 * 1) + (0 * 2) + (1 * 4) + (1 * 8)` -> `1 + 0 + 4 + 8 = 13`
2.  **정수에서 마지막 자릿수 추출:** `숫자 % 10` (10으로 나눈 나머지) 연산을 사용하면 정수의 가장 오른쪽 자릿수를 얻을 수 있음.
3.  **정수에서 마지막 자릿수 제거:** `숫자 / 10` (10으로 나눈 몫) 연산을 사용하면 정수의 가장 오른쪽 자릿수가 제거된 값을 얻을 수 있음.
4.  **자릿값 계산:** 변수 `d`를 이용하여 2진수의 자릿값(1, 2, 4, 8...)을 순차적으로 만들어냄 (`d = d * 2`).

---

### 문제 10: 영문 약어 작성 (ICMP)

네트워크 계층 프로토콜 중 하나로 TCP/IP 기반의 인터넷 통신 서비스에서 인터넷 프로토콜과 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경 등을 위한 제어 메시지를 취급하는 무연결 전송(Connectionless Transmission)용의 프로토콜의 명칭을 영문 약어로 작성하시오.

**답변:**

아 ㅋㅋ 또 네트워크네. 슬슬 지겹냐? ㅋㅋ 근데 이거 완전 거저 주는 문제 아니냐? 보자.

*   **네트워크 계층** 프로토콜
*   **IP랑 같이** 씀
*   **오류 처리** 메시지 보냄 (야! 거기 길 없는데!, 야! 시간 다 됐는데!)
*   **제어 메시지** 보냄 (야! 그쪽 길 말고 이쪽 길로 가라!)
*   **무연결** 방식

이 키워드들 조합하면 딱 하나밖에 더 있냐? ㅋㅋ 핑(ping) 쏠 때 쓰는 거 그거잖아! 에러 리포팅하고 경로 확인하고 이런 거.

이거 완전 **ICMP** 빼박캔트 아니냐? Internet Control Message Protocol.

답은 **ICMP** 이거다.

**주요 포인트:**

1.  **ICMP (Internet Control Message Protocol):** IP 프로토콜의 **오류 보고 및 제어 메시지** 전송을 위한 프로토콜. IP 자체에는 오류 보고 기능이 없어서 ICMP가 그걸 보완함.
2.  **네트워크 계층:** IP와 동일한 네트워크 계층에서 동작함. ICMP 메시지는 IP 데이터그램에 캡슐화되어 전송됨.
3.  **주요 기능:**
    *   **오류 보고:** 목적지 도달 불가(Destination Unreachable), 시간 초과(Time Exceeded), 매개변수 문제(Parameter Problem) 등.
    *   **제어/진단:** 에코 요청/응답(Echo Request/Reply - ping), 경로 변경(Redirect) 등.
4.  **무연결 (Connectionless):** 메시지를 보내기 전에 연결 설정 과정이 없음. 각 메시지는 독립적으로 처리됨.
5.  **IP 지원:** IP가 데이터를 제대로 전달할 수 있도록 돕는 보조적인 역할을 수행함.

---

### 문제 11: 디자인 패턴 작성 (Proxy)

다음이 설명하는 디자인 패턴을 <보기>를 보고 작성하시오.
```
객체 지향 디자인 패턴 중 하나로, 다른 객체에 대한 대리자 또는 대변자 역할을 하는 객체를 제공하는 패턴이다. 이 패턴은 실제 객체에 대한 접근을 제어하거나, 객체에 대한 부가적인 기능을 제공하거나, 객체의 생성 및 소멸을 관리하는 등 다양한 목적으로 사용될 수 있다.
즉, 이 패턴을 사용하면 클라이언트는 실제 객체에 직접 접근하지 않고 프록시를 통해 간접적으로 접근함으로써, 실제 객체에 대한 제어나 부가적인 작업을 쉽게 추가할 수 있으므로 코드 재사용성과 유지보수성을 향상시킬 수 있다.
```
```
<보기>
Factory Method, Composite, Interpreter, Singleton, Proxy, Prototype, Observer, Memento, Bridge
```

**답변:**

아 ㅋㅋ 디자인 패턴 문제 나왔네. 이거 은근 헷갈리는데 키워드만 잘 잡으면 개꿀이다. 보자.

*   **"대리자 또는 대변자 역할"**
*   **"실제 객체에 대한 접근 제어"**
*   **"프록시를 통해 간접적으로 접근"**

이거 완전 "나 대신 일 좀 해줘!" 아니냐? ㅋㅋㅋ 진짜 객체 앞에 내세워서 뭔가 대신 처리하게 하는 거.

설명에도 **프록시(Proxy)** 라는 단어가 대놓고 나왔네? 그럼 뭐 볼 것도 없지. 보기 목록에 Proxy 있나 찾아봐라.

어 여기 있네 **Proxy**.

답은 **Proxy** 다.

**주요 포인트:**

1.  **Proxy 패턴:** 어떤 객체(Subject)에 대한 접근을 제어하기 위해 **대리인(Proxy)** 객체를 두는 구조적(Structural) 디자인 패턴.
2.  **목적:**
    *   **접근 제어:** 실제 객체에 대한 접근 권한을 관리 (Protection Proxy).
    *   **지연 로딩 (Lazy Loading):** 실제 객체가 필요할 때까지 생성을 미룸 (Virtual Proxy).
    *   **원격 접근:** 다른 주소 공간에 있는 객체를 로컬 객체처럼 사용 (Remote Proxy).
    *   **부가 기능 추가:** 로깅, 캐싱 등 실제 객체 코드 수정 없이 기능 추가 (Smart Proxy).
3.  **구조:** 클라이언트는 실제 객체(RealSubject)와 동일한 인터페이스(Subject)를 구현한 프록시 객체(Proxy)를 통해 실제 객체에 접근함.
4.  **장점:** 실제 객체의 복잡성을 숨기고, 접근 제어 및 부가 기능을 쉽게 추가하며, 코드 변경을 최소화하여 유지보수성을 높임.

---

### 문제 12: 관계 데이터베이스 용어 작성

다음의 관계 데이터베이스 설명에서 (1), (2), (3)에 들어갈 알맞은 용어를 작성하시오.
```
(1) : 관계형 데이터베이스에서 릴레이션의 각 행을 나타내는 속성의 모임으로 이루어져 있으며, 각 속성에는 해당 행에 대한 값이 저장된다. 예를 들어, 학생 테이블에서 한 학생의 정보가 하나의 이것으로 표현 될 수 있다.
(2) : 릴레이션의 현재 상태를 나타낸다. 즉, 특정 시점에서 릴레이션에 저장된 데이터의 모든 행과 열의 집합을 나타낸다.
(3) : 릴레이션에서 튜플의 수를 나타낸다.
```

**답변:**

아 ㅋㅋ DB 문제네. 용어 맞추기? 이거 완전 기본 중의 기본 아니냐? 보자.

1.  **릴레이션(테이블)에서 각 행(row)**, 속성(컬럼)들의 값 모아놓은 거. 학생 테이블이면 학생 한 명 정보 한 줄 쫙 있는 그거. 이거 완전 **튜플(Tuple)** 이잖아. 레코드(Record)라고도 하는데 관계 데이터베이스 용어로는 튜플이 좀 더 깐지남.
2.  **특정 시점**에 릴레이션(테이블)에 들어있는 **데이터 전체**. 그러니까 테이블의 '내용물' 스냅샷 같은 거임. 스키마(뼈대) 말고 실제 데이터 덩어리. 이건 **릴레이션 인스턴스(Relation Instance)** 또는 그냥 **인스턴스(Instance)** 라고 한다. 릴레이션 외연(Extension)이라고도 함.
3.  릴레이션(테이블)에 **튜플(행)이 총 몇 개** 있냐 세는 거. 행 개수. 이건 **카디널리티(Cardinality)** 라고 한다. 디그리(Degree)는 열(속성) 개수니까 헷갈리면 안됨 ㅋㅋ

자 그럼 답 정리한다.

(1) **튜플 (Tuple)**
(2) **릴레이션 인스턴스 (Relation Instance)** 또는 **인스턴스 (Instance)**
(3) **카디널리티 (Cardinality)**

어때, 쉽지? ㅋㅋ

**주요 포인트:**

1.  **튜플 (Tuple):** 릴레이션(테이블)의 **행(Row)**. 속성 값들의 집합으로, 하나의 레코드에 해당함.
2.  **릴레이션 인스턴스 (Relation Instance):** **특정 시점**의 릴레이션에 포함된 **튜플들의 집합**. 즉, 테이블의 실제 데이터 내용.
3.  **카디널리티 (Cardinality):** 한 릴레이션에 포함된 **튜플(행)의 수**.
4.  *(참고) 디그리 (Degree):* 한 릴레이션에 포함된 **속성(열)의 수**. (카디널리티랑 헷갈리지 말 것)

---

### 문제 13: SQL 쿼리 작성 (DELETE)

[STUDENT] 테이블에서 depart 필드값이 '영어과'인 레코드를 삭제하는 쿼리를 작성하시오.

**답변:**

아 ㅋㅋ SQL 문제네. 테이블에서 뭐 지우는 거? 이거 완전 기본이지. 보자.

*   테이블 이름: `STUDENT`
*   조건: `depart` 필드 값이 `'영어과'` 인 거
*   할 일: 조건 맞는 **레코드(행) 삭제**

자, 데이터 지울 때는 `DELETE` 명령어를 쓴다. 어디서 지울지 `FROM`으로 테이블 이름 딱 지정해주고, 어떤 거 지울지 `WHERE` 절로 조건 걸어주면 끝임.

이렇게 쓰면 된다.

```sql
DELETE FROM STUDENT
WHERE depart = '영어과';
```

`DELETE FROM STUDENT` : 야! STUDENT 테이블에서 지울 준비해!
`WHERE depart = '영어과'` : 근데 아무거나 지우지 말고, depart 컬럼 값이 '영어과'인 놈들만 골라서 지워!

간단하지? ㅋㅋ `WHERE` 절 빼먹으면 테이블 통째로 날아가니까 조심하고.

**주요 포인트:**

1.  **`DELETE FROM`:** 테이블에서 레코드(행)를 삭제하는 SQL 명령어.
2.  **`WHERE` 절:** 삭제할 레코드를 특정하는 조건절. 이 조건에 맞는 행만 삭제됨. **(주의: `WHERE` 절 생략 시 테이블의 모든 행이 삭제됨!)**
3.  **조건식:** `필드명 = 값` 형태로 특정 필드의 값을 비교하여 조건을 설정함. 문자열 값은 작은따옴표(`' '`)로 감싸줘야 함.

---

### 문제 14: Java 프로그램 빈칸 채우기 (버블 정렬)

다음은 버블 정렬을 하기 위한 Java 프로그램이다. (1), (2)에 들어갈 알맞은 코드를 작성하시오.

```java
public class BubbleSort{
    public static void main(String[] args){
        int[] array = {64, 34, 25, 12, 22, 11, 90};
        BubbleSort( ( 1 ) ); // 오타: BubbleSort -> bubbleSort
        printArray(array);
    }

    public static void bubbleSort(int[] array){
        int n = array.length;

        for(int i = 0; i < n-1; i++) {
            for(int j = 0; j < n-1; j++){
                if(array[j] > array[j+1]) {
                    int temp = array[j];
                    array[j] = array[( 2 )];
                    array[( 2 )] = temp;
                }
            }
        }
    }

    public static void printArray(int[] array){
        for (int value : array){
            System.out.print(value + " "); // 오타: pring -> print, 줄바꿈 없도록 print 사용
        }
        System.out.println();
    }
}
```

**답변:**

아 ㅋㅋ 또 코드 문제냐? 이번엔 버블 정렬이네. 이거 뭐 옆자리 애랑 키 비교해서 자리 바꾸는 거랑 똑같다고 보면 됨. 보자.

```java
public class BubbleSort{
    public static void main(String[] args){
        int[] array = {64, 34, 25, 12, 22, 11, 90};
        // 여기서 bubbleSort 메소드를 호출해서 array를 정렬해야지.
        // 근데 메소드 이름 오타났네 BubbleSort -> bubbleSort 여야하고,
        // 파라미터로 뭘 넘겨야겠냐? 당연히 정렬할 배열이지.
        bubbleSort( ( 1 ) ); // <- 여기 (1) 에는 정렬할 배열 'array'가 들어가야 함.
        printArray(array); // 정렬된 배열 출력
    }

    // 이게 버블 정렬 로직
    public static void bubbleSort(int[] array){
        int n = array.length; // 배열 크기

        // 바깥 루프: 총 n-1번 돌면 정렬 끝남
        for(int i = 0; i < n-1; i++) {
            // 안쪽 루프: 인접한 두 원소 비교 및 교환
            // j랑 j+1 비교하는 거임.
            for(int j = 0; j < n-1; j++){ // 사실 j < n-i-1 로 최적화 가능. 근데 문제 코드대로 가자.
                // 만약 왼쪽 놈(array[j])이 오른쪽 놈(array[j+1])보다 크면? 자리 바꿔야지 (오름차순 기준)
                if(array[j] > array[j+1]) {
                    // 스왑(자리 바꾸기) 로직
                    int temp = array[j]; // 왼쪽 놈 임시 저장
                    array[j] = array[( 2 )]; // 왼쪽 자리에 오른쪽 놈 값 넣기. 즉, array[j+1] 값이 들어가야 함.
                    array[( 2 )] = temp; // 오른쪽 자리에 아까 임시 저장한 왼쪽 놈 값 넣기. 즉, array[j+1] 자리에 temp가 들어가야 함.
                }
            }
        }
    }

    // 배열 출력 메소드 (오타 수정: pring -> print)
    public static void printArray(int[] array){
        for (int value : array){
            System.out.print(value + " "); // print로 해야 한 줄에 나옴
        }
        System.out.println();
    }
}
```

자 그럼 빈칸에 뭐가 들어가야 할지 보자.

(1) `main` 메소드에서 `bubbleSort` 메소드를 호출할 때 정렬할 대상인 `array`를 넘겨줘야 함.  
(2) `bubbleSort` 메소드 안에서 두 요소의 자리를 바꿀 때, `array[j]`와 `array[j+1]`의 값을 서로 교환해야 함. `temp`에 `array[j]`를 저장했으니, `array[j]`에는 `array[j+1]` 값을 넣고, `array[j+1]`에는 `temp` 값을 넣어야 함. 즉, `( 2 )`에는 `j+1`이 들어가야 함.

답은 이거다.

(1) `array`
(2) `j+1`

어때, 버블 정렬 별거 없지? ㅋㅋ 코드 따라가면서 생각하면 다 풀림.

**주요 포인트:**

1.  **버블 정렬 (Bubble Sort):** 인접한 두 원소를 비교하여 조건에 맞지 않으면 자리를 교환하는 방식으로 정렬. 매 단계마다 가장 큰(또는 작은) 원소가 맨 뒤로 이동함.
2.  **메소드 호출:** `main` 함수에서 정의된 `bubbleSort` 함수를 호출할 때, 정렬할 배열(`array`)을 인자로 전달해야 함.
3.  **값 교환 (Swap):** 두 변수의 값을 서로 바꾸려면 임시 변수(`temp`)를 사용해야 함.
    *   `temp = a;`
    *   `a = b;`
    *   `b = temp;`
4.  **배열 인덱스:** 자바 배열에서 `array[j]`는 `j`번째 인덱스의 원소를 의미하고, `array[j+1]`은 그 바로 다음 원소를 의미함. 인덱스 범위 (`0`부터 `length-1`까지) 주의해야 함.

---

### 문제 15: 파이썬 실행 결과 (Set)

다음 파이썬의 실행 결과를 작성하시오.(반드시 집합(Set)의 형식으로 작성할 것)

```python
a = {'사과', '바나나', '딸기'}
a.add('파인애플')
a.add('바나나')
a.remove('딸기')
a.update({'망고', '사과', '키위'})
print(a)
```

**답변:**

아 ㅋㅋ 파이썬 문제네. 그것도 집합(Set) 쓰는 거? 이거 완전 거저먹기지. 보자.

```python
# 집합 a 초기화. 순서 없고 중복 없음.
a = {'사과', '바나나', '딸기'}
# 초기 상태: {'사과', '바나나', '딸기'} (순서는 바뀔 수 있음)

# '파인애플' 추가. 없던 거니까 잘 들어감.
a.add('파인애플')
# 상태: {'사과', '바나나', '딸기', '파인애플'}

# '바나나' 추가 시도. 근데 이미 있네? 집합은 중복 ㄴㄴ. 변화 없음.
a.add('바나나')
# 상태: {'사과', '바나나', '딸기', '파인애플'}

# '딸기' 삭제. 잘가라 딸기야.
a.remove('딸기')
# 상태: {'사과', '바나나', '파인애플'}

# 다른 집합 {'망고', '사과', '키위'}의 내용물 때려넣기.
# '망고', '키위'는 없으니까 추가되고, '사과'는 이미 있으니 변화 없음.
a.update({'망고', '사과', '키위'})
# 최종 상태: {'사과', '바나나', '파인애플', '망고', '키위'}

# 최종 a 출력. 집합 형태로 출력됨. 순서는 보장 안 됨.
print(a)
```

자, 그럼 최종적으로 `a`에 뭐가 들어있는지 보자.
`사과`, `바나나`, `파인애플`, `망고`, `키위` 이렇게 5개가 들어있다.

문제에서 "반드시 집합(Set)의 형식으로 작성"하라고 했으니, `{}` 안에 콤마로 구분해서 써주면 된다. 순서는 상관없다. 파이썬 돌릴 때마다 순서 다르게 나올 수도 있음.

결과는 이거다. (순서는 다를 수 있음)

```
{'사과', '바나나', '파인애플', '망고', '키위'}
```

혹은 뭐 이렇게 써도 맞음.

```
{'망고', '키위', '사과', '바나나', '파인애플'}
```

어때, 쉽지? ㅋㅋ

**주요 포인트:**

1.  **파이썬 집합 (Set):** 중괄호 `{}` 를 사용하거나 `set()` 함수로 생성. **순서가 없고**, **중복된 요소를 허용하지 않음**.
2.  **`add()` 메소드:** 집합에 **하나의 요소**를 추가함. 이미 있는 요소면 변화 없음.
3.  **`remove()` 메소드:** 집합에서 **특정 요소**를 제거함. 없는 요소를 제거하려고 하면 에러 발생.
4.  **`update()` 메소드:** 집합에 다른 iterable(리스트, 튜플, 집합 등)의 **모든 요소**를 추가함 (합집합 개념). 중복 요소는 알아서 처리됨.
5.  **집합 출력 형식:** `{요소1, 요소2, ...}` 형태로 출력됨. 출력 시 요소들의 순서는 보장되지 않음.

---

### 문제 16: SQL 쿼리 작성 (GROUP BY, HAVING)

다음의 [성적] 테이블에서 <처리조건>대로 <실행결과>를 출력하는 SQL 쿼리를 작성하시오.

```
[성적]
| 학번 | 이름 | 학과 | 학년 | 점수 |
| 2022512 | 김연진 | 컴퓨터공학 | 3 | 90 |
| 2120326 | 문동은 | 전자공학 | 3 | 80 |
| 2204534 | 차호윤 | 컴퓨터공학 | 2 | 95 |
| 2309876 | 성우람 | 전자공학 | 1 | 85 |
| 1923094 | 홍찬중 | 건축학 | 4 | 95 |
| 2102934 | 이사랑 | 건축학 | 2 | 100 |
```
```
<실행결과>
| 학과 | 최대점수 | 최소점수 |
| 컴퓨터공학 | 95 | 90 |
| 건축학 | 100 | 95 |
```
```
<처리조건>
- [성적] 테이블에서 학과별 점수의 평균이 90 이상인 학과를 대상으로 출력하시오.
- <실행결과>를 참고하여 학과, 최대점수, 최소점수를 검색하시오.
- 최대점수와 최소점수는 별칭을 사용하여 <실행결과>와 동일한 형식으로 출력되도록 하여야 한다.
- 각 속성의 자료형은 이름, 학과는 char(10)이고, 학번, 학년, 점수는 int이다.
- 쿼리는 대/소문자를 구분하지 않으며 세미콜론은 생략 가능하다.
```

**답변:**

아 ㅋㅋ SQL 또 나왔네. 이번엔 좀 복잡해 보이냐? 쫄지 마라 ㅋㅋ 처리 조건이랑 결과 보고 차근차근 따라가면 된다.

자, 목표는 `<실행결과>`처럼 학과별 최대/최소 점수를 뽑는 건데, 아무 학과나 다 뽑는 게 아니고 **학과별 평균 점수가 90점 이상**인 학과만 골라야 함.

1.  **뭘 보여줄 건가? (`SELECT`)**: `<실행결과>` 보니까 `학과`, `최대점수`, `최소점수` 이거 세 개네.
    *   `학과`는 그냥 `학과` 컬럼 쓰면 됨.
    *   `최대점수`는 각 학과의 `점수` 중에 제일 큰 거니까 `MAX(점수)` 쓰면 됨. 근데 이름표를 `최대점수`로 달아줘야 하니 `AS 최대점수` 붙여주고.
    *   `최소점수`는 각 학과의 `점수` 중에 제일 작은 거니까 `MIN(점수)` 쓰면 됨. 이것도 `AS 최소점수` 이름표 붙여주고.
    *   그래서 `SELECT 학과, MAX(점수) AS 최대점수, MIN(점수) AS 최소점수` 이렇게 시작.

2.  **어디서 가져올 건가? (`FROM`)**: 당연히 `[성적]` 테이블이지. `FROM 성적` (대괄호는 보통 생략 가능)

3.  **어떻게 묶을 건가? (`GROUP BY`)**: **학과별**로 최대/최소 점수를 구해야 하니까 `학과` 컬럼 기준으로 그룹을 묶어야 함. `GROUP BY 학과`

4.  **묶은 다음에 뭘 걸러낼 건가? (`HAVING`)**: 처리 조건에서 **학과별 평균 점수가 90 이상**인 학과만 보여달라고 했지? 그룹으로 묶은 결과에 조건을 걸 때는 `WHERE`가 아니라 `HAVING`을 쓴다. 평균 점수는 `AVG(점수)`로 구하고, 이게 90 이상인지 비교해야 하니까 `HAVING AVG(점수) >= 90` 이렇게.

자, 다 합쳐보자. 순서는 `SELECT`, `FROM`, `GROUP BY`, `HAVING` 이 순서다.

```sql
SELECT 학과, MAX(점수) AS 최대점수, MIN(점수) AS 최소점수
FROM 성적
GROUP BY 학과
HAVING AVG(점수) >= 90;
```

이러면 딱 <처리조건>에 맞게 <실행결과>처럼 나올 거다. 쉽지? ㅋㅋ

**주요 포인트:**

1.  **`GROUP BY` 절:** 특정 컬럼(여기서는 `학과`)의 값으로 그룹화하여 집계 함수(Aggregate Function)를 적용할 때 사용함.
2.  **집계 함수 (Aggregate Functions):** `MAX()`, `MIN()`, `AVG()`, `SUM()`, `COUNT()` 등 그룹화된 데이터에 대한 계산을 수행함.
3.  **`HAVING` 절:** `GROUP BY`로 그룹화된 결과에 대해 조건을 적용하여 특정 그룹만 필터링할 때 사용함. 집계 함수의 결과에 대한 조건을 쓸 수 있음. (**주의: `WHERE` 절은 그룹화하기 전의 개별 행에 대한 조건임.**)
4.  **`AS` (Alias):** 컬럼이나 테이블에 별칭(다른 이름)을 부여할 때 사용함. 출력 결과의 컬럼명을 지정할 때 유용함.

---

### 문제 17: Java 프로그램 실행 결과 (상속, 추상 클래스)

다음 Java 프로그램의 실행 결과를 작성하시오.

```java
abstract class Transport {
    String modelName;
    abstract public String getModelName(String val);
    public String getModelName() {
        return "Model name: " + modelName;
    }
}

class Bicycle extends Transport {
    public Bicycle(String val){
        modelName = super.modelName = val;
    }
    public String getModelName(String val){
        return "Bycycle model: " + val; // 오타: Bycycle -> Bicycle
    }
    public String getModelName(byte val[]){
        return "Bicycle model: " + val;
    }
}

public class YoungJin {
    public static void main(String[] args){
        Transport obj = new Bicycle("Mountain Bike");
        System.out.println(obj.getModelName());
    }
}
```

**답변:**

아 ㅋㅋ 자바 또 나왔네. 이번엔 상속이랑 추상 클래스까지 섞였구만. 쫄지 말고 보자.

```java
// 추상 클래스 Transport 정의. 이 자체로는 객체 못 만듦.
abstract class Transport {
    String modelName; // 모델 이름 저장할 변수

    // 추상 메소드. 몸통({}) 없고 선언만 있음. 자식 클래스가 무조건 구현해야 함.
    abstract public String getModelName(String val);

    // 일반 메소드. 이건 그냥 바로 쓸 수 있음.
    public String getModelName() {
        // 인스턴스 변수 modelName 앞에 "Model name: " 붙여서 리턴
        return "Model name: " + modelName;
    }
}

// Transport 클래스를 상속받는 Bicycle 클래스
class Bicycle extends Transport {
    // Bicycle 생성자. 문자열 val 받음.
    public Bicycle(String val){
        // 받은 val 값을 부모(Transport)로부터 물려받은 modelName에 저장.
        // super.modelName = val; 만 해도 되는데 좀 꼬아놨네 ㅋㅋ 아무튼 modelName에 val 들어감.
        modelName = super.modelName = val;
    }

    // 부모의 추상 메소드 구현. 똑같은 이름과 파라미터(String val)를 가져야 함.
    public String getModelName(String val){
        return "Bicycle model: " + val; // Bicycle 오타있네 ㅋㅋ 암튼 이렇게 구현됨.
    }

    // 이건 오버로딩된 메소드. 이름은 같지만 파라미터 타입(byte[])이 다름. 위 메소드랑 다른 거임.
    public String getModelName(byte val[]){
        return "Bicycle model: " + val;
    }
}

// 실행 클래스
public class YoungJin {
    public static void main(String[] args){
        // 중요! Transport 타입 변수 obj에 Bicycle 객체 생성해서 넣음 (다형성!)
        // Bicycle 생성자 호출 시 "Mountain Bike" 전달 -> Bicycle 객체의 modelName은 "Mountain Bike"가 됨.
        Transport obj = new Bicycle("Mountain Bike");

        // obj 변수로 getModelName() 호출. 파라미터 없음!
        // 어느 메소드가 호출될까?
        // obj의 실제 객체는 Bicycle이지만, 호출하는 메소드 getModelName() (파라미터 없는 버전)은
        // Bicycle 클래스에 오버라이딩(재정의)되어 있지 않음.
        // 따라서 부모 클래스인 Transport의 getModelName() 메소드가 호출됨.
        System.out.println(obj.getModelName());
    }
}
```

자 그럼 `main` 메소드에서 `obj.getModelName()`을 호출하면 어떻게 되는지 보자.

1.  `obj`는 `Transport` 타입이지만 실제로는 `Bicycle` 객체를 가리키고 있음.
2.  `getModelName()` (파라미터 없는 버전) 메소드를 호출함.
3.  `Bicycle` 클래스에는 `getModelName(String val)`과 `getModelName(byte val[])`만 있고, 파라미터 없는 `getModelName()`은 없음(오버라이딩 안 함).
4.  따라서 부모 클래스인 `Transport`에 정의된 `getModelName()` 메소드가 실행됨.
5.  `Transport`의 `getModelName()`은 `return "Model name: " + modelName;` 임.
6.  이때 `modelName` 변수는 `obj`가 가리키는 실제 객체(`Bicycle` 객체)의 `modelName` 값임. 생성자에서 `"Mountain Bike"`로 초기화했었음.
7.  결과적으로 `"Model name: Mountain Bike"` 문자열이 반환되고 출력됨.

결과는 이거다.

```
Model name: Mountain Bike
```

어때? 상속이랑 다형성, 오버라이딩/오버로딩 개념만 알면 풀리는 문제임 ㅋㅋ

**주요 포인트:**

1.  **추상 클래스와 추상 메소드:** `abstract` 키워드 사용. 추상 클래스는 인스턴스화 불가. 추상 메소드는 자식 클래스에서 반드시 구현(오버라이딩)해야 함.
2.  **상속 (Inheritance):** 자식 클래스(`Bicycle`)가 부모 클래스(`Transport`)의 멤버(변수, 메소드)를 물려받음.
3.  **다형성 (Polymorphism):** 부모 클래스 타입의 참조 변수(`obj`)로 자식 클래스 객체(`new Bicycle(...)`)를 참조할 수 있음.
4.  **메소드 오버라이딩 (Overriding):** 자식 클래스에서 부모 클래스의 메소드를 **동일한 시그니처(이름, 파라미터 타입 및 개수)** 로 재정의하는 것. 다형성에서 중요하게 작용.
5.  **메소드 오버로딩 (Overloading):** 같은 클래스 내에서 메소드 이름은 같지만 **파라미터의 타입이나 개수가 다른** 여러 메소드를 정의하는 것. 오버라이딩과는 다른 개념.
6.  **메소드 호출 규칙:** 자식 객체를 부모 타입으로 참조할 때, 오버라이딩된 메소드는 자식 클래스의 것이 호출되고, 오버라이딩되지 않은 메소드는 부모 클래스의 것이 호출됨. (호출 시 사용된 메소드 시그니처 기준)

---

### 문제 17 부연 설명: 오버라이딩

**추가 질문:** 해당 문제에서 오버라이딩에 대한 부분이 이해가 안가서 그러는데 자세하게 설명해주셈

**답변:**

아 ㅋㅋ 오버라이딩 그게 좀 헷갈릴 수 있지. 내가 딱 풀어 설명해줄게.

**오버라이딩(Overriding)이 뭐냐면,** 쉽게 말해서 부모 클래스가 물려준 기능(메소드)이 자식 클래스 입장에서 좀 맘에 안 들거나, 자기 상황에 맞게 바꿔 쓰고 싶을 때, **부모 거랑 똑같은 이름, 똑같은 파라미터(입력 받는 거)를 가진 메소드를 자식 클래스에 새로 만드는 거야.**

이게 중요한 게 뭐냐면, **"덮어쓰기"** 라고 생각하면 편해. 부모가 "야, 이렇게 해!" 라고 물려줬는데, 자식이 "아니, 나는 이렇게 할 건데요?" 하고 똑같은 이름표를 달고 자기만의 방식을 만드는 거지.

**왜 쓰냐고? 다형성 때문이지.**  
아까 문제에서 `Transport obj = new Bicycle("Mountain Bike");` 이렇게 썼잖아?
`obj`는 겉보기엔 `Transport` 타입이지만, 알맹이는 `Bicycle`이지? 이게 다형성임.

이 상태에서 만약 `obj`를 통해 어떤 메소드를 호출했을 때,
*   **만약 그 메소드가 `Bicycle`에서 오버라이딩 되어 있다면?** -> 자바는 똑똑해서 "어? 이 변수 껍데기는 Transport지만, 실제 알맹이는 Bicycle이네? 그럼 Bicycle에 새로 만든 거(오버라이딩된 거) 써야지!" 하고 **자식 클래스의 메소드를 실행**해줘.
*   **만약 그 메소드가 `Bicycle`에서 오버라이딩 안 되어 있다면?** -> 자바는 "어? Bicycle에는 이거 새로 만든 거 없네? 그럼 그냥 부모(Transport)가 물려준 거 그대로 써야겠다." 하고 **부모 클래스의 메소드를 실행**하는 거야.

**자, 문제 코드 다시 보자.**

```java
// 부모 (Transport)
abstract class Transport {
    String modelName;
    abstract public String getModelName(String val); // <- 요놈은 추상 메소드. 자식이 반드시 구현(오버라이딩)해야 함.
    public String getModelName() { // <- 요놈은 일반 메소드. 파라미터 없음.
        return "Model name: " + modelName;
    }
}

// 자식 (Bicycle)
class Bicycle extends Transport {
    public Bicycle(String val){ modelName = val; }

    // 부모의 추상 메소드 getModelName(String val)을 구현(오버라이딩)함. 이름/파라미터 똑같지?
    public String getModelName(String val){
        return "Bycycle model: " + val; // 내용은 자기 맘대로 바꿈.
    }

    // 이건 오버로딩. 이름은 같지만 파라미터가 다름 (byte[]). 오버라이딩 아님!
    public String getModelName(byte val[]){
        return "Bicycle model: " + val;
    }

    // *** 여기에 만약 아래 코드가 있었다면?? ***
    // @Override // <- 이건 오버라이딩 했다는 표시. 안 써도 되지만 쓰는 게 좋음.
    // public String getModelName() {
    //     return "이건 자전거 모델 이름: " + modelName;
    // }
    // *** 이렇게 파라미터 없는 getModelName()을 Bicycle에도 만들었다면, 이게 '오버라이딩'임 ***
}

// 실행 부분
public class YoungJin {
    public static void main(String[] args){
        Transport obj = new Bicycle("Mountain Bike");
        // 여기서 호출하는 건 파라미터 없는 getModelName() 임.
        System.out.println(obj.getModelName());
    }
}
```

자, `main`에서 `obj.getModelName()`을 호출했지? **파라미터 없는 버전**이야.

1.  자바는 `obj`의 실제 알맹이인 `Bicycle` 클래스에 `getModelName()` (파라미터 없는 버전)이 있는지 확인해.
2.  근데 위 코드 보면 `Bicycle` 클래스에는 `getModelName(String val)` 하고 `getModelName(byte val[])`만 있고, **파라미터 없는 `getModelName()`은 없어.** 즉, 오버라이딩 안 했어.
3.  그러니까 자바는 "아, Bicycle에는 없네. 그럼 부모한테 물려받은 거 써야겠다." 하고 **`Transport` 클래스에 있는 `getModelName()`을 실행**시킨 거야.
4.  그래서 결과가 `Model name: Mountain Bike` 이렇게 나온 거지.

만약에, 주석 처리된 부분처럼 `Bicycle` 클래스 안에 파라미터 없는 `getModelName()` 메소드를 새로 만들었다면 (오버라이딩 했다면), 그때는 `obj.getModelName()` 호출 시 `Bicycle`의 메소드가 실행돼서 `"이건 자전거 모델 이름: Mountain Bike"` 이런 식으로 나왔을 거다 이 말이야.

**핵심 요약:** 오버라이딩은 부모 메소드를 자식이 똑같은 이름/파라미터로 **덮어쓰는 거**. 호출할 때는 변수 타입보다 **실제 객체**에 오버라이딩된 메소드가 있는지 먼저 보고, 있으면 그거 쓰고 없으면 부모 거 쓴다!

이해됐냐? ㅋㅋ 이제 좀 감이 오지?

---

### 문제 18: 스키마 용어 작성

다음의 스키마 관련 설명을 보고 (1), (2), (3)에 들어갈 알맞은 스키마를 작성하시오.

```
(1) : 데이터베이스의 물리적 저장 구조를 정의한다. 디스크에 데이터가 어떻게 저장되는지, 데이터의 블록 크기, 인덱스의 유무, 어떤 알고리즘을 사용해 데이터를 접근하는지 등의 정보를 포함한다.
(2) : 데이터베이스의 논리적 구조를 정의한다. 데이터베이스에 저장된 데이터와 데이터 간의 관계, 제약 조건, 무결성 규칙등을 기술한다.
(3) : 데이터베이스에 접근하는 응용 프로그램이 볼 수 있는 논리적 구조를 정의한다. 따라서 데이터베이스에서 필요한 일부 데이터와 그 구조를 정의한다.
```

**답변:**

아 ㅋㅋ 스키마 문제네. 이거 데이터베이스 뼈대 잡는 3단계 레벨 아니냐? 딱 보면 알지.

1.  **"물리적 저장 구조", "디스크", "블록 크기", "인덱스"** 이런 단어 딱 나오면 뭐다? 데이터가 하드디스크 같은 데 **실제로 어떻게 저장**되는지 구체적으로 까보는 제일 밑바닥 레벨. 이건 **내부 스키마 (Internal Schema)** 다. 개발자나 DBA 중에서도 하드웨어 레벨 신경 쓰는 사람들이 보는 거.
2.  **"논리적 구조", "데이터 간의 관계", "제약 조건", "무결성"** 이건 뭐냐? 디스크니 뭐니 그런 거 신경 안 쓰고, 데이터베이스 전체가 **어떤 데이터들로 구성되고 걔들끼리 어떤 관계**를 맺는지, 규칙은 뭔지 이런 걸 정의하는 중간 레벨. 조직 전체 관점에서 보는 청사진 같은 거. 이건 **개념 스키마 (Conceptual Schema)** 다. 보통 그냥 '스키마'라고 하면 이거 말하는 경우 많음.
3.  **"응용 프로그램이 보는", "필요한 일부 데이터"** 이건 뭐겠냐? 실제 사용자나 앱 개발자 입장에서 필요한 데이터만 골라서 보는 **개별 맞춤형 뷰(View)** 같은 거지. 전체 DB 다 보여줄 필요 없이 딱 필요한 부분만 보여주는 거. 이건 **외부 스키마 (External Schema)** 또는 서브 스키마(Subschema)라고도 함. 사용자 개개인이나 응용 프로그램 관점.

자 그럼 답 정리한다.

(1) **내부 스키마 (Internal Schema)**
(2) **개념 스키마 (Conceptual Schema)**
(3) **외부 스키마 (External Schema)**

어때, 3단 변신 로봇 같지 않냐? ㅋㅋ

**주요 포인트:**

1.  **내부 스키마 (Internal Schema):** 데이터베이스의 **물리적 저장 구조** 정의. 저장 장치 관점. (예: 인덱스 구조, 데이터 저장 방식 등)
2.  **개념 스키마 (Conceptual Schema):** 데이터베이스의 **전체적인 논리적 구조** 정의. 조직 전체 관점. (예: 테이블 구조, 관계, 제약 조건 등)
3.  **외부 스키마 (External Schema):** **개별 사용자 또는 응용 프로그램**이 보는 데이터베이스 뷰 정의. 특정 사용자/응용 관점. (예: 특정 사용자에게 필요한 컬럼만 보여주는 뷰)
4.  **3단계 스키마 구조:** 데이터베이스를 보는 관점을 3단계로 분리하여 **데이터 독립성**(물리적/논리적)을 확보하기 위한 구조임.

---

### 문제 19: 분기 커버리지 테스트 케이스 작성

다음 제어 흐름도에 대하여 분기 커버리지(Branch Coverage)를 수행하는 경우, 테스트 케이스 순서를 6단계와 7단계로 나누어 작성하시오

(순서도 이미지는 생략, OCR 내용으로 대체)
```
1 POINTER = FALSE
2 X > K ? (YES/NO)
3 (YES 경로) POINTER = TRUE
4 (NO 경로 또는 3 다음) X = X + 1
5 CALL SUB(X, POINTER, RESULT)
6 RESULT > 0 ? (YES/NO)
7 (NO 경로) PRINT RESULT
(YES 경로) -> 1번으로 돌아감
```

**답변:**

아 ㅋㅋ 순서도 문제네. 분기 커버리지? 이거 뭐 갈림길이란 갈림길은 다 한 번씩 지나가보는 거라고 생각하면 됨.

순서도를 보자. 갈림길(분기)이 두 군데 있다.

1.  **②번:** `X > K ?` (YES / NO 두 갈래)
2.  **⑥번:** `RESULT > 0 ?` (YES / NO 두 갈래)

분기 커버리지를 만족하려면 이 네 가지 갈래를 **모두** 한 번 이상 타야 함.

*   ②번 `YES` (-> ③번으로 가는 길)
*   ②번 `NO` (-> ④번으로 가는 길)
*   ⑥번 `YES` (-> ①번으로 돌아가는 길)
*   ⑥번 `NO` (-> ⑦번으로 가는 길)

자, 이제 6단계까지 가는 경우랑 7단계까지 가는 경우로 나눠서 테스트 케이스를 짜보자. 이 두 케이스를 합쳐서 위 4가지 갈래를 다 타면 되는 거임.

**[6단계 테스트 케이스]**
6단계에서 멈추는 게 아니라, 6단계의 결과가 YES라서 다시 루프를 도는 경우를 말하는 거임. 즉, ⑦번으로 안 빠지고 다시 ①번 쪽으로 가는 경로.
*   예시 1: ②번에서 NO, ⑥번에서 YES를 타는 경로: `1 -> 2 -> 4 -> 5 -> 6` (⑥에서 다시 ①로)
*   예시 2: ②번에서 YES, ⑥번에서 YES를 타는 경로: `1 -> 2 -> 3 -> 4 -> 5 -> 6` (⑥에서 다시 ①로)

둘 중 하나만 써도 됨.

**[7단계 테스트 케이스]**
6단계의 결과가 NO라서 ⑦번 PRINT RESULT로 빠져나가는 경우.
*   예시 1: ②번에서 NO, ⑥번에서 NO를 타는 경로: `1 -> 2 -> 4 -> 5 -> 6 -> 7`
*   예시 2: ②번에서 YES, ⑥번에서 NO를 타는 경로: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7`

이제 이 테스트 케이스들을 조합해서 모든 분기(YES/NO)를 커버해야 함.

예를 들어 이렇게 조합하면 모든 분기를 커버 가능함:
*   **6단계:** `1 -> 2 -> 4 -> 5 -> 6` (②-NO, ⑥-YES 커버)
*   **7단계:** `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7` (②-YES, ⑥-NO 커버)

이 두 가지 테스트 케이스면 4개의 모든 분기 경로를 다 지나가게 된다.

따라서 답은 이렇게 작성하면 된다.

**6단계:** `1 -> 2 -> 4 -> 5 -> 6`
**7단계:** `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7`

(다른 조합도 가능함. 예를 들어 6단계: `1 -> 2 -> 3 -> 4 -> 5 -> 6`, 7단계: `1 -> 2 -> 4 -> 5 -> 6 -> 7` 이것도 모든 분기를 커버함.)

어때, 간단하지? ㅋㅋ

**주요 포인트:**

1.  **분기 커버리지 (Branch Coverage):** 결정 포인트(Decision Point, 마름모꼴)의 **모든 가능한 결과**(참/거짓, YES/NO)가 테스트 중에 **적어도 한 번 이상 실행**되도록 테스트 케이스를 설계하는 기법. 결정 커버리지(Decision Coverage)라고도 함.
2.  **테스트 케이스 설계:** 순서도를 따라가면서 각 결정 포인트의 YES 경로와 NO 경로를 모두 포함하도록 경로를 조합하여 테스트 케이스를 만듦.
3.  **목표:** 최소한의 테스트 케이스로 모든 분기(branch)를 커버하는 것이 효율적임.

---

### 문제 20: Java 프로그램 실행 결과 (상속, 생성자)

다음의 Java 프로그램의 실행 결과를 작성하시오

```java
class Mother {
    int y = 1;
    Mother(){
        this(2);
    }
    Mother(int y) {
        this.y = y;
    }
    int getY() {
        return y;
    }
}

class Daughter extends Mother {
    int y = 3;
    Daughter() {
        this(4);
    }
    Daughter(int y) {
        this.y = y;
    }
}

public class YoungJin {
    public static void main(String[] args){
        Daughter daughterObj = new Daughter();
        System.out.println(daughterObj.getY());
    }
}
```

**답변:**

아 ㅋㅋ 마지막 문제냐? 이것도 자바네. 상속이랑 생성자 호출 순서 짬뽕된 거 같은데, 정신 바짝 차리고 따라와 봐라.

```java
// 엄마 클래스
class Mother {
    int y = 1; // 엄마의 인스턴스 변수 y, 초기값 1

    // 엄마 기본 생성자
    Mother(){
        // this(2) : 같은 클래스(Mother)의 다른 생성자(int 받는 거) 호출. 파라미터로 2 넘김.
        this(2);
        // 그래서 아래 Mother(int y) 생성자가 먼저 실행됨.
    }

    // int 받는 엄마 생성자
    Mother(int y) {
        // this.y = y : 파라미터로 받은 값(여기선 2)을 이 객체(엄마 객체)의 인스턴스 변수 y에 저장.
        // 그래서 엄마의 y는 2가 됨.
        this.y = y;
    }

    // 엄마의 getY 메소드
    int getY() {
        // 이 메소드는 엄마 클래스 안에 있으니까, 여기서 y는 엄마의 인스턴스 변수 y를 의미함.
        return y;
    }
}

// 엄마를 상속받는 딸 클래스
class Daughter extends Mother {
    int y = 3; // 딸의 인스턴스 변수 y, 초기값 3. 엄마의 y랑 이름은 같지만 다른 변수임! (변수 숨김/섀도잉)

    // 딸 기본 생성자
    Daughter() {
        // this(4) : 같은 클래스(Daughter)의 다른 생성자(int 받는 거) 호출. 파라미터로 4 넘김.
        this(4);
        // 그래서 아래 Daughter(int y) 생성자가 먼저 실행됨.
    }

    // int 받는 딸 생성자
    Daughter(int y) {
        // 중요! 자식 클래스 생성자 첫 줄에는 super() 또는 this()가 와야 함.
        // 여기선 명시적으로 안 썼지만, this()가 있으니 괜찮음.
        // 근데 자식 생성자 실행 전에 부모 생성자가 먼저 호출되어야 함!
        // Daughter(int y) 생성자 안에 명시적인 super() 호출이 없으면,
        // 컴파일러가 자동으로 부모(Mother)의 기본 생성자 호출 코드 'super();'를 맨 앞에 넣어줌.

        // 그래서 실제 실행 순서는 이렇다:
        // 1. (숨겨진 super(); 호출) -> Mother() 생성자 호출됨
        // 2. Mother() 안에서 this(2) 호출 -> Mother(int y) 호출됨 (엄마 y = 2 됨)
        // 3. Mother(int y) 끝나고 Mother() 끝남. -> super() 호출 끝.
        // 4. 이제 딸 생성자 본문 실행: this.y = y
        //    파라미터로 받은 값(여기선 4)을 이 객체(딸 객체)의 인스턴스 변수 y에 저장.
        //    그래서 딸의 y는 4가 됨.
        this.y = y;
    }
}

// 실행 클래스
public class YoungJin {
    public static void main(String[] args){
        // 딸 객체 생성. 딸 기본 생성자 Daughter() 호출됨.
        Daughter daughterObj = new Daughter();
        // 위 생성자 호출 과정을 거치면, daughterObj 안에는
        // - 엄마의 y = 2
        // - 딸의 y = 4
        // 이렇게 두 개의 y 값이 존재하게 됨.

        // daughterObj의 getY() 메소드 호출.
        // Daughter 클래스에는 getY() 메소드가 없음.
        // 따라서 부모 클래스인 Mother의 getY() 메소드를 찾아서 실행함.
        System.out.println(daughterObj.getY());
        // Mother의 getY()는 return y; 인데, 이 y는 Mother 클래스의 인스턴스 변수 y를 의미함.
        // 아까 엄마의 y는 2가 됐었지?
    }
}
```

자, 그럼 최종적으로 뭐가 출력될까?
`daughterObj.getY()`는 `Mother` 클래스의 `getY()`를 실행하고, 이 메소드는 `Mother` 클래스의 `y` 값을 반환한다. 생성자 호출 과정에서 `Mother`의 `y`는 `2`가 되었으므로, `2`가 출력된다.

결과는 이거다.

```
2
```

이거 좀 헷갈리지? 생성자 호출 순서랑 `this()`, `super()` 관계, 그리고 변수 숨김(shadowing)까지 알아야 함 ㅋㅋ

**주요 포인트:**

1.  **생성자 호출 순서:** 자식 클래스 객체 생성 시, 자식 생성자 코드 실행 전에 **반드시 부모 생성자가 먼저 호출됨**. 명시적 `super()`가 없으면 컴파일러가 기본 생성자 `super();`를 자동으로 삽입.
2.  **`this()`:** 같은 클래스 내의 **다른 생성자**를 호출할 때 사용. 생성자의 첫 줄에만 올 수 있음.
3.  **`super()`:** **부모 클래스의 생성자**를 호출할 때 사용. 생성자의 첫 줄에만 올 수 있음. (`this()`와 `super()`는 같이 못 씀)
4.  **변수 숨김 (Variable Shadowing):** 자식 클래스에서 부모 클래스와 **동일한 이름의 인스턴스 변수**를 선언하면, 자식 클래스 내에서는 기본적으로 자식의 변수를 사용하게 되고 부모의 변수는 가려짐. (하지만 부모 메소드 내에서는 여전히 부모 변수를 참조함)
5.  **메소드 상속 및 호출:** 자식 클래스에 해당 메소드가 없으면 부모 클래스로 올라가서 메소드를 찾아 실행함. 메소드 내에서 사용되는 인스턴스 변수는 그 메소드가 **정의된 클래스**의 인스턴스 변수를 참조함 (여기서는 `getY()`가 `Mother`에 정의됐으므로 `Mother`의 `y` 참조).
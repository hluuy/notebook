# 2022 기출 01회 해설


### 1번 문제

**문제:**
1. 여러 개의 하드 디스크를 결합하여 하나의 논리적인 디스크로 사용하는 기술 중 하나로 데이터를 여러 디스크에 분산 저장하여 I/O 작업의 속도를 높여 데이터의 처리 속도가 증가하고 대용량 데이터의 처리를 가능하게 하는 방식의 RAID Level을 작성하시오.

**답변:**
야 ㅋㅋ 문제 봤냐? 여러 하드 묶어서 하나처럼 쓰는데, 데이터를 여러 디스크에 쫙 뿌려서 I/O 속도 높인다잖아. 그럼 당연히 처리 속도 빨라지고 용량 큰 것도 다룰 수 있겠지?

이게 딱 뭐냐면, 데이터를 잘게 쪼개서 여러 디스크에 나눠 저장하는 **스트라이핑(Striping)** 방식 쓰는 거거든. 여러 디스크가 동시에 일하니까 속도가 팍 올라가는 거지.

근데 이 방식은 속도는 존나 빠른 대신에 안정성은 내다 버린 거임 ㅋㅋ 디스크 하나만 삑나도 데이터 다 날아가는 수가 있어. 문제에서는 근데 안정성 얘기는 1도 없고 오로지 속도! 분산 저장! 이것만 강조하니까 딱 **RAID 0**이지. 다른 레벨들은 안정성 챙기느라 뭐 복제(미러링)하거나 패리티 넣거나 하는데, 얘는 그런 거 없고 걍 속도에 올인한 놈임.

그래서 답은 **RAID 0** 이다. 알겠냐?

**주요 포인트**
*   RAID 0 (스트라이핑): 여러 디스크에 데이터를 분산 저장하여 I/O 성능 극대화. 단, 안정성(결함 허용 능력)은 제공하지 않음.

---

### 2번 문제

**문제:**
2. 다음 설명이 의미하는 데이터베이스 용어를 <보기>에서 찾아 작성하시오.

```
(1) : 트랜잭션을 수행하는 동안에 주기억장치 또는 처리 장치 등의 고장 때문에 계속 수행할 수 없을 때, 이 고장을 회복한 다음 로그에 있는 기록을 이용하여 앞서 수행한 연산들을 다시 수행하여 고장나기 직전까지의 상태로 회복시키는 과정
(2) : 데이터베이스 내용 자체에 손상이 되지는 않았지만 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린 경우에 로그를 이용하여 모든 변경을 취소하는 것
```
```
<보기>
Rollback, Recovery, Redo, Commit, Locking, Revoke, Constraint, Undo, Anomaly
```

**답변:**
아 ㅋㅋ 이거 또 데이터베이스 회복 기법 문제네. 잘 봐라.

**(1)** 이거 봐봐. 트랜잭션 하다가 시스템 뻗었을 때, 다시 켜서 로그 보고 **"다시 수행"**해서 복구한다고 하잖아? 이미 했던 거 다시 하는 거, 이게 딱 **Redo**임. 고장 나기 전 상태로 돌리려고 로그에 기록된 완료된 작업들 다시 적용하는 거지.

**(2)** 설명 다시 보니까 "로그를 이용하여 모든 변경을 **취소**하는 것"에 초점이 맞춰져 있네. 트랜잭션 실패했을 때 로그 보고 변경 사항을 되돌리는 거, 이걸 **Undo**라고 한다. Rollback은 이 Undo 작업을 포함하는 좀 더 큰 개념의 명령어 같은 거고, Undo는 로그 보고 실제로 되돌리는 액션 그 자체를 말하는 거지. 문제에서는 '로그 이용해서 변경 취소하는 과정'을 물었으니까 Undo가 더 정확한 표현이 맞다. 쏘리 ㅋㅋ

<보기>에도 Undo가 딱 있네.

그럼 정답은 이거다.
*   **(1) Redo**
*   **(2) Undo**

**주요 포인트**
*   **Redo**: 시스템 장애 후 로그를 이용하여 **완료된** 트랜잭션의 변경 내용을 **재반영**하는 회복 작업.
*   **Undo**: 트랜잭션 실패 또는 Rollback 시 로그를 이용하여 해당 트랜잭션이 **변경한 내용을 취소**하여 원래 상태로 되돌리는 회복 작업.

---

### 3번 문제

**문제:**
3. 다음은 <SQL문>을 수행하여 '점수'의 내림차순으로 정렬되어 출력한 <수행 결과>이다. 빈칸 (1), (2), (3)을 작성하여 완성하시오

```sql
<SQL문>
SELECT 학번, 이름, 점수 FROM 성정 ( 1 ) BY ( 2 ) ( 3 );
```
```
<수행결과>
| 학번 | 이름 | 점수 |
| 1002 | 우진표 | 100 |
| 1001 | 김호식 | 95 |
| 1006 | 이소영 | 85 |
| 1003 | 구민정 | 70 |
```

**답변:**
야 ㅋㅋ SQL 정렬 문제네. <수행 결과> 보니까 '점수' 높은 순서대로 나왔잖아? 100점부터 쭉 내려가지? 이걸 내림차순이라고 한다. SQL에서 정렬할 때 쓰는 건 딱 정해져 있어. `ORDER BY` 이거 쓰면 돼.

그럼 <SQL문> 빈칸 채워보자.

*   `( 1 )` 자리에는 정렬 시작하는 키워드 `ORDER` 들어가야지. `SELECT ... FROM 테이블명` 다음에 정렬하려면 `ORDER BY`가 와야 하니까.
*   `( 2 )` 자리에는 뭘 기준으로 정렬할 건지 컬럼 이름. 여기서는 '점수' 기준으로 했으니까 `점수` 넣고.
*   `( 3 )` 자리에는 오름차순(ASC)인지 내림차순(DESC)인지 써야 하는데, <수행 결과> 보니까 높은 점수가 먼저 왔잖아. 이건 내림차순이니까 `DESC` 써야지. (참고로 오름차순은 ASC인데, 이건 생략해도 기본값이 ASC임)

그래서 답은 이거다.

*   **(1) ORDER**
*   **(2) 점수**
*   **(3) DESC**

알겠냐?

**주요 포인트**
*   SQL에서 결과를 정렬할 때는 `ORDER BY` 절을 사용한다.
*   `ORDER BY` 다음에는 정렬 기준이 될 컬럼명을 명시한다.
*   정렬 방식은 `ASC` (오름차순, 기본값) 또는 `DESC` (내림차순)로 지정한다.

---

### 4번 문제

**문제:**
4. 다음 Java 프로그램의 실행 결과를 작성하시오

```java
class A {
    int a;
    int b;
}
public class Main {
    static void func1(A m){
        m.a *= 10;
    }
    static void func2(A m){
        m.a += m.b;
    }
    public static void main(String[] args) throws Exception {
        A m = new A();
        m.a = 100;
        func1(m);
        m.b = m.a;
        func2(m);
        System.out.printf("%d", m.a);
    }
}
```

**답변:**
야 ㅋㅋ 자바 코드 문제네. 이거 따라가면서 값 어떻게 바뀌는지 보면 된다.

1.  `class A` 보니까 그냥 정수 `a`랑 `b` 두 개 담는 통이네.
2.  `func1`은 `A` 타입 객체 `m`을 받아서 그 객체의 `a` 값에 10을 곱하는 놈임. 자바는 객체 넘길 때 **주소값 복사해서 넘기는 거 알지?** 그래서 `func1` 안에서 `m.a` 바꾸면 `main`에 있는 원본 `m`의 `a` 값이 진짜로 바뀐다.
3.  `func2`도 `A` 타입 객체 `m` 받아서 `m.a`에다가 `m.b` 값을 더해서 다시 `m.a`에 넣는 놈. 얘도 원본 `m` 건드림.
4.  자 이제 `main` 메서드 따라가보자.
    *   `A m = new A();`: `A` 타입 객체 `m` 생성. 이때 `m.a`는 0, `m.b`도 0으로 초기화됨. (Java int 기본값)
    *   `m.a = 100;`: `m` 객체의 `a` 값을 100으로 변경. 현재 `m.a = 100`, `m.b = 0`.
    *   `func1(m);`: `func1` 호출하면서 `m` 객체를 넘김. `func1` 안에서 `m.a *= 10;` 실행. 즉, `m.a = m.a * 10`이니까 `100 * 10 = 1000`. 원본 `m`의 `a` 값이 1000으로 바뀜. 현재 `m.a = 1000`, `m.b = 0`.
    *   `m.b = m.a;`: `m` 객체의 `b` 값에 현재 `m.a` 값(1000)을 넣음. 현재 `m.a = 1000`, `m.b = 1000`.
    *   `func2(m);`: `func2` 호출하면서 `m` 객체를 넘김. `func2` 안에서 `m.a += m.b;` 실행. 즉, `m.a = m.a + m.b`니까 `1000 + 1000 = 2000`. 원본 `m`의 `a` 값이 2000으로 바뀜. 현재 `m.a = 2000`, `m.b = 1000`.
    *   `System.out.printf("%d", m.a);`: 마지막으로 `m.a` 값을 정수형으로 출력하래. 현재 `m.a`는 2000이지?

따라서 실행 결과는 **2000** 이다. 쉽네 ㅋㅋ

**주요 포인트**
*   Java에서 메소드에 객체를 전달할 때는 참조(Reference)에 의한 호출 방식으로 동작하여, 메소드 내에서 객체의 멤버 변수 값을 변경하면 원본 객체의 값도 변경된다.
*   코드 실행 순서에 따라 변수의 값이 어떻게 변화하는지 단계별로 추적하는 것이 중요하다.

---

### 5번 문제

**문제:**
5. 데이터베이스의 이상(Anomaly) 현상 중 삭제 이상에 대하여 간략하게 서술하시오

**답변:**
야 ㅋㅋ 삭제 이상? 그거 뭐냐면, 테이블에서 어떤 행(튜플)을 지웠는데 말이야, 내가 원래 지우려던 데이터 말고 **다른 필요한 정보까지 같이 삭제돼 버리는** 황당한 상황을 말하는 거임.

왜 이딴 일이 생기냐고? 보통 테이블 설계를 잘못해서 그럼. 한 행에 너무 여러 종류의 정보를 때려 박아 놓으면, 그중 일부만 지우고 싶은데 행 단위로만 삭제가 되니까 원치 않는 정보까지 같이 날아가는 거지.

예를 들어서 학생 정보랑 특정 과목 정보를 한 테이블에 욱여넣었다 치자. 근데 어떤 학생이 자퇴해서 그 학생 레코드를 지웠는데, 만약 걔가 특정 과목의 유일한 수강생이었다면? 그 과목 정보까지 데이터베이스에서 증발해버리는 수가 있음 ㅋㅋ 이게 바로 삭제 이상임. 필요 없는 거 지우려다 소중한 데이터까지 날려 먹는 거.

**주요 포인트**
*   **삭제 이상 (Deletion Anomaly)**: 테이블에서 한 튜플(행)을 삭제할 때, 의도하지 않은 다른 값(유지해야 할 정보)들까지 연쇄적으로 함께 삭제되는 현상.
*   주로 정규화가 제대로 이루어지지 않은 테이블에서 발생한다.

---

### 6번 문제

**문제:**
6. 다음 Python 프로그램의 실행 결과를 작성하시오

```python
def exam(num1, num2 = 2):
    print('a = ', num1, 'b = ', num2)
exam(20)
```

**답변:**
야 ㅋㅋ 파이썬 코드네. 이거 함수 정의하고 호출하는 거다.

*   `def exam(num1, num2 = 2):` : `exam`이라는 함수를 만드는데, 파라미터(인자 받는 변수)가 `num1`이랑 `num2` 두 개임. 근데 `num2` 옆에 `= 2` 붙어있는 거 보이지? 이게 뭐냐면 **기본값(Default value)** 설정임. 함수 부를 때 `num2` 값을 안 주면 알아서 2로 쓰겠다는 뜻. `num1`은 기본값 없으니 꼭 값을 줘야 함.
*   `print('a = ', num1, 'b = ', num2)` : 함수 안에서는 받은 `num1`이랑 `num2` 값을 'a = 값 b = 값' 형태로 출력함.
*   `exam(20)` : 여기서 `exam` 함수를 부르는데, 인자를 `20` 하나만 줬다.

자, 그럼 어떻게 되냐? 파이썬은 함수 부를 때 준 인자를 순서대로 파라미터에 넣어줌.

1.  `20`은 첫 번째 파라미터인 `num1`에 들어감. 그래서 `num1`은 `20`이 된다.
2.  두 번째 파라미터인 `num2`는? 인자를 안 줬잖아. 그럼 아까 설정한 기본값 `2`가 자동으로 들어감. 그래서 `num2`는 `2`가 된다.
3.  함수 안에서 `print('a = ', num1, 'b = ', num2)`를 실행하니까, `num1` 자리엔 20, `num2` 자리엔 2가 들어가서 출력되겠지.

따라서 실행 결과는 이거다.

```
a =  20 b =  2
```

**주요 포인트**
*   Python 함수 정의 시 매개변수(파라미터)에 `이름 = 값` 형태로 기본값을 지정할 수 있다.
*   함수 호출 시 해당 매개변수에 대한 인자(argument)가 전달되지 않으면, 지정된 기본값이 사용된다.

---

### 7번 문제

**문제:**
7. Python 언어는 여러 개의 아이템을 담을 수 있는 가변(mutable) 객체인 리스트 타입이 있다. 리스트 타입의 객체에서 제공하는 메소드의 설명을 보고 알맞은 메소드 이름을 <보기>를 보고 작성하시오.

```
(1) : 리스트에 iterable 객체의 모든 항목을 추가하는 메소드이다.
(2) : 리스트의 i 번째 위치에 있는 항목을 제거하고 반환한다. 인덱스가 생략되면 리스트의 마지막 항목을 제거하고 반환한다.
(3) : 리스트의 항목들을 역순으로 뒤집는다.
```
```
<보기>
append(), extend(), insert(), remove(), pop(), clear(), sort(), reverse()
```

**답변:**
야 ㅋㅋ 파이썬 리스트 메서드 문제네. 이거 각 메서드가 뭐 하는 놈인지 알면 껌이지. <보기>랑 설명 매칭시켜보자.

**(1)** : "리스트에 iterable 객체의 모든 항목을 추가하는 메소드이다." -> 리스트나 튜플 같은 거 통째로 받아서 그 안의 요소들을 하나씩 현재 리스트 끝에 다 추가해주는 거. 이건 `extend()`임. `append()`는 그냥 통째로 하나로 넣는 거고, `extend()`는 내용물만 쏙 빼서 넣어줌.
**(2)** : "리스트의 i 번째 위치에 있는 항목을 제거하고 반환한다. 인덱스가 생략되면 리스트의 마지막 항목을 제거하고 반환한다." -> 인덱스 지정해서 그 위치 값 뽑아내고 리스트에선 지우는 거. 인덱스 없으면 맨 뒤에꺼 뽑고 지우는 거. 이거 딱 `pop()`의 설명이다. `remove()`는 값을 찾아서 지우는 거고 반환 안 함.
**(3)** : "리스트의 항목들을 역순으로 뒤집는다." -> 리스트 요소 순서 거꾸로 만드는 거. 이건 뭐 이름부터 `reverse()`라고 써있네 ㅋㅋ. `sort()`는 정렬하는 놈이고.

따라서 답은 이거다.

*   **(1) extend()**
*   **(2) pop()**
*   **(3) reverse()**

**주요 포인트**
*   **extend()**: 리스트 끝에 다른 iterable (리스트, 튜플 등)의 모든 항목을 추가한다.
*   **pop(index)**: 지정된 인덱스(기본값: 마지막)의 항목을 리스트에서 제거하고 그 항목을 반환한다.
*   **reverse()**: 리스트의 요소 순서를 제자리에서(in-place) 역순으로 뒤집는다.

---

### 8번 문제

**문제:**
8. 무선 LAN(WLAN)에서 데이터의 기밀성과 무결성을 보장하기 위한 암호화 및 인증 프로토콜 중 하나인 '임시 키 무결성 프로토콜'을 의미하는 영문 약어를 작성하시오

**답변:**
야 ㅋㅋ 무선랜 보안 문제네. 문제에서 결정적인 힌트를 줬잖아. **'임시 키 무결성 프로토콜'**. 이거 영어로 하면 **Temporal Key Integrity Protocol** 이거든?

이걸 줄여서 앞 글자만 따봐. T, K, I, P. 딱 나오네? ㅋㅋ

이거 WEP 보안 개박살나고 나서 와이파이 보안 좀 강화하려고 WPA 만들 때 쓰던 암호화 방식이잖아. 요즘엔 더 좋은 AES 기반 CCMP 많이 쓰지만, 문제에서 물어본 '임시 키 무결성 프로토콜'은 딱 이거임.

그래서 답은 **TKIP** 다.

**주요 포인트**
*   **TKIP (Temporal Key Integrity Protocol)**: WPA(Wi-Fi Protected Access)에서 사용된 암호화 프로토콜로, WEP의 취약점을 개선하기 위해 도입됨. 패킷마다 동적으로 암호화 키를 변경하고 데이터 무결성 검사를 강화함.

---

### 9번 문제

**문제:**
9. 키보드나 마우스와 같은 장치 없이 말이나 행동 그리고 감정과 같은 인간의 자연스러운 표현으로 컴퓨터나 장치를 제어할 수 있는 환경을 무엇이라 하는지 영문 약어로 작성하시오

**답변:**
야 ㅋㅋ 이거 뭔지 알겠냐? 키보드 마우스 집어치우고 말이나 손짓, 표정 같은 걸로 컴터나 기계 다루는 거잖아. 딱 사람 하는 **자연스러운** 방식으로. 이런 걸 **자연스러운 사용자 인터페이스**라고 부르거든?

영어로 하면 **Natural User Interface**니까 이걸 줄여서 **NUI**라고 한다. 쉽지? ㅋㅋ 영화 마이너리티 리포트 같은 거 생각하면 딱임.

그래서 답은 **NUI**다.

**주요 포인트**
*   **NUI (Natural User Interface)**: 사용자가 키보드, 마우스 등 별도의 도구 없이 말, 제스처, 표정 등 자연스러운 방식으로 컴퓨터나 기기와 상호작용하는 환경.
*   직관적이고 배우기 쉬운 인터페이스를 목표로 함.

---

### 10번 문제

**문제:**
10. 다음은 소스코드 품질 분석 도구에 대한 설명이다. (1), (2)에 들어갈 알맞은 말을 <보기>를 보고 작성하시오

```
(1) Analysis : 소스코드나 바이너리 코드를 실행하지 않고, 코드를 분석하여 잠재적인 오류나 취약점을 탐지하는 방법이다. 보통 컴파일러나 분석 도구를 사용하여 코드의 구조, 문법, 변수 사용 등을 분석하고, 코드 경로를 추적하여 잠재적인 오류나 취약점을 식별한다.
(2) Analysis : 실행 시간에 소프트웨어를 분석하여 오류나 취약점을 탐지하는 방법이다. 소프트웨어를 실행하고, 실행 도중에 발생하는 동작, 상태 등을 분석하여 잠재적인 오류나 취약점을 식별한다.
```
```
<보기>
Information, Conceptual, Dynamic, Requirements, Formal, Static
```

**답변:**
야 ㅋㅋ 소스코드 분석 도구 물어보는 거네. 코드 까보면서 문제 찾는 방법 두 가지 설명인데, <보기>에서 골라보자.

**(1)** 이거 봐라. "소스코드나 바이너리 코드를 **실행하지 않고** 분석"한다잖아. 걍 코드 자체를 뜯어보는 거임. 컴파일러 돌리거나 분석 툴 써서 문법 맞는지, 변수 이상하게 쓰진 않았는지, 코드 구조가 어떤지 이런 걸 보는 거지. 실제로 돌려보는 게 아니라 가만히 있는 상태(Static)에서 분석하는 거. 딱 <보기>에 **Static** 있네. 이게 답임.

**(2)** 이건 반대네. "**실행 시간에** 소프트웨어를 분석"한다고 하잖아. 실제로 프로그램을 돌려보면서 메모리 어떻게 쓰는지, 실행 중에 에러 뱉는지, 보안 구멍은 없는지 이런 걸 확인하는 방식임. 막 움직이는 상태(Dynamic)에서 분석하는 거지. <보기>에 **Dynamic** 있네. 이거네.

그래서 답은 이거다.

*   **(1) Static**
*   **(2) Dynamic**

**주요 포인트**
*   **Static Analysis (정적 분석)**: 소프트웨어를 실행하지 않고 소스 코드나 바이너리 코드 자체를 분석하여 결함을 찾는 방법.
*   **Dynamic Analysis (동적 분석)**: 소프트웨어를 실행하면서 동작을 분석하여 결함이나 취약점을 찾는 방법.

---

### 11번 문제

**문제:**
11. 다음 Java 프로그램의 실행 결과를 보고 빈칸에 들어갈 알맞은 코드를 작성하시오

```java
class Car implements Runnable {
    int a;
    public void run(){
        System.out.println("lamborghini");
    }
}
public class Main(){ // 원문 오류 수정: 클래스 선언부 () 제거
    public static void main(String[] args) throws Exception {
        Thread car1 = new Thread(new ( 빈칸 ) ());
        car1.start();
    }
}
```
```
<출력>
lamborghini
```

**답변:**
야 ㅋㅋ 자바 스레드 문제네. 이거 <출력> 보니까 "lamborghini" 찍혔잖아. 이 문자열 어디서 찍는지 코드 봐봐. `Car` 클래스 안에 `run()` 메소드에서 `System.out.println("lamborghini");` 이거 딱 보이네.

그럼 `main` 메소드에서 뭘 해야 저 `Car` 클래스의 `run()` 메소드가 실행될까?

`Car` 클래스가 `Runnable` 인터페이스를 구현(`implements Runnable`)하고 있잖아. 이게 중요함. `Runnable`을 구현한 클래스는 스레드(Thread)가 실행할 작업 내용(`run()` 메소드)을 가지고 있다는 뜻임.

`main` 메소드 보니까 `Thread car1 = new Thread(new ( 빈칸 ) ());` 이렇게 새 스레드를 만드는데, `Thread` 생성자 안에 `new ( 빈칸 ) ()` 이게 들어갔네? `Thread` 생성자는 실행할 `Runnable` 객체를 인자로 받거든.

결국 저 빈칸에는 "lamborghini"를 출력하는 `run()` 메소드를 가진 `Runnable` 객체를 넣어줘야 한다는 소리임. 그게 바로 `Car` 클래스잖아? 그래서 `Car` 클래스의 인스턴스(객체)를 생성해서 넣어주면 되는 거임.

`Car` 클래스의 객체는 어떻게 만드냐? `new Car()` 이렇게 만들지.

그래서 빈칸에 들어갈 코드는 **Car** 다.

```java
// 완성된 코드
class Car implements Runnable {
    int a;
    public void run(){
        System.out.println("lamborghini");
    }
}
public class Main { // 클래스 선언부에 () 빼는게 맞음
    public static void main(String[] args) throws Exception {
        Thread car1 = new Thread(new Car()); // 빈칸 채움
        car1.start();
    }
}
```

이렇게 하면 `new Car()`로 `Car` 객체가 만들어지고, 이 객체가 `Thread` 생성자에 전달됨. `car1.start()` 하면 이 스레드가 시작되고, 스레드는 자기가 가지고 있는 `Runnable` 객체(여기선 `Car` 객체)의 `run()` 메소드를 실행함. 그래서 "lamborghini"가 출력되는 거임. 알겠냐?

**주요 포인트**
*   Java에서 스레드를 생성하는 방법 중 하나는 `Runnable` 인터페이스를 구현한 클래스의 인스턴스를 `Thread` 생성자에 전달하는 것이다.
*   `Thread` 객체의 `start()` 메소드를 호출하면 해당 스레드가 시작되고, `Runnable` 객체의 `run()` 메소드가 실행된다.

---

### 12번 문제

**문제:**
12. 다음이 설명하는 인터페이스 검증 도구는 무엇인지 영문으로 작성하시오

```
- 자바 프로그래밍 언어를 기반으로 하는 단위 테스트 프레임워크로 단위 테스트는 소프트웨어 개발 과정에서 개별 컴포넌트, 함수, 메소드 또는 클래스와 같은 소프트웨어 단위를 분리하여 테스트하는 프로세스이다.
- 단위 테스트를 자동화하고 단위 테스트 케이스를 작성하고 실행하는 데 도움을 주는 도구이다.
```

**답변:**
야 ㅋㅋ 인터페이스 검증 도구 물어보네. 근데 설명 보니까 딱 단위 테스트 얘기잖아.

"**자바 프로그래밍 언어 기반**" 이고 "**단위 테스트 프레임워크**"래. 그리고 "**단위 테스트 자동화**", "**테스트 케이스 작성 및 실행**" 도와준다고? 이거 완전 자바 개발자들이 메소드나 클래스 하나하나 제대로 도는지 확인할 때 쓰는 국룰 툴 아니냐? ㅋㅋ

이 설명에 딱 맞는 건 **JUnit**이지. 자바 쓰는 사람들이면 이거 모르면 간첩 소리 듣는다 ㅋㅋ.

그래서 답은 **JUnit** 이다.

**주요 포인트**
*   **JUnit**: 자바 프로그래밍 언어용 단위 테스트 프레임워크.
*   개별 코드 단위(메소드, 클래스 등)를 테스트하는 데 사용된다.
*   테스트 케이스 작성, 실행, 결과 확인을 자동화하여 개발 생산성을 높인다.

---

### 13번 문제

**문제:**
13. 다음 중 블랙박스 테스트에 해당하는 것을 모두 고르시오.
```
ㄱ. Cause-Decision Graph ㄴ. Statement Coverage ㄷ. Boundary Value Analysis ㄹ. Equivalence Partitioning  ㅁ. Decision Coverage ㅂ. Cause-Effect Graphing Testing ㅅ. Base Path Coverage ㅇ. Boundary Division Analysis ㅈ. Base Path Testing
```

**답변:**
야 ㅋㅋ 블랙박스 테스트 고르라고? 블랙박스가 뭐냐? 속은 깜깜해서 안 보고, 걍 겉으로 드러난 기능만 보고 테스트하는 거잖아. 입력값 넣고 기대한 출력값 나오는지 확인하는 거. 코드 까보는 화이트박스랑 반대지.

답지 기준으로 다시 정리하면,

*   **ㄷ. Boundary Value Analysis**: 경계값 분석. 명세 기반이니까 **블랙박스 맞음**.
*   **ㄹ. Equivalence Partitioning**: 동등 분할. 이것도 명세 기반. **블랙박스 맞음**.
*   **ㅂ. Cause-Effect Graphing Testing**: 원인-결과 그래프. 이것도 명세 기반. **블랙박스 맞음**.

나머지 ㄴ, ㅁ, ㅅ, ㅈ는 코드 구조 보는 거니 **화이트박스** 확실하고.
ㄱ, ㅇ는 ㅂ, ㄷ과 너무 유사해서 대표 용어만 답으로 인정해서 빠진 걸로 보인다.

결론은 답지 따라 **ㄷ, ㄹ, ㅂ** 이게 맞는 거네. 쏘리 ㅋㅋ

**주요 포인트**
*   **블랙박스 테스트**: 소프트웨어 내부 구조를 참조하지 않고 기능 명세를 기반으로 테스트하는 기법.
*   **대표적인 블랙박스 테스트 기법**:
    *   **Equivalence Partitioning (동등 분할)**: 유사한 입력값/출력값을 그룹화하여 테스트 케이스 수를 줄임.
    *   **Boundary Value Analysis (경계값 분석)**: 입력값 범위의 경계 지점에서 오류가 발생할 확률이 높다는 점을 이용한 테스트.
    *   **Cause-Effect Graphing (원인-결과 그래프)**: 입력 조건(원인)과 출력 결과(결과) 간의 논리적 관계를 그래프로 표현하여 테스트 케이스 설계.
*   (화이트박스 테스트 기법: Statement Coverage, Decision Coverage, Base Path Testing 등)

---

### 14번 문제

**문제:**
14. 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
#include <stdio.h> // scanf, printf 사용을 위해 추가

int func(int a) {
    if(a <= 1) return 1;
    return a * func(a-1);
}
int main() {
    int a;
    scanf("%d", &a); // 5를 입력
    printf("%d", func(a));
    return 0; // main 함수 리턴 타입 맞춰줌
}
```

**답변:**
야 ㅋㅋ C언어 코드네. 이거 재귀 함수 문제다. `func` 함수가 자기 자신을 또 부르는 거 보이지?

1.  `main` 함수부터 봐봐. `a`라는 정수 변수 만들고 `scanf`로 입력을 받는데, 문제에서 **5를 입력**했다고 친절하게 알려줬네. 그럼 `a`는 5다.
2.  마지막에 `printf("%d", func(a));` 이걸로 `func(5)`의 결과값을 출력하는 거임.
3.  자 이제 `func` 함수가 어떻게 도는지 보자.
    *   `func(int a)`: 정수 `a`를 받는다.
    *   `if(a <= 1) return 1;`: 만약 `a`가 1보다 작거나 같으면 1을 반환하고 끝낸다. 이게 재귀 멈추는 조건임. 없으면 무한으로 돌다가 스택 터짐 ㅋㅋ.
    *   `return a * func(a-1);`: `a`가 1보다 크면, `a`랑 `func(a-1)`을 곱한 값을 반환한다. 즉, `a`에다가 `a-1`을 넣어서 자기 자신을 다시 부르는 거임.

4.  그럼 `func(5)`가 어떻게 계산되는지 따라가 보자.
    *   `func(5)` 호출 -> `5 > 1`이니까 `5 * func(4)` 반환 시도
    *   `func(4)` 호출 -> `4 > 1`이니까 `4 * func(3)` 반환 시도
    *   `func(3)` 호출 -> `3 > 1`이니까 `3 * func(2)` 반환 시도
    *   `func(2)` 호출 -> `2 > 1`이니까 `2 * func(1)` 반환 시도
    *   `func(1)` 호출 -> `1 <= 1`이니까 드디어 멈추고 `1` 반환!
    *   이제 거꾸로 올라가면서 계산하면 됨.
    *   `func(2)`는 `2 * func(1)` = `2 * 1 = 2` 반환
    *   `func(3)`은 `3 * func(2)` = `3 * 2 = 6` 반환
    *   `func(4)`는 `4 * func(3)` = `4 * 6 = 24` 반환
    *   `func(5)`는 `5 * func(4)` = `5 * 24 = 120` 반환

5.  결국 `main` 함수는 `func(5)`의 결과값인 120을 받아서 출력하겠지.

따라서 실행 결과는 **120** 이다. 이거 팩토리얼 계산하는 함수네 ㅋㅋ

**주요 포인트**
*   **재귀 함수(Recursive Function)**: 함수 내부에서 자기 자신을 다시 호출하는 함수.
*   재귀 함수는 반드시 **종료 조건**을 가져야 무한 루프에 빠지지 않는다. (여기서는 `a <= 1`)
*   해당 코드는 입력된 정수 `a`의 팩토리얼(`a!`)을 계산한다. (5! = 5 \* 4 \* 3 \* 2 \* 1 = 120)

---

### 15번 문제

**문제:**
15. 다음 C언어 프로그램은 변수 number의 값 1234를 역순으로 출력하는 프로그램이다. (1), (2), (3)에 들어갈 알맞은 연산자를 작성하시오

```c
#include <stdio.h> // printf 사용을 위해 추가

int main(){
    int number = 1234;
    int divider = 10;
    int result = 0;
    while (number (1) 0){
        result = result * divider;
        result = result + number (2) divider;
        number = number (3) divider;
    }
    printf("%d", result);
    return 0; // main 함수 리턴 추가
}
```

**답변:**
야 ㅋㅋ C언어 코드 빈칸 채우기네. 1234를 4321로 뒤집어서 출력하는 게 목표임.

`while` 루프 보니까 `number` 가지고 뭔가 조작해서 `result`에 쌓아가는 구조네. `divider`는 10이고. 딱 봐도 10진수 자릿수 가지고 장난치는 거임.

*   **(1) `while (number (1) 0)`**: 이 루프는 `number`가 0이 될 때까지 돌아야 함. 왜? 1234에서 4 뽑고 123 만들고, 3 뽑고 12 만들고, 2 뽑고 1 만들고, 1 뽑고 0 만들면 끝나니까. 즉, `number`가 0보다 **클 동안** 계속 돌아야지. 그래서 `>` 연산자가 필요함. (`!=`도 되긴 하는데, 양수만 다루니까 `>`가 더 명확함)

*   **(2) `result = result + number (2) divider;`**: 이건 `number`의 **마지막 자릿수**를 뽑아서 `result`에 더하는 부분임. `result`는 이미 `* 10` 해서 자릿수를 하나 올려놨거든 (예: 4 -> 40). 여기다가 `number`의 마지막 자릿수를 더해야지 (예: 40 + 3 = 43). 어떤 수의 마지막 자릿수를 얻으려면 10으로 나눈 **나머지**를 구하면 됨. 나머지 연산자는 `%`지.

*   **(3) `number = number (3) divider;`**: 이건 `number`에서 방금 뽑아 쓴 **마지막 자릿수를 없애는** 부분임. 1234에서 4를 썼으니 이제 123으로 만들어야 다음 루프에서 3을 뽑을 수 있잖아. 10으로 나눈 **몫**만 취하면 마지막 자릿수가 날아가지 (정수 나눗셈). 그래서 `/` 연산자가 필요함.

자, 그럼 `1234` 넣고 돌려보자.
1.  `number = 1234`, `result = 0`. `1234 > 0` 참.
2.  `result = 0 * 10 = 0`.
3.  `result = 0 + (1234 % 10) = 4`.
4.  `number = 1234 / 10 = 123`.
5.  `number = 123`, `result = 4`. `123 > 0` 참.
6.  `result = 4 * 10 = 40`.
7.  `result = 40 + (123 % 10) = 43`.
8.  `number = 123 / 10 = 12`.
9.  `number = 12`, `result = 43`. `12 > 0` 참.
10. `result = 43 * 10 = 430`.
11. `result = 430 + (12 % 10) = 432`.
12. `number = 12 / 10 = 1`.
13. `number = 1`, `result = 432`. `1 > 0` 참.
14. `result = 432 * 10 = 4320`.
15. `result = 4320 + (1 % 10) = 4321`.
16. `number = 1 / 10 = 0`.
17. `number = 0`, `result = 4321`. `0 > 0` 거짓. 루프 끝.
18. `printf("%d", result);` -> 4321 출력. 딱 맞네 ㅋㅋ

그래서 답은 이거다.

*   **(1) >**
*   **(2) %**
*   **(3) /**

**주요 포인트**
*   정수를 역순으로 만들기 위해 `while` 루프와 산술 연산자를 활용한다.
*   나머지 연산자 (`% 10`)는 숫자의 마지막 자릿수를 추출하는 데 사용된다.
*   정수 나누기 연산자 (`/ 10`)는 숫자의 마지막 자릿수를 제거하는 데 사용된다.
*   `result`를 10씩 곱해주면서 새로운 자릿수를 더해 역순 숫자를 구성한다.
*   루프는 원래 숫자가 0이 될 때까지 (즉, 0보다 클 동안) 반복된다.

---

### 16번 문제

**문제:**
16. 다음이 설명하는 용어를 영문 약어로 작성하시오

```
- 정보 보안 관리 체계를 나타내는 용어로, 조직 내부에서 정보 보안을 효과적으로 관리하고 보호하기 위한 체계적이고 체계적인 접근 방법을 제공하는 프레임워크 또는 시스템이다.
- 정보 보안을 계획, 구현, 모니터링 및 지속적으로 개선하기 위한 일련의 프로세스, 정책, 절차, 기술 및 사람에 대한 통합된 접근 방식을 제공한다.
- 조직의 정보 자산을 보호하고 정보 보안 위협으로부터 조직을 보호하기 위한 중요한 수단으로 사용되며, 정보 보안을 관리하고 개선하는 데 필요한 프로세스, 정책 및 실천 방법을 제공한다.
```

**답변:**
야 ㅋㅋ 이거 딱 보면 감 오지 않냐? 설명 겁나 길게 써놨는데 핵심은 이거잖아. **'정보 보안 관리 체계'**. 회사나 조직이 가진 소중한 정보들 안전하게 지키려고 온갖 규칙 만들고, 시스템 갖추고, 사람들 교육하고, 문제 생기면 고치고... 뭐 이런 거 체계적으로 관리하는 **종합 선물 세트** 같은 거임.

계획 세우고(Plan), 실행하고(Do), 계속 감시하고(Check), 문제 있으면 개선하고(Act) – 이 PDCA 사이클 돌리는 거 생각하면 딱이지. 단순히 백신 깔고 방화벽 세우는 기술적인 거 넘어서, 정책, 절차, 책임자 지정, 교육 훈련까지 다 포함하는 큰 틀을 말하는 거야.

이거 영어로 하면 **Information Security Management System** 이거든? 앞 글자만 따봐. I, S, M, S. 딱 나오네 ㅋㅋ

그래서 답은 **ISMS** 다.

**주요 포인트**
*   **ISMS (Information Security Management System)**: 조직의 정보 자산을 보호하기 위한 정책, 프로세스, 절차, 조직 구조, 소프트웨어 및 하드웨어 등을 포함하는 포괄적인 정보 보안 관리 체계.
*   정보 보안 위험을 관리하고 지속적으로 개선하기 위한 체계적인 접근 방식을 제공한다. (PDCA 모델 기반)

---

### 17번 문제

**문제:**
17. 다음 키(Key)에 대한 설명을 보고 (1), (2)에 들어갈 알맞은 특성을 작성하시오

```
슈퍼키(SuperKey)는 관계형 데이터베이스에서 튜플(레코드)을 고유하게 실별하는 데 사용될 수 있는 하나 이상의 속성 집합이다. 즉, 슈퍼키는 중복된 값을 가지지 않고, 각 튜플을 고유하게 식별할 수 있는 키이다. 따라서, 슈퍼키는 (1)의 특성을 갖게 된다.
반면 후보키(Candidate Key)는 (1)의 특성을 만족하는 슈퍼키 중에서도 (2)를 만족하는 키이다. 즉, 튜플과 고유하게 식별할 수 있는 최소한의 속성만을 포함하는 키이다.
```

**답변:**
야 ㅋㅋ 키(Key) 문제네. 데이터베이스에서 존나 중요한 개념이지. 설명 보고 빈칸 채워보자.

설명 보니까 슈퍼키는 일단 튜플(데이터 한 줄)을 **유일하게 식별**할 수만 있으면 된대. 속성이 하나든 여러 개든 상관없음. 즉, 그 키 값 알면 딱 어떤 놈인지 구별만 되면 장땡이라는 거. 이게 바로 키의 기본 중의 기본 속성, **(1) 유일성**이지. 어떤 키든 일단 유일성은 깔고 가야 함.

근데 후보키는 여기서 한 단계 더 나아감. 유일성은 당연히 만족해야 하고 (슈퍼키 중에서 고르는 거니까), 추가로 **(2) 최소성**을 만족해야 한대. 이게 뭔 말이냐면, 유일성을 만족하는 속성들 중에서 **가장 적은 수의 속성**으로만 이루어져야 한다는 거임. 더 이상 쪼개면 유일성이 깨지는, 딱 필요한 최소한의 속성 조합.

예를 들어 '학번' 하나만 있어도 학생 구별되잖아? 그럼 '학번'은 유일성 + 최소성 만족하니까 후보키임. 근데 '학번'이랑 '이름'을 묶어도 학생 구별은 되지? 그럼 이건 유일성은 만족하니까 슈퍼키는 맞는데, '이름' 없어도 '학번'만으로 구별되니까 최소성은 만족 못 함. 그래서 '학번+이름'은 후보키는 아님.

알겠냐? 슈퍼키는 유일성만, 후보키는 유일성 + 최소성 둘 다!

*   **(1) 유일성**
*   **(2) 최소성**

**주요 포인트**
*   **유일성 (Uniqueness)**: 키를 구성하는 속성(들)의 값은 릴레이션 내의 모든 튜플에서 유일해야 함 (중복 불가). 슈퍼키, 후보키, 기본키 모두 만족해야 하는 기본 속성.
*   **최소성 (Minimality)**: 키를 구성하는 속성 중 어느 하나라도 제거하면 유일성을 만족하지 못하게 되는 성질. 즉, 유일성을 만족하는 데 필요한 최소한의 속성으로만 구성되어야 함. 후보키와 기본키가 만족해야 하는 속성.

---

### 18번 문제

**문제:**
18. 다음이 설명하는 보안 위협은 무엇인지 <보기>를 보고 작성하시오

```
- 사이버 공격자가 특정 그룹이나 조직을 타겟으로 선택하여 해당 그룹이 빈번하게 방문하는 웹 사이트나 온라인 환경을 감시하고 공격 대상 그룹을 유인하기 위해 해당 웹 사이트를 감염시키는 공격 기술이다.
- 공격자는 이를 통해 정보 수집, 악성 코드 배포, 레버리지된 악의적 활동을 수행한다.
```
```
<보기>
ㄱ. Pharming ㄴ. Spear Phising ㄷ. Watering Hole ㄹ. DNS Spoofing ㅁ. Nimda ㅂ. Zero Day Attack ㅅ. Worm Virus ㅇ. Trap Door ㅈ. Cyber Kill Chain ㅊ. Ransomware
```

**답변:**
야 ㅋㅋ 이거 보안 문제네. 설명 딱 보면 그림 그려지지 않냐?

해커 새끼가 특정 회사나 집단 노리는데, 얘네한테 바로 안 덤비고 얘네가 **자주 가는 사이트** (뭐 커뮤니티나 뉴스 사이트 같은 거)를 미리 해킹해서 악성코드를 심어놓는 거임.

그러면 타겟들은 맨날 가던 사이트니까 아무 의심 없이 접속하겠지? 접속하는 순간! 악성코드 감염되고 정보 털리거나 랜섬웨어 걸리거나 하는 거임 ㅋㅋ 마치 사자가 물 마시러 오는 동물들 덮치려고 물웅덩이(**Watering Hole**) 근처에 숨어있는 거랑 똑같다고 해서 이런 이름 붙은 거임.

<보기> 보니까 **ㄷ. Watering Hole** 이거 딱 있네. 이게 정답임. 스피어 피싱(ㄴ)은 메일 같은 걸로 직접 낚는 거고, 파밍(ㄱ)은 가짜 사이트로 보내는 거고, 이건 자주 가는 사이트 자체를 감염시키는 거니까 다름.

**주요 포인트**
*   **Watering Hole Attack**: 공격 대상 그룹이 자주 방문하는 합법적인 웹사이트를 미리 감염시킨 후, 대상이 해당 사이트에 방문했을 때 악성코드에 감염시키는 표적 공격 기법.
*   공격자는 대상의 신뢰를 이용하여 방어망을 우회한다.

---

### 19번 문제

**문제:**
19. 다음 C언어 프로그램의 실행 결과를 작성하시오.

```c
#include <stdio.h> // printf 사용을 위해 추가

int isPrime(int number) {
    int i;
    // 1은 소수가 아니므로 추가 처리 (원 코드에는 없지만 명확성을 위해)
    if (number <= 1) return 0; 
    for(i = 2; i * i <= number; i++){ // 최적화: number의 제곱근까지만 확인
        if(number % i ==0)
        return 0;
    }
    return 1;
}
int main(void){
    int number = 13195, max_div=0, i;
    // 최적화: number의 제곱근까지만 확인해도 최대 소인수를 찾는데는 문제 없음
    // 하지만 원 코드 로직 그대로 따라가면 number까지 반복
    for(i = 2; i < number; i++) 
        if(isPrime(i) == 1 && number % i == 0)
            max_div = i;
    
    // 만약 위 루프에서 max_div가 0이고 number 자체가 소수일 경우 처리 (원 코드에는 없음)
    // if (max_div == 0 && isPrime(number)) max_div = number; 
    // 여기서는 number가 합성수이므로 위 로직 없어도 결과는 동일

    printf("%d", max_div);
    return 0;
}
```

**답변:**
야 ㅋㅋ C언어 코드 분석이네. 이거 소수(Prime number)랑 약수 찾는 거 섞여있다.

1.  **`isPrime` 함수부터 보자.**
    *   이 함수는 입력받은 `number`가 소수인지 아닌지 판단하는 놈임.
    *   `for` 루프 돌면서 2부터 `number - 1`까지 수(`i`)로 `number`를 나눠봄. (사실 제곱근까지만 봐도 되는데 코드는 그냥 number-1까지 다 봄)
    *   만약 한 번이라도 `number % i == 0` 이면 (즉, 나눠 떨어지면) 소수가 아니니까 바로 `0` 리턴하고 끝냄.
    *   루프 다 돌 때까지 한 번도 안 나눠 떨어졌으면 소수가 맞으니까 `1` 리턴함.
    *   (근데 사실 1 들어오면 1 리턴해서 좀 이상하긴 한데, `main`에서 2부터 쓰니까 문제는 없음 ㅋㅋ. 원래대로면 1은 소수 아니니까 0 리턴해야 맞음)

2.  **`main` 함수 보자.**
    *   `number`는 13195로 고정.
    *   `max_div`는 0으로 시작. 얘가 최종 답이 될 놈임.
    *   `for` 루프가 `i`를 2부터 13194까지 쭉 돌림.
    *   `if(isPrime(i) == 1 && number % i == 0)` 이 조건문이 핵심임.
        *   `isPrime(i) == 1`: 현재 `i`가 소수인지 확인.
        *   `number % i == 0`: 현재 `i`가 `number`(13195)의 약수인지 확인.
        *   `&&`: 두 조건 **모두** 참이어야 함. 즉, `i`가 **13195의 약수이면서 동시에 소수**여야 한다는 뜻. 이런 걸 **소인수**라고 부르지.
    *   만약 `i`가 13195의 소인수면, `max_div = i;` 이걸 실행함.
    *   루프는 `i` 값을 계속 증가시키면서 돌잖아? 그러니까 `if` 조건을 만족하는 `i`가 여러 개 나와도, `max_div`에는 **가장 마지막에** 조건을 만족한 `i` 값이 저장됨. 즉, 13195의 소인수 중에서 **가장 큰** 놈이 `max_div`에 남게 되는 거임.

3.  **그럼 13195의 소인수를 찾아보자.**
    *   13195 끝자리가 5니까 5로 나눠짐. `13195 / 5 = 2639`. 5는 소수 맞지? -> `max_div`는 5가 됨.
    *   2639를 또 나눠보자. 7로 나눠짐. `2639 / 7 = 377`. 7은 소수 맞지? -> `max_div`는 7로 업데이트.
    *   377을 또 나눠보자. 13으로 나눠짐. `377 / 13 = 29`. 13은 소수 맞지? -> `max_div`는 13으로 업데이트.
    *   29는 더 이상 안 나눠지는 소수임. `isPrime(29)`는 1이고, 13195는 29로 나눠 떨어지니까 (`13195 = 5 * 7 * 13 * 29`) -> `max_div`는 29로 업데이트.
    *   그 뒤로 `i`가 계속 커져도 13195의 약수가 되는 소수는 더 이상 없겠지. (루프는 13194까지 가지만)

4.  루프 다 끝나고 나면 `max_div`에는 마지막으로 업데이트된 값인 **29**가 남아있음.
5.  `printf("%d", max_div);` 하니까 29를 출력하겠네.

따라서 실행 결과는 **29** 다.

**주요 포인트**
*   `isPrime` 함수는 주어진 숫자가 소수인지 판별한다 (1: 소수, 0: 소수 아님).
*   `main` 함수는 2부터 `number-1`까지 반복하면서 `i`가 `number`의 약수(factor)이면서 동시에 소수(prime)인 경우 (`number`의 소인수, prime factor)를 찾는다.
*   `max_div = i`는 조건 만족 시 실행되므로, 루프가 끝나면 `max_div`에는 `number`의 소인수 중 가장 큰 값이 저장된다.
*   13195의 소인수는 5, 7, 13, 29이며, 이 중 가장 큰 값은 29이다.

---

### 소인수분해 쉽게 하는 방법

**질문:**
소인수를 쉽게 구하는 방법 좀 알려주셈

**답변:**
야 ㅋㅋ 소인수분해 쉽게 하는 법? 별거 없다. 걍 **가장 작은 소수부터** 차례대로 나눠보면 됨. 젤 무식한데 확실한 방법이다 ㅋㅋ

1.  **쪼갤 숫자를 가져온다.** (예: 13195)
2.  **가장 작은 소수(Prime number)인 2부터 시작한다.**
    *   13195가 2로 나눠지냐? -> 아니지? (홀수니까) 그럼 2는 패스.
3.  **다음 소수인 3으로 나눠본다.**
    *   13195가 3으로 나눠지냐? -> 각 자리수 합(1+3+1+9+5 = 19)이 3의 배수가 아니니까 안 나눠짐. 3도 패스.
4.  **다음 소수인 5로 나눠본다.**
    *   13195가 5로 나눠지냐? -> 어? 끝자리가 5네? 그럼 무조건 나눠짐!
    *   `13195 / 5 = 2639`. 오케이. 일단 소인수 **5** 하나 찾았다. 이제 남은 건 2639임.
5.  **남은 숫자(2639)를 가지고 다시 소수로 나눠본다.** 이때, 아까 나눴던 **5부터 다시 시작**해도 되는데, 딱 봐도 5로 안 나눠지겠지? 끝자리 9니까. 그럼 다음 소수로 넘어감.
6.  **다음 소수인 7로 나눠본다.**
    *   2639가 7로 나눠지냐? -> 계산기 두들겨보거나 나눠보면 됨. `2639 / 7 = 377`. 오! 나눠지네. 그럼 **7**도 소인수 당첨. 이제 남은 건 377.
7.  **남은 숫자(377)를 가지고 또 나눠본다.** 7로는 이제 안 나눠질 거 같지? (실제로 해보면 안 나눠짐)
8.  **다음 소수인 11로 나눠본다.**
    *   377이 11로 나눠지냐? -> 안 나눠짐. (377 / 11 = 34.2...) 패스.
9.  **다음 소수인 13으로 나눠본다.**
    *   377이 13으로 나눠지냐? -> `377 / 13 = 29`. 와우! 나눠지네. **13**도 소인수 추가. 이제 남은 건 29.
10. **남은 숫자(29)를 가지고 또 나눠본다.** 13 다음 소수는 17, 19, 23... 인데 얘네로 29 안 나눠지잖아. 근데 **29 자체가 소수**네? 더 이상 쪼갤 수 없는 놈이지. 그럼 **29**도 소인수 마지막으로 추가.
11. **결과**: 13195를 쪼개고 쪼개서 나온 소수들은 **5, 7, 13, 29** 임. `13195 = 5 * 7 * 13 * 29` 이렇게 된 거.

핵심은 이거다: **작은 소수부터 차례대로 계속 나눠보는 거.** 나눠지면 그 소수 기록하고, 몫 가지고 또 반복. 안 나눠지면 다음 소수로 넘어감. 언제까지? 몫이 1이 되거나 더 이상 안 나눠지는 소수가 나올 때까지. 알겠냐?

**주요 포인트**
*   소인수분해는 숫자를 소수들의 곱으로 나타내는 것.
*   가장 작은 소수(2, 3, 5, 7, 11...)부터 차례대로 나누어 본다.
*   나누어 떨어지면 해당 소수는 소인수이며, 몫을 대상으로 다시 같은 소수 또는 다음 소수로 나누기를 반복한다.
*   몫이 1이 되거나 소수가 되면 종료한다.

---

### 20번 문제

**문제:**
20. 다음은 소프트웨어 생명주기 모델 중 V-모델의 절차를 도식화 한 것이다. 빈칸에 들어갈 알맞은 테스트 기법을 나열하시오

```
                                                               ( 4 )
                                                               ↗
            요구분석      ←      요구 분석 검증      →      ( 3 )
                ↘                                        ↗
            아키텍처 설계     ← 인터페이스 검증 →      ( 2 )
                    ↘                                ↗
                    모듈 설계   ← 모듈 검증 →    ( 1 )
                            ↘                 ↗
                                    구현
```
```
<보기>
인수 테스트, 단위 테스트, 시스템 테스트, 통합 테스트
```

**답변:**
야 ㅋㅋ V-모델 문제네. 이거 왼쪽은 개발 단계 내려가는 거고, 오른쪽은 테스트 단계 올라가는 거잖아. 서로 짝꿍임.

1.  젤 밑바닥 **구현(코딩)** 하고 나면 뭘 테스트해야겠냐? 코드 쪼가리 하나하나, 즉 **모듈(단위)** 제대로 도는지 봐야지. 이게 **(1) 단위 테스트** 임.
2.  그다음 모듈들 합쳐서(통합해서) 서로 문제없이 잘 붙어 돌아가는지 봐야지. **아키텍처 설계** 때 생각한 대로 인터페이스 잘 맞는지 보고. 이게 **(2) 통합 테스트** 임.
3.  통합까지 끝났으면 이제 시스템 전체가 **요구분석**에서 정한 대로 기능 다 잘 돌아가는지 통으로 테스트해야지. 이게 **(3) 시스템 테스트** 임.
4.  마지막으로, 사용자가 진짜 써도 되는지, 요구사항 다 만족하는지 최종 확인 받아야지. 이게 **(4) 인수 테스트** 임.

<보기>에 있는 거 순서대로 딱딱 맞네 ㅋㅋ

*   **(1) 단위 테스트**
*   **(2) 통합 테스트**
*   **(3) 시스템 테스트**
*   **(4) 인수 테스트**

**주요 포인트**
*   **V-모델**: 소프트웨어 개발 생명주기 모델로, 개발 단계와 각 단계에 대응하는 테스트 단계를 V자 형태로 표현하여 검증과 확인을 강조함.
*   **테스트 단계 매칭**:
    *   구현(코딩) ↔ **단위 테스트 (Unit Test)**: 개별 모듈(컴포넌트) 검증
    *   상세/모듈 설계 ↔ **통합 테스트 (Integration Test)**: 모듈 간 인터페이스 및 상호작용 검증
    *   아키텍처/기본 설계 ↔ **시스템 테스트 (System Test)**: 전체 시스템이 요구사항 명세를 만족하는지 검증
    *   요구 분석 ↔ **인수 테스트 (Acceptance Test)**: 사용자의 요구사항을 만족하는지 최종 검증 (사용자 관점)
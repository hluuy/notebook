# 2022 기출 02회 해설

### 문제 1

다음이 설명하고 있는 관계 데이터 연산을 표현하는 방법의 빈칸에 들어갈 알맞은 용어를 작성하시오

```
- ( )은/는 수학의 Predicate Calculus에 기반을 두고 있으며, 관계 데이터 모델의 제안자인 Codd가 수학적인 기반을 두고 특별히 관계 데이터베이스를 위해 제안하였다.
- 관계 데이터베이스 관리에서 관계를 조작하기 위한 비절차적인 방법의 하나이다.
- ( )에는 도메인 ( )과 튜플 ( )가 있다.
```

**답변:**

아 ㅋㅋ 이거 딱 보면 각 나오지 않냐?

-   **수학의 Predicate Calculus 기반**, **Codd 아재**가 제안, **비절차적 방법**? 이거 완전 **관계 해석 (Relational Calculus)** 설명이잖아 ㅋㅋ 관계 대수랑 맨날 비교되는 그거 맞음 ㅇㅇ. 관계 대수는 '어떻게' 가져올지 절차를 따지는 거고, 관계 해석은 '뭘' 원하냐 결과만 딱 정의하는 비절차적인 방식임.
-   그리고 관계 해석에는 종류가 두 개 있잖냐. 원하는 튜플들이 만족해야 할 조건을 **도메인 변수**랑 그 변수가 취하는 값으로 기술하는 **도메인 관계 해석 (Domain Relational Calculus)** 하고, **튜플 변수**를 사용하는 **튜플 관계 해석 (Tuple Relational Calculus)**.
-   그러니까 문제에서 "( )에는 도메인 ( )과 튜플 ( )가 있다" 이 부분은 "관계 해석에는 도메인 관계 해석과 튜플 관계 해석이 있다" 이 말이지.

그래서 빈칸에 들어갈 말은 다 **관계 해석** 임.

```
- (관계 해석)은/는 수학의 Predicate Calculus에 기반을 두고 있으며, 관계 데이터 모델의 제안자인 Codd가 수학적인 기반을 두고 특별히 관계 데이터베이스를 위해 제안하였다.
- 관계 데이터베이스 관리에서 관계를 조작하기 위한 비절차적인 방법의 하나이다.
- (관계 해석)에는 도메인 (관계 해석)과 튜플 (관계 해석)가 있다.
```

근데 보통 저 마지막 문장은 '도메인 관계 해석', '튜플 관계 해석' 이라고 종류 이름 써주는 게 더 정확하긴 한데, 문제 구조상 그냥 '관계 해석' 넣으라는 의도 같아 보이네 ㅋㅋ 걍 '관계 해석'으로 밀고 가자.

---

**📌 이 문제 핵심 포인트 정리**

1.  **관계 해석 (Relational Calculus)**: 정의 꼭 알아둬라. **수학 기반(Predicate Calculus)**, **Codd 아재**, **비절차적** 이게 키워드임. 원하는 데이터가 뭔지만 선언하는 방식. (SQL이 여기에 기반했지)
2.  **비절차적 언어**: '뭘 원하냐'만 명시하는 거. 어떻게 가져올지는 DBMS가 알아서 함. (↔ 절차적 언어: 관계 대수처럼 '어떻게 가져올지' 순서대로 명시)
3.  **관계 해석 종류**: **도메인 관계 해석**이랑 **튜플 관계 해석** 두 개 있다는 거 기억 ㄱㄱ.

---

### 문제 2

다음 (1)과 (2)에서 설명하는 암호화 기술을 <보기>를 참조하여 작성하시오

```
(1) : 1991년에 개발된 블록 암호화 알고리즘으로, 블록 크기는 64비트이며, 128비트 대칭키를 사용한다. Feistel 구조를 사용하고 있으며, 라운드 함수를 8회 반복 적용하여 암호화를 수행한다. 하지만, 특허권 문제로 인해 많은 제약이 따르기 때문에 최근에는 대체재로 AES가 널리 사용되고 있다.
(2) : 미국 국립안보국에서 개발된 블록 암호화 알고리즘으로, 64비트 블록 크기와 80비트 대칭키를 사용한다. 대칭키 암호화 알고리즘에 해당하므로 암호화와 복호화에 동일한 키를 사용한다. 일반적으로 Clipper 칩에 내장되어 기밀성을 보호하였으나, Clipper 칩의 사용이 논란이 되면서 널리 사용하지 않게 되었다.
```
```
<보기>
DES, AES, SKIPJACK, RSA, DSA, IDEA, SEED
```

**답변:**

아 ㅋㅋ 이번엔 암호 문제네? 보자보자... <보기>에 있는 놈들 중에 찾는 거구만.

**(1)번 설명 분석 드간다.**

*   **1991년 개발, 블록 암호, 블록 크기 64비트, 키 128비트, Feistel 구조, 8 라운드**: 오... 스펙이 꽤 자세하네. 이 조건들 보면 딱 떠오르는 애가 있어야 하는데...
*   **특허권 문제, 대체재 AES**: 이게 존나 결정적인 힌트지 ㅋㅋ 특허 때문에 쓰기 좀 껄끄러웠고, 요즘엔 AES가 대세잖아? 이 조건까지 합치면 **IDEA** 아니냐 이거? IDEA 스펙이 딱 저렇거든. 1991년, 64비트 블록, 128비트 키, 8라운드. PGP 초기에 쓰였던 그 알고리즘 맞음.
*   <보기>에 IDEA 있나? 있네! 그럼 (1)번 답은 **IDEA**.

**(2)번 설명 분석 드간다.**

*   **NSA 개발, 블록 암호, 64비트 블록, 80비트 키**: NSA가 만들었다는 게 좀 특이점인데. 64비트 블록에 80비트 키 쓰는 놈...
*   **Clipper 칩 내장, 논란**: ㅋㅋㅋㅋㅋ 이거 완전 **SKIPJACK** 얘기잖아! 클리퍼 칩! 미국 정부가 통신 감청하려고 밀어붙이다가 백도어 논란 때문에 개같이 멸망한 그 칩! 거기에 들어간 알고리즘이 바로 스킵잭임. NSA가 만들고, 스펙도 64비트 블록, 80비트 키 딱 맞음.
*   <보기>에 SKIPJACK 있나? 있네! 그럼 (2)번 답은 **SKIPJACK**.

자, 그럼 정리하면 답은 이거지.

```
(1) IDEA
(2) SKIPJACK
```

<보기>에도 둘 다 있고, 설명이랑 딱딱 들어맞으니 이게 정답임 ㅇㅇ.

---

**📌 이 문제 핵심 포인트 정리**

1.  **주요 대칭키 블록 암호 알고리즘 스펙 암기**: 각 알고리즘별 **개발 기관/년도, 블록 크기, 키 길이, 라운드 수, 특징(Feistel 구조 여부, 특허/논란 등)** 같은 핵심 스펙은 외워두는 게 좋음. 특히 DES, AES, IDEA, SEED 정도는 필수!
2.  **IDEA 특징**: 1991년 개발, 64비트 블록, 128비트 키, 8 라운드, **특허 문제**, PGP 초기 사용.
3.  **SKIPJACK 특징**: **NSA 개발**, 64비트 블록, 80비트 키, **Clipper 칩**, 백도어 논란으로 실패.
4.  **문제 키워드 캐치**: 설명에서 **결정적인 키워드 (예: 특허, Clipper 칩, NSA 등)** 를 빠르게 찾는 연습이 중요함.

---

### 문제 3

다음 [상품] 테이블을 대상으로 하는 <SQL문>은 '제조사'가 'H'인 상품의 '단가'보다 큰 제품을 검색하는 쿼리이다. 빈칸에 들어갈 알맞은 명령을 작성하시오

```
[상품]
| 제품명 | 단가 | 제조사 |
| 라면 | 1500 | A |
| 커피 | 2300 | H |
| 사탕 | 1000 | A |
| 과자 | 3000 | C |
| 커피 | 2500 | C |
| 라면 | 1800 | H |
```
```
<SQL문>
SELECT 제품명, 단가, 제조사
FROM 상품
WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
```

**답변:**

아 ㅋㅋ SQL 문제 나왔네. 바로 풀어보자.

일단 문제가 뭐냐면, [상품] 테이블에서 '제조사'가 'H'인 놈들 ('커피' 2300원짜리, '라면' 1800원짜리)의 '단가'보다 **비싼** 제품을 찾는 거임.

자, SQL문 까보자.

```sql
SELECT 제품명, 단가, 제조사
FROM 상품
WHERE 단가 > ( ) (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
```

여기서 `(SELECT 단가 FROM 제품 WHERE 제조사 = 'H')` 이 부분이 서브쿼리인데, 실행하면 결과가 뭐가 나오냐? 제조사 'H'인 애들 단가니까 `2300` 하고 `1800` 두 개가 나오겠지?

그럼 메인 쿼리는 `WHERE 단가 > ( ) (2300, 1800)` 이런 식이 되는 거임. 근데 서브쿼리 결과가 값이 하나가 아니라 여러 개(2개)잖아? 그냥 `>` 같은 비교 연산자만 쓰면 에러남. 이럴 때 쓰라고 있는 게 `ALL`, `ANY` 같은 연산자임.

*   `> ALL`: 괄호 안의 **모든** 값보다 커야 함. 즉, `단가 > 2300 AND 단가 > 1800` 이니까 결국 `단가 > 2300` 이랑 같은 의미.
*   `> ANY` (또는 `> SOME`): 괄호 안의 값 중 **어느 하나**보다만 크면 됨. 즉, `단가 > 2300 OR 단가 > 1800` 이니까 결국 `단가 > 1800` 이랑 같은 의미.

문제에서 "제조사가 'H'인 상품의 '단가'보다 큰 제품"이라고 했잖아? 이건 보통 그 제조사 H 제품들 **모두** 보다 비싼 걸 의미함. 즉, H사 제품 최고가(2300원)보다 비싼 걸 찾으라는 소리임. 만약 '어느 하나보다 비싼' 이었으면 `ANY` 쓰겠지만, 통상적으로는 `ALL`을 써서 가장 비싼 놈보다 비싼 걸 찾으라는 의미로 해석하는 게 일반적임.

그래서 빈칸에는 **ALL** 이 들어가야 함.

```sql
SELECT 제품명, 단가, 제조사
FROM 상품
WHERE 단가 > ALL (SELECT 단가 FROM 제품 WHERE 제조사 = 'H');
```

이렇게 하면 단가가 2300보다 큰 '과자' (3000원)랑 '커피' (2500원, 제조사 C) 이 두 놈이 결과로 나오겠지.

---

**📌 이 문제 핵심 포인트 정리**

1.  **서브쿼리 (Subquery)**: SQL문 안에 포함된 또 다른 SELECT문. 메인 쿼리의 조건 등으로 활용됨.
2.  **다중 행 서브쿼리 비교 연산자**: 서브쿼리 결과가 여러 행(값)일 때 메인 쿼리와 비교하기 위해 사용하는 연산자.
    *   **ALL**: 서브쿼리의 *모든* 결과값에 대해 조건을 만족해야 함 (`> ALL`은 최댓값보다 큼).
    *   **ANY (SOME)**: 서브쿼리의 결과값 중 *어느 하나라도* 조건을 만족하면 됨 (`> ANY`는 최솟값보다 큼).
    *   **IN**: 서브쿼리 결과값 중에 *같은* 값이 있으면 참. (`= ANY`와 동일)
    *   **EXISTS**: 서브쿼리 결과값이 *존재하면* 참.
3.  **문맥 파악**: 문제에서 요구하는 조건이 '모든 값보다' 큰 것인지, '어느 하나보다' 큰 것인지 잘 파악해서 `ALL` 이나 `ANY` 를 선택해야 함. (보통 명시 없으면 `ALL` 로 해석될 때가 많음)

---

### 문제 4

다음의 [Test] 테이블에 대하여 <SQL문>을 수행했을 때의 결과를 작성하시오

```
[Test]
| col1 | col2 | col3 |
| 1 | 2 | null |
| 2 | 3 | 6 |
| 3 | 5 | 5 |
| 4 | 6 | 3 |
| 5 | null | 3 |
```
```
<SQL문>
SELECT COUNT(col3)
FROM Test
WHERE col2 IN(2,3) OR col3 IN(3,5)
```

**답변:**

오케이, SQL 실행 결과 맞추는 문제구만. 테이블이랑 쿼리 보고 따라가보자.

**[Test] 테이블:**

| col1 | col2 | col3 |
| :--- | :--- | :--- |
| 1    | 2    | null |
| 2    | 3    | 6    |
| 3    | 5    | 5    |
| 4    | 6    | 3    |
| 5    | null | 3    |

**<SQL문>:**

```sql
SELECT COUNT(col3)
FROM Test
WHERE col2 IN(2,3) OR col3 IN(3,5);
```

자, 순서대로 함 보자.

1.  **`FROM Test`**: 일단 `Test` 테이블을 대상으로 함.
2.  **`WHERE col2 IN(2,3) OR col3 IN(3,5)`**: 이제 조건에 맞는 행을 골라내야 함. `OR` 조건이니까 둘 중 하나만 만족해도 OK.
    *   **1번 행 (1, 2, null)**: `col2`가 2니까 `col2 IN(2,3)`은 참(TRUE). 뒤는 볼 필요 없이 **선택됨**.
    *   **2번 행 (2, 3, 6)**: `col2`가 3이니까 `col2 IN(2,3)`은 참(TRUE). 뒤는 볼 필요 없이 **선택됨**.
    *   **3번 행 (3, 5, 5)**: `col2`가 5니까 `col2 IN(2,3)`은 거짓(FALSE). 근데 `col3`가 5니까 `col3 IN(3,5)`는 참(TRUE). `FALSE OR TRUE`는 TRUE니까 **선택됨**.
    *   **4번 행 (4, 6, 3)**: `col2`가 6이니까 `col2 IN(2,3)`은 거짓(FALSE). 근데 `col3`가 3이니까 `col3 IN(3,5)`는 참(TRUE). `FALSE OR TRUE`는 TRUE니까 **선택됨**.
    *   **5번 행 (5, null, 3)**: `col2`가 `null`이니까 `col2 IN(2,3)`은 알 수 없음(UNKNOWN). 근데 `col3`가 3이니까 `col3 IN(3,5)`는 참(TRUE). `UNKNOWN OR TRUE`는 TRUE니까 **선택됨**.

    결국 `WHERE` 조건 거치니까 1, 2, 3, 4, 5번 행이 다 선택되네?

3.  **`SELECT COUNT(col3)`**: 이제 선택된 행들 (1, 2, 3, 4, 5번 행) 중에서 `col3`의 개수를 세야 함. 근데 여기서 개 중요한 게 `COUNT(컬럼명)`은 해당 컬럼 값이 **NULL인 경우는 제외**하고 센다는 거임. `COUNT(*)`랑 다르다 이거지.
    *   선택된 행들의 `col3` 값: `null`, `6`, `5`, `3`, `3`
    *   이 중에서 NULL 아닌 값들: `6`, `5`, `3`, `3`
    *   NULL 아닌 값의 개수는? 총 **4개**.

따라서 <SQL문>을 수행했을 때의 결과는 **4** 임.

---

**📌 이 문제 핵심 포인트 정리**

1.  **WHERE 절 조건 평가**: `IN` 연산자는 괄호 안의 값 목록 중 하나와 일치하면 TRUE. `OR` 연산자는 연결된 조건 중 하나라도 TRUE이면 전체가 TRUE. (`NULL`과의 비교는 UNKNOWN이 되지만, `UNKNOWN OR TRUE`는 TRUE임)
2.  **COUNT 함수 특징**:
    *   `COUNT(*)`: `WHERE` 조건을 만족하는 *행의 총 개수*를 반환 (NULL 포함).
    *   `COUNT(컬럼명)`: `WHERE` 조건을 만족하는 행 중에서 해당 *컬럼의 값이 NULL이 아닌 것*들의 개수를 반환.
    *   `COUNT(DISTINCT 컬럼명)`: `WHERE` 조건을 만족하는 행 중에서 해당 컬럼의 *중복을 제외한, NULL이 아닌 값*들의 개수를 반환.
3.  **NULL 처리**: SQL에서 `NULL`은 '값이 없음'을 의미하며, 일반적인 산술/비교 연산 시 특별하게 처리됨. `COUNT(컬럼명)`에서 제외된다는 점 꼭 기억해야 함.

---

### 문제 5

다음 설명이 의미하는 것이 무엇인지 영문 약어로 작성하시오

```
- 인터넷을 통해 디바이스 간에 사설 네트워크 연결을 생성한다.
- 퍼블릭 네트워크를 통해 데이터를 안전하게 익명으로 전송하는 데 사용된다.
- 사용자 IP 주소를 마스킹하고 데이터를 암호화하여 수신 권한이 없는 사람이 읽을 수 없도록 한다.
```

**답변:**

아 ㅋㅋ 이거 완전 그거네 그거.

*   인터넷 쓰는데 **사설 네트워크**처럼 연결해 준다? 이거 딱 **터널링** 개념인데.
*   공용망(인터넷)에서 **안전하게 + 익명으로** 데이터 보낸다? **암호화** 기본으로 깔고, 내 IP 숨겨주는 기능이 있다는 거네.
*   **IP 주소 마스킹 + 데이터 암호화**? 위에 나온 얘기 다시 한번 확인사살 해주는구만.

이 세 가지 특징 다 합쳐보면 뭐겠냐? 바로 **VPN** 이지 ㅋㅋㅋ 가상 사설망! 인터넷 회선으로 가상의 전용선 같은 걸 만들어서 데이터 암호화해서 보내고, 내 진짜 IP 대신 VPN 서버 IP 보여줘서 숨겨주는 거. 딱 설명이랑 일치하잖아.

그러니까 답은 **VPN** 임. (Virtual Private Network 약자)

---

**📌 이 문제 핵심 포인트 정리**

1.  **VPN (Virtual Private Network)**: 정의를 알아두자. 공중망(인터넷)을 통해 사설망과 같은 효과를 내는 가상 네트워크 기술.
2.  **VPN 핵심 기능**:
    *   **터널링 (Tunneling)**: 공중망 상에 가상의 통로를 만들어 데이터를 전송.
    *   **암호화 (Encryption)**: 터널을 통해 전송되는 데이터를 암호화하여 기밀성 보장.
    *   **IP 마스킹 (IP Masking)**: 사용자의 실제 IP 주소를 VPN 서버의 IP 주소로 가려 익명성/프라이버시 강화.
3.  **VPN 주요 용도**: 보안 강화, 원격 접속, 지역 제한 콘텐츠 접근, 프라이버시 보호 등.

---

### 문제 6

객체 지향 프로그래밍에서의 설계 원칙인 SOLID 원칙 중 클라이언트는 자신이 사용하지 않는 메서드에 의존성을 가져서는 안 되고, 인터페이스는 클라이언트의 요구에 따라 분리되어야 한다는 원칙을 <보기>를 참조하여 작성하시오.

```
<보기>
SRP(Single Responsibility Principle), OCP(Open/Closed Principle), LSP(Liskov Substitution Principle), ISP(Interface Segregation Principle), DIP(Dependency Inversion Principle)
```

**답변:**

아 ㅋㅋ SOLID 문제구만. 객체지향 설계 5대 원칙 중에 하나 맞추는 거네.

자, 설명을 다시 보자.

*   **클라이언트는 자신이 사용하지 않는 메서드에 의존성을 가져서는 안 된다**: 이게 뭔 소리냐면, 인터페이스에 메소드가 한 10개 있는데, 어떤 클라이언트는 그 중에 2개만 쓴다고 치자. 근데 인터페이스가 통짜로 하나면, 이 클라이언트는 자기가 쓰지도 않는 나머지 8개 메소드까지 알아야 하고, 만약 그 8개 중 하나가 바뀌면 이 클라이언트도 영향을 받을 수 있다는 거임. 개불편하겠지?
*   **인터페이스는 클라이언트의 요구에 따라 분리되어야 한다**: 그래서! 저런 불편함을 없애려면, 인터페이스를 잘게 쪼개라는 거임. 클라이언트 A가 쓰는 기능 묶어서 인터페이스 A 만들고, 클라이언트 B가 쓰는 기능 묶어서 인터페이스 B 만들고... 이렇게 분리(Segregation)하라는 거지.

이 두 가지 설명을 합쳐보면 딱 나오지 않냐? **인터페이스를 분리하라 (Interface Segregation)** 이거잖아 ㅋㅋ 뚱뚱한 인터페이스 하나 만들어서 클라이언트한테 다 떠넘기지 말고, 클라이언트가 필요한 것들만 모아서 작은 인터페이스 여러 개로 만들라는 원칙.

<보기>에서 찾아보면 **ISP(Interface Segregation Principle)** 이 바로 그놈임. 인터페이스 분리 원칙.

그래서 답은 **ISP(Interface Segregation Principle)** 임.

---

**📌 이 문제 핵심 포인트 정리**

1.  **ISP (Interface Segregation Principle) 정의**: 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하도록 강요받아서는 안 된다는 원칙. 즉, **인터페이스를 클라이언트에 맞게 분리**해야 함.
2.  **ISP 목표**: "뚱뚱한(fat)" 인터페이스 대신, 작고 구체적인 인터페이스 여러 개를 만들어 클라이언트와 인터페이스 간의 **결합도를 낮추는 것**.
3.  **핵심 아이디어**: 인터페이스를 기능별, 클라이언트별로 **분리(Segregation)**하여 필요한 것만 사용하도록 유도.
4.  **SOLID 원칙 암기**: SRP, OCP, LSP, ISP, DIP 각 원칙의 핵심 개념과 이름을 정확히 매칭해서 기억해야 함.

---

### 문제 7

다음 Java 프로그램의 실행 결과를 작성하시오

```java
public class Main {
    public static void main(String[] args) throws Exception {
        int a = 3;
        int b = 1;
        switch(a) {
            case 1:
                b += 1;
            case 2:
                b++;
            case 3:
                b = 0;
            case 4:
                b += 3;
            case 5:
                b -= 10;
            default:
                b--;
        }
        System.out.print(b);
    }
}
```

**답변:**

아 ㅋㅋ 자바 코드 결과 맞추는 거네. 함 돌려보자고.

```java
public class Main {
    public static void main(String[] args) throws Exception {
        int a = 3; // a는 3으로 시작
        int b = 1; // b는 1로 시작

        switch(a) { // a가 3이니까 case 3으로 점프!
            case 1: // 여긴 아님
                b += 1;
            case 2: // 여기도 아님
                b++;
            case 3: // 여기다!
                b = 0; // b가 0이 됨. 근데 break가 없네? 계속 간다 ㅋㅋ
            case 4: // break 없어서 여기도 실행됨
                b += 3; // b는 0 + 3 = 3이 됨. 또 break 없네?
            case 5: // break 없어서 여기도 실행됨
                b -= 10; // b는 3 - 10 = -7이 됨. 또 break 없네?
            default: // break 없어서 default까지 옴 ㅋㅋ
                b--; // b는 -7 - 1 = -8이 됨.
        }
        // switch문 끝남. 최종 b 값은 -8

        System.out.print(b); // b 값(-8)을 출력
    }
}
```

자, 분석 끝났지?

1.  `a`는 3, `b`는 1로 시작.
2.  `switch(a)` 에서 `a`가 3이니까 `case 3:` 으로 바로 감.
3.  `case 3:` 에서 `b = 0;` 실행. `b`는 0이 됨.
4.  근데 `case 3:` 끝에 `break;` 가 없음. 이럼 밑으로 줄줄이 실행되는 **fall-through** 현상이 발생함.
5.  `case 4:` 실행. `b += 3;` 해서 `b`는 `0 + 3 = 3` 됨.
6.  또 `break;` 없음.
7.  `case 5:` 실행. `b -= 10;` 해서 `b`는 `3 - 10 = -7` 됨.
8.  또 `break;` 없음.
9.  `default:` 실행. `b--;` 해서 `b`는 `-7 - 1 = -8` 됨.
10. 이제 `switch` 문 끝남.
11. `System.out.print(b);` 로 최종 `b` 값인 **-8**을 출력함.

결과는 **-8** 이다 이거야.

---

**📌 이 문제 핵심 포인트 정리**

1.  **`switch` 문 동작 방식**: `switch` 괄호 안의 값과 일치하는 `case` 레이블로 이동하여 실행 시작.
2.  **`break` 문의 중요성**: 각 `case` 블록 끝에 `break;` 가 없으면, 다음 `case` (또는 `default`) 블록으로 넘어가서 코드가 계속 실행됨. 이를 **fall-through** 라고 함.
3.  **fall-through**: `break` 를 만나거나 `switch` 문이 끝날 때까지 아래쪽 `case` 와 `default` 가 순차적으로 실행되는 현상. 이 문제의 핵심 함정임.
4.  **`default` 블록**: 일치하는 `case` 가 없거나, fall-through 로 인해 도달했을 때 실행됨. `switch` 문 가장 마지막에 위치하는 것이 일반적이지만, 필수는 아님. `default` 뒤에도 `break` 가 없으면 그 아래 `case` 로 fall-through 될 수도 있음 (이 코드에선 맨 마지막이라 해당 없음).

---

### 문제 8

다음 C언어 프로그램의 실행 결과를 작성하시오

```c
struct nums {
    int n;
    int g;
};
int main() {
    struct nums a[2];
    for(int i = 0; i < 2; i++){
        a[i].n = i;
        a[i].g = i + 1;
    }
    printf("%d", a[0].n + a[1].g);
    return 0;
}
```

**답변:**

오 C언어 코드네. 구조체랑 배열 쓰는 거 보니까 기본기는 좀 있어야 풀겠구만. 함 보자.

```c
// nums라는 이름의 구조체 정의. 정수형 멤버 n과 g를 가짐.
struct nums {
    int n;
    int g;
};

int main() {
    // nums 구조체 2개를 담을 수 있는 배열 a 선언. a[0], a[1] 이렇게 두 칸짜리임.
    struct nums a[2];

    // for 루프: i가 0부터 1까지 총 2번 돈다.
    for(int i = 0; i < 2; i++){
        // i가 0일 때:
        // a[0].n = 0; (a 배열의 첫 번째 구조체 n 멤버에 0 저장)
        // a[0].g = 0 + 1; (a 배열의 첫 번째 구조체 g 멤버에 1 저장)
        // i가 1일 때:
        // a[1].n = 1; (a 배열의 두 번째 구조체 n 멤버에 1 저장)
        // a[1].g = 1 + 1; (a 배열의 두 번째 구조체 g 멤버에 2 저장)
        a[i].n = i;
        a[i].g = i + 1;
    }
    // 루프 끝나면 a[0]에는 {n:0, g:1}, a[1]에는 {n:1, g:2} 가 저장된 상태.

    // printf: 정수(%d)를 출력하는데, 뭘 출력하냐면 a[0].n + a[1].g 값을 출력함.
    // a[0].n 값은 위에서 0으로 저장됐고,
    // a[1].g 값은 위에서 2로 저장됐음.
    // 그러니까 0 + 2 를 계산해서 출력하는 거임.
    printf("%d", a[0].n + a[1].g); // 0 + 2 = 2 출력

    return 0;
}
```

자, 코드 흐름 따라가보니까 쉽지?

1.  `nums` 구조체 정의.
2.  `nums` 구조체 2개짜리 배열 `a` 생성.
3.  `for` 루프 돌면서 배열 초기화:
    *   `i=0` 일 때 `a[0].n = 0`, `a[0].g = 1`
    *   `i=1` 일 때 `a[1].n = 1`, `a[1].g = 2`
4.  `printf` 에서 `a[0].n` (값은 0) 이랑 `a[1].g` (값은 2) 를 더해서 출력.
5.  `0 + 2 = 2`.

따라서 최종 결과는 **2** 임.

---

**📌 이 문제 핵심 포인트 정리**

1.  **구조체 (struct)**: C언어에서 관련된 데이터를 하나로 묶는 사용자 정의 자료형. 멤버 접근은 `.` 연산자 사용 (예: `variable.member`).
2.  **구조체 배열**: 구조체 여러 개를 담는 배열. 각 요소는 구조체 변수이며, 멤버 접근은 `array[index].member` 형식 사용.
3.  **for 루프**: 지정된 횟수만큼 코드 블록 반복 실행. 배열 초기화 등에 자주 사용됨.
4.  **변수 값 추적**: 프로그램 실행 흐름에 따라 변수(특히 배열 요소나 구조체 멤버)의 값이 어떻게 변하는지 정확히 추적하는 것이 중요함.
5.  **printf 형식 지정자**: `%d` 는 정수(int) 값을 십진수로 출력하는 형식 지정자.

---

### 문제 9

다음의 IP 주소와 서브넷 마스크를 참조하여 빈 칸 (1), (2)에 들어갈 알맞은 값을 작성하시오

| IP 주소 | 서브넷 마스크 |
| 192.127.19.132 | 255.255.255.192 |

| IP 주소의 네트워크 주소 | 호스트 주소의 개수 (네트워크 주소와 브로드캐스트 주소 제외) |
| 192.127.19.(1) | (2)|

**답변:**

아 ㅋㅋ IP 문제네. 서브네팅 좀 할 줄 아나 테스트하는 거구만. 바로 계산 드가자.

**주어진 정보:**

*   IP 주소: `192.127.19.132`
*   서브넷 마스크: `255.255.255.192`

**(1) 네트워크 주소 구하기**

네트워크 주소는 IP 주소랑 서브넷 마스크랑 **비트 단위 AND 연산**하면 나옴.

*   IP 주소랑 서브넷 마스크를 2진수로 바꿔야 하는데, 앞 세 덩어리(옥텟)는 서브넷 마스크가 `255` (`11111111`)니까 AND 연산해도 IP 주소 그대로 내려옴. 즉, `192.127.19` 이건 확정.
*   문제는 마지막 옥텟임.
    *   IP 마지막 옥텟 `132` 를 2진수로: `10000100` (128 + 4)
    *   서브넷 마스크 마지막 옥텟 `192` 를 2진수로: `11000000` (128 + 64)
*   이제 이 둘을 AND 연산하자. 각 자리 비트가 둘 다 1이어야 결과가 1, 아니면 0.
    ```
      10000100  (132)
    & 11000000  (192)
    ----------
      10000000
    ```
*   결과 `10000000` 을 10진수로 바꾸면? 딱 `128` 이네.
*   그러므로 네트워크 주소는 `192.127.19.128` 임.
*   따라서 빈칸 (1)에 들어갈 값은 **128**.

**(2) 호스트 주소의 개수 구하기**

*   호스트 주소 개수는 서브넷 마스크를 보고 판단함. 서브넷 마스크에서 `0`으로 된 비트가 호스트 ID를 나타내는 부분임.
*   서브넷 마스크 `255.255.255.192` 를 2진수로 보면 `11111111.11111111.11111111.11000000` 임.
*   마지막 옥텟 `11000000` 에서 `0`이 몇 개냐? **6개** 있네. 이게 호스트 ID 비트 수임.
*   호스트 ID 비트 수가 `n`개일 때, 할당 가능한 총 IP 개수는 2<sup>n</sup> 개임. 여기선 n=6 이니까 2<sup>6</sup> = 64개.
*   근데 문제에서 "네트워크 주소와 브로드캐스트 주소 제외"라고 했잖아? 모든 호스트 비트가 0인 네트워크 주소랑, 모든 호스트 비트가 1인 브로드캐스트 주소, 이 두 개는 실제 장비에 할당 못 함.
*   그래서 실제 사용 가능한 호스트 주소 개수는 `2^n - 2` 임.
*   계산하면 2<sup>6</sup> - 2 = 64 - 2 = 62개.
*   따라서 빈칸 (2)에 들어갈 값은 **62**.

**정리:**

(1) = 128
(2) = 62

---

**📌 이 문제 핵심 포인트 정리**

1.  **네트워크 주소 계산**: IP 주소와 서브넷 마스크를 **비트 단위 AND 연산**하여 구함.
2.  **호스트 ID 비트 수**: 서브넷 마스크를 2진수로 변환했을 때 **0의 개수**가 호스트 ID 비트 수(n)임.
3.  **사용 가능한 호스트 개수**: 호스트 ID 비트 수가 n개일 때, 실제 장비에 할당 가능한 IP 주소의 개수는 **2<sup>n</sup> - 2** 임. (-2 하는 이유는 네트워크 주소와 브로드캐스트 주소를 제외하기 때문).
4.  **2진수 변환 및 연산**: IP 주소와 서브넷 마스크 관련 계산은 2진수 기반으로 이루어지므로, 10진수 ↔ 2진수 변환 및 비트 연산(AND)에 익숙해져야 함.

---

### 문제 10

다음이 설명하고 있는 테스트의 종류는 무엇인지 빈칸 (1), (2)에 알맞은 말을 작성하시오

```
(1) 테스트와 (2) 테스트는 소프트웨어 개발 주기의 단계로서, 제품이 출시되기 전에 제품을 테스트하고 개선하기 위해 수행한다.

(1) 테스트는 제품의 초기 버전을 테스트하는 단계이다. 이 단계에서는 개발자나 내부 테스터가 제품을 테스트하며, 버그나 결함 등을 찾고 수정한다. 이 과정은 보통 개발 초기에 이루어지며, 제품의 안정성을 검증하고 기능을 완성하기 위해 사용된다.

(2) 테스트는 (1) 테스트 이후, 일반 사용자가 제품을 사용하고 피드백을 제공하는 단계이다. 이 단계에서는 제품의 완성도를 높이기 위해 최종 버그 및 결함을 찾고 수정한다. (2) 테스트를 통해 사용자들의 의견을 반영하며, 제품을 개선하고 안정성을 높이기 위해 노력한다.

(1) 테스트와 (2) 테스트는 제품 출시 전 중요한 단계로서 제품의 품질과 안정성을 높이기 위해 필수적이다. 이를 통해 제품 출시 후에 발생할 수 있는 문제들을 사전에 방지할 수 있으며, 사용자들의 만족도를 높이기 위한 노력으로 이어진다.
```

**답변:**

아 ㅋㅋ 이거 딱 보면 답 나오는 각 아니냐? 알파랑 베타 테스트 설명이네.

*   **(1) 설명**: **초기 버전**, **개발자나 내부 테스터**가 테스트, **개발 초기**, **안정성/기능 완성** 목표. 이거 완전 내부 테스트잖아. 지들끼리 먼저 돌려보는 거. 이게 **알파(Alpha)** 테스트지.
*   **(2) 설명**: **(1) 테스트 이후**, **일반 사용자**가 써보고 피드백, **최종 버그 수정**, **사용자 의견 반영**. 알파 끝나고 외부 사용자들한테 뿌려서 막판 점검 + 피드백 받는 거. 이게 **베타(Beta)** 테스트임.

개발 순서도 알파 -> 베타 순서 맞고, 설명도 딱딱 들어맞네.

그래서 빈칸에 들어갈 말은 이거임.

(1) **알파 (Alpha)**
(2) **베타 (Beta)**

---

**📌 이 문제 핵심 포인트 정리**

1.  **알파 테스트 (Alpha Test)**:
    *   **시기**: 개발 초기 단계, 베타 테스트 이전.
    *   **테스터**: 주로 **내부 직원 (개발자, QA팀 등)**. 통제된 환경에서 수행.
    *   **목표**: 주요 기능 동작 확인, 심각한 버그 발견 및 수정, 내부적인 안정성 검증.
2.  **베타 테스트 (Beta Test)**:
    *   **시기**: 알파 테스트 이후, 정식 출시 직전.
    *   **테스터**: **외부 실제 사용자 (일반 사용자)**. 실제 사용 환경에서 수행.
    *   **목표**: 다양한 환경에서의 호환성/성능 테스트, 사용자 관점에서의 사용성 평가, 최종 버그 발견 및 수정, 사용자 피드백 수집.
3.  **테스트 순서**: 일반적으로 **알파 테스트 → 베타 테스트** 순서로 진행됨.
4.  **공통 목표**: 정식 제품 출시 전 품질 향상 및 안정성 확보.

---

### 문제 11

변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는 테스트를 의미하는 용어를 <보기>에서 찾아 작성하시오

```
<보기>
Recovery, Stress, Performance, Structure, Regression, Paralle, Security
```

**답변:**

아 ㅋㅋ 이 문제 쉽네. 키워드가 딱 보이잖아.

**"변경 또는 수정된 코드"** 에 대해서 **"새로운 결함 발견 여부"** 를 평가하는 테스트.

이거 완전 **회귀 테스트 (Regression Test)** 설명 아니냐? 코드 고쳤더니 다른 멀쩡하던 게 맛이 가거나, 아니면 고친 부분 때문에 또 다른 새로운 버그가 생기지는 않았는지 확인하는 거잖아. 말 그대로 기능이 '퇴행(Regression)'했는지 보는 테스트임.

<보기> 딱 보면 **Regression** 있네. 바로 이거지.

답은 **Regression** 임.

---

**📌 이 문제 핵심 포인트 정리**

1.  **회귀 테스트 (Regression Testing) 정의**: 코드 수정, 변경 또는 기능 추가 후, 이로 인해 기존 기능에 오류가 생기거나 새로운 오류가 발생하지 않았는지 확인하는 테스트.
2.  **회귀 테스트 목적**: 변경으로 인한 **의도치 않은 부작용 (Side Effect)** 이나 **기능 퇴행**을 방지하는 것.
3.  **회귀 테스트 시점**: 소프트웨어 변경(버그 수정, 기능 개선, 리팩토링 등)이 발생한 **이후**에 수행됨.
4.  **중요성**: 소프트웨어 유지보수 단계에서 시스템의 안정성을 유지하는 데 필수적인 테스트 활동임.

---

### 문제 12

다음의 [직원] 테이블에서 <관계대수>를 수행하였을 때의 결과 (1), (2), (3), (4), (5)를 작성하시오

```
[직원]
| 사번 | 이름 | 직급 | 부서 |
| 101 | 김수일 | 과장 | 경리부 |
| 103 | 오지영 | 대리 | 총무부 |
| 106 | 이지영 | 부장 | 기획부 |
| 108 | 홍기훈 | 사원 | 인사부 |
```
```
<관계대수>
Π<sub>직급</sub>(직원)
```
```
<실행 결과>
(1) :
(2) :
(3) :
(4) :
(5) :
```

**답변:**

아 ㅋㅋㅋ 맞네 맞네. 내가 깜빡했다. 관계대수 결과도 결국 **릴레이션(테이블)** 이니까, 속성 이름(컬럼 헤더)이 있어야지. 문제 형식상 그냥 값만 쭉 쓰는 줄 알았는데, 헤더 포함해서 쓰라는 의도였나 보네.

OK, 수정 드간다.

**<관계대수>**

```
Π직급(직원)
```

이 연산의 결과는 '직급'이라는 속성 하나만 가진 새로운 테이블임.

**[직원] 테이블에서 '직급' 값들:**

*   과장
*   대리
*   부장
*   사원

중복 없으니까 그대로 다 나옴. 결과 테이블은 이렇게 생겼겠지.

| 직급 |
| :--- |
| 과장 |
| 대리 |
| 부장 |
| 사원 |

이걸 문제의 `<실행 결과>` 형식에 맞춰 써보면, 첫 줄에 컬럼 헤더인 '직급'이 들어가고, 그 다음 줄부터 값들이 쭉 나오는 게 맞겠네.

```
<실행 결과>
(1) : 직급
(2) : 과장
(3) : 대리
(4) : 부장
(5) : 사원
```

이렇게 쓰는 게 더 정확하겠다. 네 말이 맞음 ㅇㅇ.

---

**📌 이 문제 핵심 포인트 정리**

1.  **관계대수 (Relational Algebra)**: 관계형 데이터베이스에서 원하는 데이터를 얻기 위해 사용하는 절차적인 언어. 연산자 기호를 사용함.
2.  **프로젝션 (Projection, Π)**: 특정 **속성(열, 컬럼)** 들을 선택하는 연산. 결과 릴레이션(테이블)에는 해당 속성 이름(헤더)과 값들이 포함됨. 결과 릴레이션에서 **중복된 튜플(행)은 제거됨**.
3.  **결과는 릴레이션 (집합)**: 관계대수 연산의 결과는 항상 릴레이션(테이블)이며, 속성 이름(헤더)과 튜플(데이터)로 구성됨. 릴레이션은 튜플의 중복을 허용하지 않음.
4.  **기호 숙지**: Π (프로젝션), σ (셀렉션), ⋈ (조인), ∪ (합집합), - (차집합), ∩ (교집합), × (카티션 프로덕트) 등 주요 연산자 기호와 의미를 알아야 함.

---

### 문제 13

다음 Python 프로그램의 실행 결과를 작성하시오

```python
s = "REMEMBER NOVEMBER"
a = s[:3] + s[12:16]
b = "R AND %s" % "STR"
print(a+b)
```

**답변:**

아 ㅋㅋㅋ 미안하다. 인덱스 세는 걸 계속 틀렸네;; 다시 세보자 제대로.

```
s = "REMEMBER NOVEMBER"

s[0]  = 'R'
s[1]  = 'E'
s[2]  = 'M'
s[3]  = 'E'
s[4]  = 'M'
s[5]  = 'B'
s[6]  = 'E'
s[7]  = 'R'
s[8]  = ' '  <-- 공백
s[9]  = 'N'
s[10] = 'O'
s[11] = 'V'
s[12] = 'E'  <-- 아 내가 이걸 계속 M으로 봤네. E 맞네 E.
s[13] = 'M'
s[14] = 'B'
s[15] = 'E'
s[16] = 'R'
```

니 말이 맞았다. `s[12]` 는 'E' 임 ㅋㅋ

자 그럼 코드 다시 돌려보자.

```python
s = "REMEMBER NOVEMBER"

a = s[:3] + s[12:16]
# s[:3] 은 인덱스 0, 1, 2 -> "REM" (이건 맞았고)
# s[12:16] 은 인덱스 12, 13, 14, 15 -> "EMBE" (이게 맞는 거였음)
# a = "REM" + "EMBE" -> a는 "REMEMBE" 가 됨

b = "R AND %s" % "STR"
# 이건 그대로 b = "R AND STR"

print(a+b)
# a는 "REMEMBE"
# b는 "R AND STR"
# 합치면 "REMEMBE" + "R AND STR" = "REMEMBE R AND STR"
```

아오... 미안하다 진짜. 내가 인덱스를 잘못 세서 삽질했네. 결과는 **REMEMBE R AND STR** 이 맞다. 니가 정확했음.

---

**📌 이 문제 핵심 포인트 정리**

1.  **문자열 인덱싱 & 슬라이싱**: 인덱스는 **0부터 시작**하며, **공백도 인덱스를 차지**한다는 점을 명심해야 함. 슬라이싱 `[start:end]`는 `start` 인덱스부터 `end-1` 인덱스까지의 문자를 포함함. **정확하게 인덱스를 세는 것이 매우 중요!**
2.  **문자열 연결 (Concatenation)**: `+` 연산자로 문자열을 이어붙임.
3.  **문자열 포매팅 (String Formatting)**: `%` 연산자나 다른 포매팅 방법을 사용하여 문자열 내에 값을 삽입.
4.  **코드 실행 추적**: 변수 값의 변화를 단계별로 정확히 따라가야 실수를 줄일 수 있음 (나처럼 실수하지 마라 ㅋㅋ).

---

### 문제 14

다음은 라우팅 프로토콜에 대한 설명이다. 빈칸에 들어갈 알맞은 프로토콜을 <보기>를 참조하여 작성하시오.

```
(1)은 하나의 자율 시스템 내에서 라우터 간 라우팅 정보를 교환하기 위한 라우팅 프로토콜로 라우팅 테이블을 유지하여 데이터 패킷을 효율적으로 전달하며 종류에는 RIP, ( 2 ) 등이 있다. 그 중 ( 2 )는 하나의 자율 시스템 내에서 라우터 간 라우팅 정보를 교환하기 위한 ( 1 ) 프로토콜 중 하나이다. 대규모 기업 네트워크를 지원하도록 설계된 오픈 스탠다드 프로토콜로 최단 경로 우선 알고리즘을 사용하여 데이터 전달에 최적화된 경로를 계산한다.

(3)은 서로 다른 자율 시스템 간에 라우팅 정보를 교환하기 위한 라우팅 프로토콜로 인터넷을 구성하기 위해 여러 개의 네트워크를 연결하는 데 사용된다. ( 4 )가 가장 흔히 사용되는 (3)이다. (4)는 서로 다른 자율 시스템 간에 라우팅 정보를 교환하기 위한 (3) 프로토콜로 거리 벡터 라우팅 알고리즘을 사용한다. (4)는 높은 확장성과 자율 시스템 간 트래픽 라우팅에 대한 다양한 정책을 지원하도록 설계되어 있다.
```
```
<보기>
BGP, OSPF, IGP, EGP
```

**답변:**

아 ㅋㅋ 라우팅 프로토콜 문제네. 네트워크 좀 공부했으면 바로 맞출 수 있는 거. 함 까보자.

**첫 번째 문단 분석 ( (1), (2) )**

*   **(1)** 설명: "**하나의 자율 시스템(AS) 내**에서" 쓰는 라우팅 프로토콜. AS 내부용 프로토콜을 뭐라고 부르냐? **IGP (Interior Gateway Protocol)** 라고 부르지. 딱 봐도 이거네.
*   **(2)** 설명: IGP의 종류 중 하나래. RIP 말고 다른 예시. "**대규모** 네트워크", "**오픈 스탠다드**", "**최단 경로 우선 알고리즘 (SPF)**" 사용. 이거 완전 **OSPF (Open Shortest Path First)** 설명이잖아 ㅋㅋ RIP는 소규모용이고 거리 벡터 방식인데, OSPF는 대규모용이고 링크 상태(SPF) 방식임.
*   <보기>에 IGP, OSPF 둘 다 있네? 그럼 됐고.

**두 번째 문단 분석 ( (3), (4) )**

*   **(3)** 설명: "**서로 다른 자율 시스템(AS) 간**에" 쓰는 라우팅 프로토콜. AS 외부, 즉 AS 끼리 연결할 때 쓰는 건 뭐다? **EGP (Exterior Gateway Protocol)** 임.
*   **(4)** 설명: EGP 중에서 제일 흔하게 쓰이는 거래. AS 간 라우팅 정보 교환. "**높은 확장성**", "**다양한 정책 지원**". 인터넷에서 AS 간 라우팅 표준으로 쓰이는 게 뭐냐? 바로 **BGP (Border Gateway Protocol)** 지. BGP는 경로 벡터(Path Vector) 방식인데, 문제에서 거리 벡터라고 좀 뭉뚱그려 말한 감은 있지만, AS 간 라우팅 + 확장성 + 정책 = BGP 빼박임.
*   <보기>에 EGP, BGP 둘 다 있네? 이것도 됐고.

**자, 정리하면 답은 이거지.**

(1) : **IGP**
(2) : **OSPF**
(3) : **EGP**
(4) : **BGP**

---

**📌 이 문제 핵심 포인트 정리**

1.  **라우팅 프로토콜 구분**:
    *   **IGP (Interior Gateway Protocol)**: **하나의 자율 시스템 (AS) 내부**에서 사용. (예: RIP, OSPF, EIGRP)
    *   **EGP (Exterior Gateway Protocol)**: **서로 다른 자율 시스템 (AS) 간**에 사용. (예: BGP)
2.  **주요 IGP 특징**:
    *   **RIP (Routing Information Protocol)**: 거리 벡터 알고리즘, 소규모 네트워크에 적합, 홉 카운트 기반 (최대 15홉).
    *   **OSPF (Open Shortest Path First)**: 링크 상태 알고리즘 (SPF, Dijkstra), 대규모 네트워크에 적합, 오픈 스탠다드, 빠른 수렴.
3.  **주요 EGP 특징**:
    *   **BGP (Border Gateway Protocol)**: 현재 인터넷에서 사용하는 표준 EGP, 경로 벡터 알고리즘 기반, 대규모 네트워크 환경(인터넷)에 적합, 높은 확장성 및 다양한 라우팅 정책 적용 가능.
4.  **용어 매칭**: 문제 설명의 키워드(AS 내부/외부, 알고리즘 종류, 규모, 표준 등)와 프로토콜 이름을 정확히 연결하는 것이 중요함.

---

### 문제 15

다음 C언어 프로그램의 실행 결과를 작성하시오

```c
int len(char*p);
int main(){
    char* ps1 = "1234";
    char* ps2 = "123456";
    int a1 = ps1;
    int a2 = ps2;
    printf("%d", len(a1) + len(a2));
    return 0;
}
int len(char* p){
    int r = 0;
    while(*p != '\0'){
        p++;
        r++;
    }
    return r;
}
```

**답변:**

아 ㅋㅋ C언어 포인터랑 함수 문제네. 이거 좀 함정이 있을 수 있으니 잘 봐야 함.

```c
// 문자열 길이를 구하는 함수 정의. char 포인터를 받아서 '\0' 만날 때까지 카운트 증가.
int len(char* p);

int main() {
    // ps1은 문자열 "1234"의 시작 주소를 가리킴.
    char* ps1 = "1234";
    // ps2는 문자열 "123456"의 시작 주소를 가리킴.
    char* ps2 = "123456";

    // !!! 여기가 문제 !!!
    // 포인터(메모리 주소)를 정수형 변수에 그냥 할당함.
    // a1에는 ps1이 가리키는 주소값이 (int 크기에 맞춰서, 아마 잘려서) 들어감.
    // a2에는 ps2가 가리키는 주소값이 (int 크기에 맞춰서, 아마 잘려서) 들어감.
    // 이건 매우 위험하고 잘못된 코드임. 포인터를 정수에 담으면 안 됨.
    int a1 = ps1;
    int a2 = ps2;

    // len 함수를 호출하는데, 파라미터로 정수 a1, a2를 넘김.
    // len 함수는 char* 포인터를 받기로 되어 있는데, int를 받고 있음.
    // 컴파일러가 이걸 어떻게 처리할지는 미정의 동작(Undefined Behavior)에 가까움.
    // 만약 컴파일러가 관대해서 int를 그냥 포인터 주소값으로 해석해준다고 '가정'하면...
    // len(a1)은 len(ps1)처럼 동작해서 "1234"의 길이 4를 반환할 '수도' 있고,
    // len(a2)는 len(ps2)처럼 동작해서 "123456"의 길이 6을 반환할 '수도' 있음.
    // 하지만 이건 보장되지 않음. 주소값이 int에 담기면서 잘렸거나 잘못 해석될 가능성이 높음.
    // 만약 그렇게 '의도대로' 동작한다고 치면, 4 + 6 = 10 이 출력될 것임.
    printf("%d", len(a1) + len(a2));

    return 0;
}

// 문자열 길이 계산 함수
int len(char* p) {
    int r = 0;
    // 포인터 p가 가리키는 곳의 문자가 널 문자('\0')가 아니면 반복
    while (*p != '\0') {
        p++; // 포인터를 다음 문자로 이동
        r++; // 길이 카운터 증가
    }
    return r; // 계산된 길이 반환
}
```

자, 이 코드의 핵심 문제는 `int a1 = ps1;` 과 `int a2 = ps2;` 부분임. 포인터는 메모리 주소인데, 이걸 그냥 `int` 변수에 넣는 건 위험천만한 짓임. 포인터 크기랑 `int` 크기가 다르면 주소값이 잘려나갈 수도 있고, 나중에 `len` 함수에 이 `int` 값을 넘겼을 때 함수는 이걸 `char*` 로 해석하려고 시도함. 정수 값을 강제로 주소값으로 해석해서 메모리에 접근하면 어떻게 될까?

1.  **운 좋게** (혹은 컴파일러/시스템이 관대해서) 원래 주소값이 보존되고 `len` 함수가 제대로 동작해서 `len("1234")` 결과인 4와 `len("123456")` 결과인 6을 얻고, 그 합인 **10**이 출력될 수도 있음. **아마 문제 출제 의도는 이걸 거임.**
2.  **대부분의 경우** 잘못된 메모리 주소에 접근하려고 시도하기 때문에 **세그멘테이션 오류 (Segmentation Fault)** 같은 런타임 에러가 발생하며 프로그램이 비정상 종료될 가능성이 높음.

근데 정보처리기사 실기 시험에서는 보통 이런 UB(Undefined Behavior)까지 깊게 파고들기보다는 코드의 *의도된* 흐름을 따라가서 결과를 내는 경우가 많음. 그래서 출제자는 `a1`이 `ps1`의 역할을, `a2`가 `ps2`의 역할을 그대로 할 거라고 기대했을 가능성이 큼.

따라서, '의도대로' 동작한다고 가정하고 풀면,
`len(a1)` 은 `len("1234")` 와 같아서 4를 반환.
`len(a2)` 는 `len("123456")` 와 같아서 6을 반환.
`printf("%d", 4 + 6);` 이므로 결과는 **10** 임.

(만약 실제 코딩 환경이었다면 저런 코드는 절대 짜면 안 되고, 결과도 보장 못 함.)

---

**📌 이 문제 핵심 포인트 정리**

1.  **포인터와 문자열**: C언어에서 문자열은 보통 `char*` 포인터로 다루며, 포인터는 문자열의 첫 번째 문자 주소를 가리킴. 문자열의 끝은 널 문자(`\0`)로 표시됨.
2.  **사용자 정의 함수 (`len`)**: 함수의 정의와 호출 과정을 이해해야 함. 이 함수는 포인터를 받아 널 문자를 만날 때까지 이동하며 길이를 계산함.
3.  **포인터와 정수 간의 변환 (위험성 인지)**: 포인터(주소값)를 일반 정수형 변수에 할당하는 것은 매우 위험하며, 데이터 손실이나 잘못된 메모리 접근(Undefined Behavior)을 유발할 수 있음. 이 코드의 가장 큰 문제점임.
4.  **문제 출제 의도 파악**: 시험 문제에서는 종종 기술적으로는 문제가 있는 코드라도, 작성자의 *의도된 논리*를 따라 결과를 도출하도록 요구하는 경우가 있음. (여기서는 포인터를 int에 넣었지만 원래 포인터처럼 작동하길 기대하는 것).
5.  **결과 계산**: (문제가 의도한 대로 동작한다고 가정 시) `len("1234")`는 4, `len("123456")`는 6. 따라서 `4 + 6 = 10`.

---

### 문제 16

다음 C언어 프로그램의 실행 결과를 작성하시오

```c
int main(){
    int arr1[4] = {0, 2, 4, 8};
    int arr2[3] = {};
    int *p, i, sum = 0;
    for(i = 1; i < 4; i++){
        p = arr1 + i;
        arr2[i-1] = *p - arr1[i-1];
        sum = sum + arr2[i-1] + arr1[i];
    }
    printf("%d", sum);
    return 0;
}
```

**답변:**

오케이 C언어 코드 또 나왔네. 이번엔 배열이랑 포인터 같이 쓰네. 정신 바짝 차리고 함 따라가 보자.

```c
int main(){
    // arr1 배열 초기화: {0, 2, 4, 8}
    int arr1[4] = {0, 2, 4, 8};
    // arr2 배열 초기화: 명시적으로 안 줬으니 전부 0으로 초기화됨. {0, 0, 0}
    int arr2[3] = {};
    // 포인터 변수 p, 정수 i, 정수 sum(0으로 초기화) 선언
    int *p, i, sum = 0;

    // for 루프: i가 1부터 3까지 1씩 증가하며 총 3번 반복 (i=1, i=2, i=3)
    for(i = 1; i < 4; i++){
        // p는 arr1[i]의 메모리 주소를 가리킴.
        p = arr1 + i; // 포인터 연산. arr1은 배열의 시작 주소, +i 하면 i번째 요소의 주소.

        // arr2[i-1]에 값을 계산해서 넣음.
        // *p는 p가 가리키는 값, 즉 arr1[i] 임.
        // arr1[i-1]은 arr1의 이전 요소 값.
        // 결국 arr2[i-1] = arr1[i] - arr1[i-1] (현재 요소 - 이전 요소 값)
        arr2[i-1] = *p - arr1[i-1];

        // sum 값을 업데이트 함.
        // sum = 기존 sum + 방금 계산한 arr2[i-1] + 현재 요소 값 arr1[i]
        sum = sum + arr2[i-1] + arr1[i];
    }
    // 루프 끝나면 최종 sum 값 출력
    printf("%d", sum);
    return 0;
}
```

자, 루프 한 바퀴씩 돌려보자.

**초기 상태:**
`arr1 = {0, 2, 4, 8}`
`arr2 = {0, 0, 0}`
`sum = 0`

**i = 1 일 때:**
1.  `p = arr1 + 1;` (p는 `arr1[1]` 즉, 값 2의 주소를 가리킴)
2.  `*p = 2`
3.  `arr1[i-1] = arr1[0] = 0`
4.  `arr2[i-1] = arr2[0] = *p - arr1[i-1] = 2 - 0 = 2`
    (이제 `arr2 = {2, 0, 0}`)
5.  `arr1[i] = arr1[1] = 2`
6.  `sum = sum + arr2[0] + arr1[1] = 0 + 2 + 2 = 4`
    (이제 `sum = 4`)

**i = 2 일 때:**
1.  `p = arr1 + 2;` (p는 `arr1[2]` 즉, 값 4의 주소를 가리킴)
2.  `*p = 4`
3.  `arr1[i-1] = arr1[1] = 2`
4.  `arr2[i-1] = arr2[1] = *p - arr1[i-1] = 4 - 2 = 2`
    (이제 `arr2 = {2, 2, 0}`)
5.  `arr1[i] = arr1[2] = 4`
6.  `sum = sum + arr2[1] + arr1[2] = 4 + 2 + 4 = 10`
    (이제 `sum = 10`)

**i = 3 일 때:**
1.  `p = arr1 + 3;` (p는 `arr1[3]` 즉, 값 8의 주소를 가리킴)
2.  `*p = 8`
3.  `arr1[i-1] = arr1[2] = 4`
4.  `arr2[i-1] = arr2[2] = *p - arr1[i-1] = 8 - 4 = 4`
    (이제 `arr2 = {2, 2, 4}`)
5.  `arr1[i] = arr1[3] = 8`
6.  `sum = sum + arr2[2] + arr1[3] = 10 + 4 + 8 = 22`
    (이제 `sum = 22`)

루프 끝! `i`가 4가 되면 `i < 4` 조건이 거짓이라 종료됨.

최종 `sum` 값은 **22** 이다. `printf`로 이 값을 출력하니까 결과는 **22**.

---

**📌 이 문제 핵심 포인트 정리**

1.  **배열 초기화**: `int arr[] = {};` 와 같이 초기화 값을 생략하면 모든 요소가 0으로 초기화됨.
2.  **포인터와 배열**: 배열 이름 자체는 배열의 첫 번째 요소의 주소를 나타냄. `arr + i`는 배열의 `i`번째 요소의 주소를 의미함 (인덱스는 0부터 시작).
3.  **포인터 역참조 (`*`)**: 포인터 변수 앞에 `*`를 붙이면, 해당 포인터가 가리키는 메모리 주소에 저장된 **값**을 가져옴. (`*p`는 `p`가 가리키는 곳의 값).
4.  **배열 인덱싱**: `arr[i]`는 배열 `arr`의 `i`번째 요소의 값을 의미함 (인덱스는 0부터 시작).
5.  **루프 내 변수 추적**: `for` 루프가 반복될 때마다 각 변수(특히 배열 요소와 `sum`)의 값이 어떻게 변하는지 정확히 계산하고 추적해야 함.

---

### 문제 17

다음 Java 프로그램의 실행 결과를 작성하시오

```java
class comp{
    int a;
    comp(int a){
        this.a = a;
    }
    int func(){
        int b = 1;
        for (int i = 1 ; i < a; i++){
            b = a * i + b;
        }
        return a + b;
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        comp obj = new comp(3);
        obj.a = 5;
        int b = obj.func();
        System.out.print(obj.a + b);
    }
}
```

**답변:**

아 ㅋㅋ 자바 클래스랑 메소드 문제구만. 이것도 차근차근 따라가면 답 나옴.

```java
// comp 클래스 정의
class comp {
    int a; // 인스턴스 변수 a

    // 생성자: 정수 하나 받아서 인스턴스 변수 a 초기화
    comp(int a) {
        this.a = a;
    }

    // func 메소드: 인스턴스 변수 a를 사용해서 계산하고 int 값 반환
    int func() {
        int b = 1; // 지역 변수 b 초기화
        // for 루프: i가 1부터 시작해서 인스턴스 변수 a보다 작을 때까지 반복
        // 현재 obj.a는 5 이므로, i는 1, 2, 3, 4 일 때 반복함.
        for (int i = 1; i < a; i++) {
            // b 값을 업데이트: b = (현재 a 값) * i + (이전 b 값)
            b = a * i + b;
        }
        // 루프 끝나고 최종 a + b 값 반환
        return a + b;
    }
}

// 메인 클래스
public class Main {
    // 메인 메소드
    public static void main(String[] args) throws Exception {
        // comp 객체 생성, 생성자에 3 전달.
        // 이 시점: obj.a = 3
        comp obj = new comp(3);

        // obj의 인스턴스 변수 a 값을 5로 '변경'함. 중요!
        // 이 시점: obj.a = 5
        obj.a = 5;

        // obj의 func() 메소드 호출, 그 결과를 지역 변수 b에 저장.
        // func() 내부 계산 시작 (현재 obj.a는 5임):
        // 1. 초기 b = 1
        // 2. i = 1: b = a * i + b = 5 * 1 + 1 = 6
        // 3. i = 2: b = a * i + b = 5 * 2 + 6 = 10 + 6 = 16
        // 4. i = 3: b = a * i + b = 5 * 3 + 16 = 15 + 16 = 31
        // 5. i = 4: b = a * i + b = 5 * 4 + 31 = 20 + 31 = 51
        // 루프 끝 (i가 5가 되면 i < a 즉 5 < 5 는 거짓)
        // func()는 a + b를 반환: 5 + 51 = 56
        int b = obj.func(); // 메인 메소드의 지역 변수 b에 56 저장

        // obj.a 값 (현재 5) + 지역 변수 b 값 (56) 을 출력
        // 5 + 56 = 61
        System.out.print(obj.a + b);
    }
}
```

자, 단계별로 추적해보자.

1.  `comp` 객체 `obj` 생성 시 `obj.a`는 3이 됨.
2.  바로 다음 줄에서 `obj.a = 5;` 로 값이 **5로 변경**됨. 이게 중요 포인트!
3.  `obj.func()` 호출 시 `func` 메소드 안에서는 `a` 값으로 5를 사용함.
4.  `func` 내부 `for` 루프 (`i`는 1, 2, 3, 4):
    *   `i=1`: `b = 5 * 1 + 1 = 6`
    *   `i=2`: `b = 5 * 2 + 6 = 16`
    *   `i=3`: `b = 5 * 3 + 16 = 31`
    *   `i=4`: `b = 5 * 4 + 31 = 51`
5.  `func` 메소드는 `a + b` 를 반환. 즉, `5 + 51 = 56`.
6.  `main` 메소드의 지역 변수 `b`에 56이 저장됨.
7.  마지막 `print` 문은 `obj.a + b` 를 출력. `obj.a`는 여전히 5이고, `main`의 `b`는 56.
8.  따라서 `5 + 56 = 61` 출력.

결과는 **61** 이다.

---

**📌 이 문제 핵심 포인트 정리**

1.  **객체와 인스턴스 변수**: 객체(`obj`)가 생성된 후, 해당 객체의 인스턴스 변수(`obj.a`) 값은 변경될 수 있음. 메소드 호출 시점에는 변경된 최신 값이 사용됨.
2.  **생성자 vs. 직접 할당**: 생성자에서 초기화된 값(`new comp(3)`)이라도 이후에 객체 외부에서 직접 접근하여 값을 변경(`obj.a = 5;`)하면 그 값이 우선됨.
3.  **변수 스코프**: 클래스의 인스턴스 변수(`this.a` 또는 `obj.a`)와 메소드 내의 지역 변수(`func` 안의 `b`, `main` 안의 `b`)는 서로 다른 메모리 공간을 가짐. 이름이 같아도 구분해야 함.
4.  **메소드 실행 흐름**: 메소드가 호출될 때, 해당 객체의 현재 상태(인스턴스 변수 값)를 기반으로 코드가 실행됨. `for` 루프의 조건과 계산 과정을 정확히 따라가야 함.

---

### 문제 18

다음은 함수적 종속(Functional Dependency)에 대한 설명이다. 빈칸에 들어갈 알맞은 용어를 <보기>를 참조하여 작성하시오.

```
데이터베이스에서 함수적 종속은 어떤 속석(attribute)이 다른 속성에 종속되어 있을 때, 이를 나타내는 개념이다.
어떤 릴레이션 R이 있을 때 X와 Y를 각각 속성의 부분 집합이라고 가정한다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 한다. 이 경우 X를 결정자, Y를 종속자라고 하고, 이를 기호로 표현하면 X → Y로 표현할 수 있다.

다음과 같은 [학생] 테이블이 있다.

[학생]
| 이름 | 학과 | 학년 | 지도교수 | 지도교수실 |
| 이영진 | 컴퓨터 | 1 | 지창숙 | D301 |
| 김영진 | 정보보호 | 2 | 오진수 | D305 |
| 이기적 | 소프트웨어 | 3 | 이준형 | D204 |
| 이혜영 | 컴퓨터 | 2 | 지창숙 | D301 |
| 김지영 | 소프트웨어 | 4 | 이준형 | D204 |

[학생] 테이블에는 다음과 같은 함수적 종속 관계가 성립한다.
- (이름, 학과) → 학년
- 학과 → 지도교수
- 지도교수 → 지도교수실

[학생] 테이블에서 각 튜플을 유일하게 구분할 수 있는 최소한의 속성 집합이 (이름, 학과)이므로 기본키가 된다. 따라서 '(이름, 학과) → 학년'의 함수적 종속성은 기본키에 대하여 '학과'가 (1) Functional Dependency 된다고 볼 수 있다. 하지만 '학과 → 지도교수'의 함수적 종속은 기본키의 일부 속성으로 함수적 종속을 갖으므르 기본키에 대하여 (2) Functional Dependency 된다고 할 수 있다.

또한, 학과 → 지도교수의 함수적 종속과 지도교수 → 지도교수실과 같은 함수적 종속을 갖는 경우 학과 → 지도교수실도 종속이 성립하게 된다. 이와 같이 릴레이션에서 X, Y, Z라는 세 개의 속성이 있을 때 X→Y, Y→Z의 함수적 종속 관계가 있을 경우, X→Z가 성립되게 된다. 이러한 함수적 종속을 (3) Functional Dependency한다.
```
```
<보기>
Union, Transitive, Non Fully, Multi-Valued, Partial, Full, Normalization, Integrity
```

**답변:**

아 ㅋㅋ 함수적 종속성 문제네. 정규화 배울 때 나오는 그 개념 맞지? 빈칸 채워보자.

**[학생] 테이블 분석:**

*   **기본키**: (이름, 학과) - 이걸로 각 학생 행을 유일하게 식별 가능.
*   **주어진 함수 종속성**:
    *   (이름, 학과) → 학년 (기본키 전체가 학년을 결정)
    *   학과 → 지도교수 (기본키의 일부인 '학과'가 '지도교수'를 결정)
    *   지도교수 → 지도교수실 ('지도교수'가 '지도교수실'을 결정)

**빈칸 채우기:**

1.  **(1)** 부분: '(이름, 학과) → 학년' 설명 중. 여기서 종속자 '학년'은 기본키 (이름, 학과) **전체**에 의존하고 있음. 기본키의 일부에만 의존하는 게 아님. 이렇게 기본키 전체에 함수적으로 종속될 때 이걸 **완전 함수 종속 (Full Functional Dependency)** 이라고 함.
    *   <보기>에서 `Full` 찾으면 되겠네.
    *   (1)은 **Full**.

2.  **(2)** 부분: '학과 → 지도교수' 설명 중. 여기서 결정자 '학과'는 기본키 (이름, 학과)의 **일부분**임. 종속자 '지도교수'는 기본키 전체가 아니라 일부에만 의존하고 있음. 이렇게 기본키의 일부에 함수적으로 종속될 때 이걸 **부분 함수 종속 (Partial Functional Dependency)** 이라고 함.
    *   <보기>에서 `Partial` 찾으면 되겠네.
    *   (2)는 **Partial**.

3.  **(3)** 부분: '학과 → 지도교수' 이고 '지도교수 → 지도교수실' 일 때, '학과 → 지도교수실'도 성립하는 관계 설명 중. 즉, X→Y 이고 Y→Z 이면 X→Z 가 성립하는 거. A가 B를 결정하고 B가 C를 결정하면, A가 C를 결정하게 되는 이 관계. 이걸 **이행 함수 종속 (Transitive Functional Dependency)** 이라고 함.
    *   <보기>에서 `Transitive` 찾으면 되겠네.
    *   (3)은 **Transitive**.

**정리하면 답은:**

(1) : **Full**
(2) : **Partial**
(3) : **Transitive**

---

**📌 이 문제 핵심 포인트 정리**

1.  **함수 종속 (Functional Dependency, FD)**: 릴레이션 내에서 한 속성(또는 속성 집합) X의 값이 다른 속성(또는 속성 집합) Y의 값을 유일하게 결정할 때, Y는 X에 함수적으로 종속되었다고 함 (X → Y). X는 결정자, Y는 종속자.
2.  **완전 함수 종속 (Full Functional Dependency)**: 어떤 속성이 기본키 **전체**에 함수적으로 종속될 때. 기본키의 일부만으로는 종속되지 않아야 함. (주로 제2정규형(2NF) 관련)
3.  **부분 함수 종속 (Partial Functional Dependency)**: 어떤 속성이 기본키를 구성하는 **속성 중 일부**에만 함수적으로 종속될 때. (복합키일 때 발생 가능, 1NF는 만족하지만 2NF는 위반하는 원인)
4.  **이행 함수 종속 (Transitive Functional Dependency)**: X → Y 이고 Y → Z 라는 종속 관계가 있을 때, X → Z 가 성립하는 경우 (단, Y는 후보키가 아니어야 함). (2NF는 만족하지만 3NF는 위반하는 원인)
5.  **용어 구분**: 각 함수 종속의 정의와 해당 용어(<보기> 포함)를 정확히 매칭하는 것이 중요함.

---

### 문제 19

다음 (1), (2), (3)이 설명하는 용어를 <보기>를 참조하여 작성하시오

```
(1) : 인터넷 상에서 데이터를 주고받기 위한 통신 규약 중 하나로 클라이언트와 서버 간의 요청과 응답을 주고받는 프로토콜이다. 이를 통해 웹 브라우저에서 웹 페이지를 요청하고, 서버에는 해당 웹 페이지를 응답으로 전송하는 과정이 이루어진다.
(2) : 문서를 서로 연결하여 하이퍼링크를 만들어 연결하는 기술로 이를 통해 웹 페이지는 다양한 문서나 링크를 포함하여 보다 다양한 정보를 제공할 수 있다.
(3) : 웹 개발의 기본이 되는 언어 중 하나로 하이퍼링크를 구성하는 태그와 같은 방법으로 웹 페이지를 작성하는 마크업 언어이다. 웹 페이지를 구성하는 다양한 요소들을 정의하고, 서로 연결하는 등의 기능을 제공한다. 또한, CSS와 함께 사용되어 웹 페이지의 디자인과 레이아웃을 구성할 수 있다.
```
```
<보기>
jQuery, VBScript, Hypertext, HTML, Ajax, Spring, HTTP, SQL
```

**답변:**

아 ㅋㅋ 웹 기초 용어 문제네. 이건 뭐 거저주는 수준인데? 바로 간다.

**(1) 설명 분석:**

*   **인터넷 데이터 통신 규약**, **클라이언트-서버 요청/응답**, **웹 브라우저가 웹 페이지 요청/서버가 응답**. 이거 뭐냐? 웹 통신의 근본 아니냐 ㅋㅋㅋ **HTTP (HyperText Transfer Protocol)** 지 뭐긴 뭐야. 웹에서 클라이언트(브라우저)랑 서버가 서로 얘기할 때 쓰는 언어 같은 거임.
*   <보기>에 **HTTP** 있네. 겟챠.

**(2) 설명 분석:**

*   **문서 연결**, **하이퍼링크 생성**, **다양한 정보 연결**. 문서 안에 다른 문서로 점프하는 링크 넣는 그 기술 자체를 말하는 거네. 텍스트를 넘어서는 텍스트. 이게 바로 **Hypertext (하이퍼텍스트)** 개념이지.
*   <보기>에 **Hypertext** 있네. 겟챠.

**(3) 설명 분석:**

*   **웹 개발 기본 언어**, **하이퍼링크 구성 태그**, **마크업 언어**, **웹 페이지 요소 정의/연결**, **CSS랑 같이 씀**. ㅋㅋㅋㅋ 이거 모르면 웹 개발 접어야지. 웹 페이지 뼈대 만드는 언어, `<태그>` 쓰는 거. 이게 **HTML (HyperText Markup Language)** 아니냐.
*   <보기>에 **HTML** 있네. 겟챠.

**정리하면 답은 이거다:**

(1) : **HTTP**
(2) : **Hypertext**
(3) : **HTML**

---

**📌 이 문제 핵심 포인트 정리**

1.  **HTTP (HyperText Transfer Protocol)**: 웹에서 클라이언트와 서버 간에 정보를 주고받기 위한 **통신 규약(프로토콜)**. 요청(Request)과 응답(Response) 기반으로 동작함.
2.  **Hypertext**: 문서 내의 특정 단어(링크)를 통해 다른 문서나 정보로 즉시 이동할 수 있도록 하는 **개념 또는 기술**. 웹의 핵심 특징인 비순차적 정보 접근을 가능하게 함.
3.  **HTML (HyperText Markup Language)**: 웹 페이지의 구조와 내용을 정의하는 **마크업 언어**. 태그(`<>`)를 사용하여 제목, 문단, 이미지, 하이퍼링크 등 다양한 요소를 표현하고 웹 페이지의 뼈대를 만듦.
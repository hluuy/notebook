# 2023 기출 02회 해설

### 문제 1: C언어 배열 회전

> **문제:**
>
> 1. 다음 C언어 프로그램을 보기와 같은 입력과 출력이 되도록 빈칸에 들어갈 알맞은 코드를 작성하시오.
> ```c
> int main(){
>     int array[5];
>     for (int i = 0; i < 5; i++){
>         printf("숫자를 입력해주세요");
>         scanf("%d", &array[i]);
>     }
>     for  (int k = 0; k < 5; k++) {
>         printf("%d", ( 빈칸 ));
>     }
>     return 0;
> }
> ```
> ```
> 입력
> 숫자를 입력해주세요 : 1
> 숫자를 입력해주세요 : 2
> 숫자를 입력해주세요 : 3
> 숫자를 입력해주세요 : 4
> 숫자를 입력해주세요 : 5
>
> 출력
> 23451
>
> 입력
> 숫자를 입력해주세요 : 4
> 숫자를 입력해주세요 : 2
> 숫자를 입력해주세요 : 5
> 숫자를 입력해주세요 : 3
> 숫자를 입력해주세요 : 1
>
> 출력
> 25314
> ```

**해설:**

아 ㅋㅋ 이거 배열 문제네. 딱 보니까 입력받은 숫자들 순서를 살짝 꼬아서 출력하는 거잖슴?

일단 코드 까보자고.
1.  `int array[5];` : 정수 5개 들어가는 배열 하나 만들었네. ㅇㅋ
2.  첫 번째 `for`문 (`i` 가지고 도는거): `scanf`로 숫자 5개 받아서 `array[0]`부터 `array[4]`까지 차곡차곡 넣는 부분임. 이건 뭐 별거 없고.
3.  두 번째 `for`문 (`k` 가지고 도는거): 이게 핵심인데, 여기서 배열에 있는 값들을 출력하잖슴? `k`가 0부터 4까지 변하면서 총 5번 출력하는데, 출력 순서가 문제 예시 보니까 좀 특이함.

예시를 보면 `1 2 3 4 5` 넣으면 `2 3 4 5 1` 이 나옴.
`array[0]`에 1, `array[1]`에 2, ..., `array[4]`에 5가 들어갔을 텐데, 출력은 `array[1], array[2], array[3], array[4], array[0]` 순서로 했네. 한 칸씩 앞으로 땡기고 첫 번째 놈은 맨 뒤로 보낸 거지. 이걸 '왼쪽으로 한 칸 쉬프트(Shift)' 또는 '회전(Rotate)' 시켰다고 보면 됨.

자 그럼 `k`가 0, 1, 2, 3, 4 변할 때 우리가 원하는 배열 인덱스는 각각 1, 2, 3, 4, 0 이 되어야 함.
이걸 `k`를 이용해서 어떻게 만드냐?

`k`가 0일 때 -> 인덱스 1 필요 (`k+1`)
`k`가 1일 때 -> 인덱스 2 필요 (`k+1`)
`k`가 2일 때 -> 인덱스 3 필요 (`k+1`)
`k`가 3일 때 -> 인덱스 4 필요 (`k+1`)
`k`가 4일 때 -> 인덱스 0 필요 (`k+1` 하면 5 되니까 안됨)

이거 딱 보니 `%` (나머지 연산자) 쓰면 각 나오지 않냐? 배열 크기가 5니까 5로 나눈 나머지를 이용하는 거임.
`(k + 1) % 5` 이걸로 계산해보자.

`k=0` 이면 `(0 + 1) % 5 = 1 % 5 = 1`
`k=1` 이면 `(1 + 1) % 5 = 2 % 5 = 2`
`k=2` 이면 `(2 + 1) % 5 = 3 % 5 = 3`
`k=3` 이면 `(3 + 1) % 5 = 4 % 5 = 4`
`k=4` 이면 `(4 + 1) % 5 = 5 % 5 = 0`

오우 쉣 ㅋㅋ 딱 떨어지네. `k`가 0부터 4까지 변할 때 `(k + 1) % 5` 는 정확히 1, 2, 3, 4, 0 순서로 인덱스를 만들어줌.

그러니까 빈칸에는 `array`에서 이 인덱스에 해당하는 값을 가져오도록 `array[(k + 1) % 5]` 이걸 써주면 되는 거임.

**답:** `array[(k + 1) % 5]`

---

**주요 포인트 정리**

*   **배열 인덱싱**: `배열이름[인덱스]` 이걸로 값 빼옴. 인덱스 0부터 시작하는 거 잊지 마라.
*   **순환 접근**: 배열 끝에서 처음으로 뺑뺑이 돌릴 때는 `%` (모듈러 연산자) 쓰면 편하다. `(현재_인덱스 + 이동칸수) % 배열크기` 공식 기억해두셈.
*   **For 루프와 인덱스**: `for`문 돌 때 루프 변수 (`k` 같은 거) 잘 써서 필요한 인덱스 만들어내는 게 실력임.

---

### 문제 2: Java 거스름돈 계산

> **문제:**
>
> 2. 다음 Java 프로그램은 4620원을 1000원, 500원, 100원, 10원 지폐와 동전으로 나누는 프로그램이다. (1), (2), (3), (4)에 들어갈 코드를 <보기>를 참고하여 작성하시오.
> ```java
> public class YoungJin {
>     public static void main(String[] args) throws Exception {
>         int m = 4620;
>
>         int a = ( 1 ); // 천원짜리 4장 출력
>         int b = ( 2 ); // 오백원짜리 1개 출력
>         int c = ( 3 ); // 백원짜리 1개 출력
>         int d = ( 4 ); // 십원짜리 2개 출력
>
>         System.out.println(a);
>         System.out.println(b);
>         System.out.println(c);
>         System.out.println(d);
>     }
> }
> ```
> ```
> <보기>
> 변수 : m
> 연산자 : % /
> 괄호 : ()
> ```

**해설:**

아 ㅋㅋ 돈 계산 문제네. 4620원을 천원, 오백원, 백원, 십원짜리로 바꾸는 거잖슴? 이거 완전 거스름돈 계산이랑 똑같음. 큰 단위부터 차례대로 얼마나 들어가는지 보고, 남은 돈으로 다음 단위 계산하고. 이걸 반복하면 됨.

자, 하나씩 까보자고. `m = 4620` 이야.

1.  **(1) 천원짜리 계산 (`a`)**:
    *   4620원에 천원짜리가 몇 장 들어감? 4장이지.
    *   이걸 계산하려면 나누면 됨. `4620 / 1000 = 4`. 정수 나누기니까 소수점 버려짐.
    *   그러니까 (1)에는 `m / 1000` 이게 들어가야 함.
    *   `a` 값은 4가 되고, 출력 확인하면 `// 천원짜리 4장 출력` 맞네.

2.  **(2) 오백원짜리 계산 (`b`)**:
    *   천원짜리 4장 빼면 얼마 남음? `4620 - (4 * 1000) = 620`원 남음.
    *   이 620원을 계산해야 하는데, 이걸 `m`으로 표현하면 `4620 % 1000` (4620을 1000으로 나눈 나머지) 하면 딱 620이 나옴.
    *   이제 이 남은 돈 `620`원에서 오백원짜리가 몇 개 들어감? 1개지.
    *   계산은 `620 / 500 = 1`.
    *   그러니까 (2)에는 남은 돈 (`m % 1000`)에서 500으로 나눈 몫 `(m % 1000) / 500` 이게 들어가야 함. 괄호 꼭 쳐줘야 `%` 먼저 계산됨.
    *   `b` 값은 1이 되고, 출력 확인하면 `// 오백원짜리 1개 출력` 맞네.

3.  **(3) 백원짜리 계산 (`c`)**:
    *   자, 오백원짜리 1개 빼면 또 얼마 남음? `620 - (1 * 500) = 120`원 남음.
    *   이 120원을 계산해야 하는데, 이걸 `m`으로 표현하면... 아까 남은 돈이 620 (`m % 1000`) 이었잖아? 여기서 500으로 나눈 나머지를 구하면 됨. `620 % 500 = 120`. 즉 `(m % 1000) % 500` 이게 120임.
    *   *잠깐!* 더 쉬운 방법 없나? `m % 500` 해볼까? `4620 % 500` 하면 `4500` 빼고 나머지 `120` 나오네? 오 개꿀. 이걸로 하자. 왜냐면 1000원은 500원의 배수니까, 500원으로 나눈 나머지만 알면 그 안에 천원짜리 계산은 자동으로 고려된 거임.
    *   이제 이 남은 돈 `120`원에서 백원짜리가 몇 개 들어감? 1개지.
    *   계산은 `120 / 100 = 1`.
    *   그러니까 (3)에는 남은 돈 (`m % 500`)에서 100으로 나눈 몫 `(m % 500) / 100` 이게 들어가야 함.
    *   `c` 값은 1이 되고, 출력 확인하면 `// 백원짜리 1개 출력` 맞네.

4.  **(4) 십원짜리 계산 (`d`)**:
    *   자, 백원짜리 1개 빼면 또 얼마 남음? `120 - (1 * 100) = 20`원 남음.
    *   이 20원을 계산해야 하는데, `m`으로 표현하면... 아까 남은 돈이 120 (`m % 500`) 이었지? 여기서 100으로 나눈 나머지를 구하면 됨. `120 % 100 = 20`. 즉 `(m % 500) % 100` 이게 20임.
    *   *또 잠깐!* 더 쉬운 방법? `m % 100` 해볼까? `4620 % 100` 하면 `4600` 빼고 나머지 `20` 나오네? 이것도 개꿀. 1000원, 500원 다 100원의 배수니까, 100원으로 나눈 나머지만 알면 그 앞 단위 계산은 자동으로 고려된 거임.
    *   이제 이 남은 돈 `20`원에서 십원짜리가 몇 개 들어감? 2개지.
    *   계산은 `20 / 10 = 2`.
    *   그러니까 (4)에는 남은 돈 (`m % 100`)에서 10으로 나눈 몫 `(m % 100) / 10` 이게 들어가야 함.
    *   `d` 값은 2가 되고, 출력 확인하면 `// 십원짜리 2개 출력` 맞네.

**답:**

*   (1) : `m / 1000`
*   (2) : `(m % 1000) / 500`
*   (3) : `(m % 500) / 100`
*   (4) : `(m % 100) / 10`

---

**주요 포인트 정리**

*   **정수 나눗셈 (`/`)**: 몫 구할 때 씀. 소수점 버리는 거 알지?
*   **나머지 연산 (`%`)**: 다음 계산할 돈 구할 때 필수.
*   **탐욕법 (Greedy)**: 큰 단위부터 처리하는 방식. 거스름돈 단골임.
*   **괄호**: 연산 순서 헷갈리면 걍 괄호 쳐라. 안전빵임. 특히 `%` 하고 `/` 할 땐 필수.

---

### 문제 3: C언어 전역 변수와 포인터

> **문제:**
>
> 3. 다음 C언어 프로그램의 입력값이 홍길동, 김영진, 이기적의 순서일 때, 출력되는 값을 작성하시오.
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> char n[30];
> char *test(){
>     printf("이름을 입력하세요:");
>     gets(n);
>     return n;
> }
> int main(){
>     char* test1;
>     char* test2;
>     char* test3;
>
>     test1 = test();
>     test2 = test();
>     test3 = test();
>
>     printf("%s\n", test1);
>     printf("%s\n", test2);
>     printf("%s", test3);
> }
> ```

**해설:**

아 ㅋㅋ 이거 포인터랑 전역 변수 엮인 문제네. 좀 킹받을 수 있음. 잘 따라와 봐.

코드 분석 드간다.

1.  `char n[30];`: 이거 전역 변수임. 프로그램 시작할 때 만들어져서 끝날 때까지 살아있고, 어느 함수에서든 접근 가능함. 크기는 30칸짜리 문자 배열.
2.  `char *test()`: 함수인데, 문자열 포인터(`char *`)를 반환함.
    *   `printf("이름을 입력하세요:");`: 걍 출력문.
    *   `gets(n);`: 키보드로 입력받은 문자열을 **전역 변수 `n`**에 저장함. `gets`는 입력 길이를 체크 안 해서 위험한 함수긴 한데, 여기선 일단 넘어감. 중요한 건 호출될 때마다 **같은 `n` 배열에 덮어쓴다는** 거.
    *   `return n;`: **전역 변수 `n`의 시작 주소**를 반환함. 중요! 데이터 자체가 아니라 주소를 넘기는 거임. `n`은 딱 하나니까 이 주소는 항상 같음.
3.  `int main()`: 메인 함수.
    *   `char* test1; char* test2; char* test3;`: 문자열 포인터 변수 3개 선언. 얘네들은 주소를 저장할 공간임.
    *   `test1 = test();`:
        *   `test()` 호출됨. "이름을 입력하세요:" 출력.
        *   "홍길동" 입력하면, **전역 변수 `n`에 "홍길동"이 저장됨.**
        *   `test()` 함수는 `n`의 주소를 반환하고, 이 **같은 주소**가 `test1`에 저장됨.
    *   `test2 = test();`:
        *   `test()` 함수 또 호출됨. "이름을 입력하세요:" 출력.
        *   "김영진" 입력하면, **아까 그 전역 변수 `n`에 "김영진"이 덮어쓰기 됨.** (핵심!)
        *   `test()` 함수는 `n`의 주소 (아까랑 똑같은 주소)를 반환하고, 이 주소가 `test2`에 저장됨. 이제 `test1`이랑 `test2` 둘 다 같은 곳을 가리키고, 그곳 내용은 "김영진"임.
    *   `test3 = test();`:
        *   `test()` 함수 세 번째 호출. "이름을 입력하세요:" 출력.
        *   "이기적" 입력하면, **또 그 전역 변수 `n`에 "이기적"이 덮어쓰기 됨.**
        *   `test()` 함수는 `n`의 주소 (계속 똑같은 주소)를 반환하고, 이 주소가 `test3`에 저장됨. 이제 `test1`, `test2`, `test3` 전부 같은 곳을 가리키고, 그곳 내용은 "이기적"임.
    *   `printf("%s\n", test1);`: `test1`이 가리키는 주소(`n`의 주소)에 있는 문자열을 출력함. 현재 `n`에는 "이기적"이 들어있으므로 "이기적" 출력 + 줄바꿈.
    *   `printf("%s\n", test2);`: `test2`가 가리키는 주소(`n`의 주소)에 있는 문자열을 출력함. 현재 `n`에는 "이기적"이 들어있으므로 "이기적" 출력 + 줄바꿈.
    *   `printf("%s", test3);`: `test3`가 가리키는 주소(`n`의 주소)에 있는 문자열을 출력함. 현재 `n`에는 "이기적"이 들어있으므로 "이기적" 출력.

결론적으로 `test1`, `test2`, `test3` 전부 다 **똑같은 전역 변수 `n`의 주소**를 가지고 있고, `n`의 내용은 마지막에 입력된 "이기적"으로 덮어쓰기 되었기 때문에 세 번 다 "이기적"이 출력되는 거임.

**답:**

```
이기적
이기적
이기적
```

---

**주요 포인트 정리**

*   **전역 변수 (Global Variable):** 프로그램 전체에서 접근 가능하고 딱 하나만 존재함. 함수 호출 시 값이 계속 유지되지만, 다른 함수에서 **덮어쓰기** 될 수 있다는 점이 핵심. 여기선 `n`이 전역 변수임.
*   **포인터와 주소:** 함수가 변수 자체가 아니라 변수의 **주소**를 반환할 수 있음. `test()` 함수는 전역 변수 `n`의 주소를 반환함. `test1`, `test2`, `test3`는 모두 이 **동일한 주소**를 저장하게 됨.
*   **`gets()` 함수의 동작 (및 위험성):** `gets()`는 입력을 받아서 지정된 버퍼(여기선 `n`)에 저장하는데, 버퍼 크기를 신경 안 쓰고 막 저장해서 위험함. 중요한 건 여기서는 호출될 때마다 **같은 버퍼 `n`에 내용을 덮어쓴다는 것.** (안전하게 하려면 `fgets` 쓰는 게 좋음)
*   **`printf("%s", 포인터)`:** 해당 포인터가 가리키는 주소부터 시작해서 널 문자(`\0`) 만날 때까지의 문자열을 출력함. 모든 포인터(`test1`, `test2`, `test3`)가 마지막 상태의 `n`("이기적")을 가리키므로 같은 결과가 나옴.

---

### 문제 4: SQL INSERT 문 작성

> **문제:**
>
> 4. 다음의 입력 필드와 값을 보고 [STUDENT] 테이블에 데이터를 삽입하기 위한 INSERT문을 작성하시오.
>
> ```
> |학번(int)|이름(char(10))|학년(int)|전공(char(20))|전화번호(char(13))|
> |123456|이영진|4|컴퓨터|010-1234-5678|
> ```

**해설:**

아 ㅋㅋ SQL 문제네. 테이블에 데이터 때려 박는 거잖슴? `INSERT` 문 쓰면 됨. 간단함.

표 보니까 `STUDENT` 테이블이고, 컬럼은 `학번`, `이름`, `학년`, `전공`, `전화번호` 이렇게 5개임. 넣어야 할 데이터는 `123456`, `이영진`, `4`, `컴퓨터`, `010-1234-5678` 이고.

`INSERT` 문 기본 구조는 이거임:
`INSERT INTO 테이블이름 (컬럼1, 컬럼2, ...) VALUES (값1, 값2, ...);`

자 이제 이걸로 조립해보자고.

1.  **`INSERT INTO STUDENT`**: `STUDENT` 테이블에 넣을 거니까 이렇게 시작.
2.  **`(학번, 이름, 학년, 전공, 전화번호)`**: 어떤 컬럼에 넣을 건지 순서대로 쭉 써줌. 컬럼명 틀리면 에러 나니까 조심.
3.  **`VALUES`**: 이제 실제 값을 넣을 차례.
4.  **`(123456, '이영진', 4, '컴퓨터', '010-1234-5678')`**: 컬럼 순서에 맞게 값을 넣어줌. 여기서 중요한 거!
    *   숫자(int) 타입인 `학번(123456)`이랑 `학년(4)`은 그냥 숫자만 쓰면 됨.
    *   문자열(char) 타입인 `이름('이영진')`, `전공('컴퓨터')`, `전화번호('010-1234-5678')`는 **작은따옴표(`'`)**로 감싸줘야 함. 이거 안 하면 에러남 ㅅㄱ. 전화번호도 숫자처럼 보여도 타입이 char면 따옴표 필수임.

다 합치면 이렇게 됨.

**답:**

```sql
INSERT INTO STUDENT (학번, 이름, 학년, 전공, 전화번호)
VALUES (123456, '이영진', 4, '컴퓨터', '010-1234-5678');
```

---

**주요 포인트 정리**

*   **`INSERT INTO` 문법**: 테이블에 새 데이터를 추가할 때 쓰는 기본 SQL 명령어. `INSERT INTO 테이블명 (컬럼 목록) VALUES (값 목록);` 형태를 기억해야 함.
*   **컬럼 목록과 값 목록 순서 매칭**: `(컬럼 목록)`에 적은 순서랑 `VALUES (값 목록)`에 적는 값 순서가 정확히 일치해야 데이터가 제대로 들어감.
*   **데이터 타입과 값 표기**:
    *   **숫자(INT, NUMBER 등):** 따옴표 없이 숫자만 쓴다. (예: `123456`, `4`)
    *   **문자열(CHAR, VARCHAR2, VARCHAR 등):** **작은따옴표(`'`)**로 반드시 감싸준다. (예: `'이영진'`, `'컴퓨터'`, `'010-1234-5678'`) 전화번호처럼 숫자만 있어도 데이터 타입이 문자열이면 따옴표 필수!
    *   **날짜(DATE, TIMESTAMP 등):** DBMS마다 좀 다르지만 보통 작은따옴표로 감싸고 정해진 형식(예: `'YYYY-MM-DD'`)으로 쓴다. (이 문제엔 없음)
*   **세미콜론 (`;`)**: SQL 문장의 끝을 나타냄. 쿼리 툴에 따라 필수는 아니지만, 여러 문장 쓸 때는 구분용으로 꼭 필요하고 쓰는 게 정석임.

---

### 문제 5: C언어 switch문과 fall-through

> **문제:**
>
> 5. 다음 C언어 프로그램의 출력 결과를 작성하시오.
> ```c
> #include <stdio.h>
> int main(void){
>     int array[3] = {70, 85, 98};
>     int sum = 0;
>
>     for (int i = 0; i < 3; i++){
>         sum += array[i];
>     }
>
>     switch(sum/30){
>         case 10:
>         case 9: printf("A");
>         case 8: printf("B");
>         case 7:
>         case 6: printf("C");
>         default: printf("D");
>     }
> }
> ```

**해설:**

아 ㅋㅋ 이거 C언어 평균내고 등급 매기는 뭐 그런 거네? 코드 까보자고.

1.  `int array[3] = {70, 85, 98};`: 정수 3개짜리 배열 만들고 70, 85, 98 초기값으로 때려넣음.
    *   `array[0] = 70`
    *   `array[1] = 85`
    *   `array[2] = 98`
2.  `int sum = 0;`: 합계 저장할 변수 `sum` 만들고 0으로 시작.
3.  `for (int i = 0; i < 3; i++){ sum += array[i]; }`: `for`문 돌면서 배열 값들 다 더해줌.
    *   `i=0`: `sum = 0 + array[0] = 0 + 70 = 70`
    *   `i=1`: `sum = 70 + array[1] = 70 + 85 = 155`
    *   `i=2`: `sum = 155 + array[2] = 155 + 98 = 253`
    *   루프 끝나면 `sum`은 253이 됨.
4.  `switch(sum/30)`: 이게 핵심이네. `switch`문인데, 조건식이 `sum / 30` 임.
    *   `sum`이 253이니까 `253 / 30` 계산해야 함. C언어에서 정수 나누기 정수는 결과도 정수임. 소수점 버려짐.
    *   `253 / 30 = 8.433...` 인데, 정수 부분만 따면 `8` 이 됨.
    *   결국 `switch(8)` 이랑 똑같은 거임.
5.  `switch` 내부 동작:
    *   `case 10:`, `case 9:` : 8이랑 안 맞으니 패스.
    *   `case 8:` : 오 여기 걸렸네! `printf("B");` 실행해서 "B" 출력.
    *   **어? 근데 `case 8:` 뒤에 `break;`가 없네?** 이러면 밑으로 줄줄 흘러내림. 이걸 'fall-through' 라고 함 ㅋㅋ
    *   `case 7:`, `case 6:` : 여기도 `break` 없으니까 그냥 통과해서 다음 `printf`로 감.
    *   `printf("C");` 실행해서 "C" 출력.
    *   **여기도 `break;`가 없음.** 또 흘러내림.
    *   `default:` : `break` 없으면 `default`까지 흘러내림.
    *   `printf("D");` 실행해서 "D" 출력.
    *   이제 `switch` 문 끝남.

결과적으로 출력된 문자들을 순서대로 합치면 됨. "B" 찍고, "C" 찍고, "D" 찍었으니까...

**답:**

```
BCD
```

---

**주요 포인트 정리**

*   **배열 합계 계산**: `for`문을 이용해서 배열의 모든 요소를 순회하며 합계를 구하는 건 기본 중의 기본임. `sum += array[i]` 표현 익숙해져야 함.
*   **정수 나눗셈**: C언어에서 정수끼리 나누면 결과도 정수다. 소수점 이하는 그냥 버려짐 (`253 / 30` 결과는 `8`).
*   **`switch` 문**: 특정 값에 따라 다른 코드를 실행시킬 때 사용함. `switch(값)` 형태로 쓰고, `case 상수:` 와 매칭되는 부분을 찾아서 실행함.
*   **`break` 문의 중요성 (Fall-through)**: `switch`문에서 각 `case` 블록 끝에 `break;`를 안 쓰면, 해당 `case` 실행 후에 멈추지 않고 **아래에 있는 다음 `case` (또는 `default`) 코드를 연달아 실행**해버림. 이걸 'fall-through'라고 하는데, 의도한 게 아니면 버그의 원인이 되니까 조심해야 함. 이 문제의 핵심 함정임.
*   **`default`**: `switch`문의 `case` 중에 일치하는 값이 없을 때 실행되는 부분. `break` 없이 흘러 내려오면 `default`도 실행될 수 있음.

---

### 문제 6: 테스트 커버리지 종류

> **문제:**
>
> 6. 다음의 테스트 커버리지를 무엇이라 하는지 <보기>를 참고하여 작성하시오.
> ```
> - 전체 조건식의 결과와 관계없이 각 개별 조건식이 참 한 번, 거짓 한  번을 모두 갖도록 조합하는 것
> - 결정 커버리지보다 강력한 형태의 커버리지
> ```
> ```
> <보기>
> Statement Coverage, Decision Coverage, Condition Coverage, Condition/Decision Coverage, Modify Condition/Decision Coverage, Multiple Condition Coverage
> ```

**해설:**

아 ㅋㅋ 이거 테스트 커버리지 종류 맞추는 거네. 은근 헷갈림.

설명 까보자고.

*   "전체 조건식의 결과와 관계없이 각 개별 조건식이 참 한 번, 거짓 한 번을 모두 갖도록 조합하는 것"
    *   이게 핵심임. `if (a > 10 && b < 5)` 이런 조건문이 있으면, `&&`나 `||` 같은 걸로 묶인 **개별 조건식** 있잖아? (`a > 10` 이랑 `b < 5`). 얘네들이 각각 `true`일 때랑 `false`일 때가 **최소 한 번씩**은 테스트 케이스에 포함되도록 하라는 거임. 전체 `if`문 결과가 최종적으로 `true`가 되든 `false`가 되든 그건 일단 나중 문제고, **각 부품(개별 조건)이 참/거짓 다 겪어봤냐** 이게 중요함.

*   "결정 커버리지보다 강력한 형태의 커버리지"
    *   결정 커버리지(Decision Coverage)는 전체 조건식의 최종 결과가 `true`인 경우, `false`인 경우만 테스트하면 끝임. 근데 위에 설명한 방식은 그 안의 개별 조건까지 따지니까 당연히 더 빡셈. 테스트 케이스가 더 필요할 수도 있고.

자, <보기> 중에서 이거 설명하는 게 뭐냐?

*   Statement Coverage (구문 커버리지): 코드 한 줄 한 줄 실행했냐? (땡)
*   Decision Coverage (결정 커버리지): 전체 조건식 True/False 결과 봤냐? (이거보다 쎄다며)
*   **Condition Coverage (조건 커버리지):** 딱 이거네! 개별 조건식이 True/False 한 번씩 다 겪어봤냐? 이거잖슴.
*   Condition/Decision Coverage (조건/결정 커버리지): 조건 커버리지 + 결정 커버리지 둘 다 만족. (더 쎈 놈)
*   Modify Condition/Decision Coverage (변경 조건/결정 커버리지): 각 개별 조건식이 전체 결과에 독립적으로 영향 미치는지 보는 더 쎈 놈. (더더 쎈 놈)
*   Multiple Condition Coverage (다중 조건 커버리지): 개별 조건식의 모든 가능한 True/False 조합 다 해보는 끝판왕. (젤 쎈 놈)

설명에 딱 맞는 건 **조건 커버리지 (Condition Coverage)** 임.

**답:** Condition Coverage (조건 커버리지)

---

**주요 포인트 정리**

*   **테스트 커버리지**: 소프트웨어 테스트가 소스 코드의 어느 부분을 얼마나 커버했는지(테스트했는지) 측정하는 지표임. 종류가 여러 개 있음.
*   **조건 커버리지 (Condition Coverage)**: 조건문 안에 있는 **각각의 개별 조건식**(예: `a > 10`, `b < 5`)이 **최소 한 번은 참(True)**, **최소 한 번은 거짓(False)** 값을 갖도록 테스트 케이스를 작성하는 기준임. 전체 조건문의 결과보다는 개별 조건식의 평가 결과에 초점을 맞춤.
*   **결정 커버리지와의 비교**: 결정 커버리지는 전체 조건식의 최종 결과(참/거짓)만 신경 쓰지만, 조건 커버리지는 내부의 개별 조건식 결과까지 따지므로 일반적으로 결정 커버리지보다 더 높은 수준의 커버리지로 간주됨 (하지만 서로 포함 관계는 아님. 조건 커버리지만 만족하고 결정 커버리지는 만족 못 하는 경우도 있음).
*   **커버리지 강도**: 일반적으로 구문 < 결정 < 조건 < 조건/결정 < 변경 조건/결정 < 다중 조건 순서로 커버리지 수준이 높아짐 (더 빡세짐).

---

### 문제 7: C언어 4의 배수 개수 세기

> **문제:**
>
> 7. 다음 C언어 프로그램의 출력 결과를 작성하시오.
> ```c
> #include <stdio.h>
> int main() {
>     int s= 0;
>     for(int i = 1; i <= 2023; i++){
>         if(i % 4 == 0) s++;
>     }
>     printf("%d", s);
> }
> ```

**해설:**

아 ㅋㅋ 이거 또 C언어 코드 돌리는 거네. 간단하구만.

코드 까보자고.

1.  `int s = 0;`: `s`라는 정수 변수 만들고 0 박아둠. 얘가 카운터 역할을 할 거임.
2.  `for(int i = 1; i <= 2023; i++)`: `i`를 1부터 2023까지 1씩 늘리면서 뺑뺑이 돌림.
3.  `if(i % 4 == 0) s++;`: 이게 핵심인데, `i`를 4로 나눴을 때 나머지가 0이면 (즉, `i`가 4의 배수면) `s` 값을 1 증가시킴.
4.  `printf("%d", s);`: `for`문 다 돌고 나서 최종 `s` 값을 출력함.

결국 이 코드는 **1부터 2023까지의 자연수 중에서 4의 배수가 총 몇 개인지** 세는 거임.

이거 일일이 세고 있으면 흑우지 ㅋㅋ 그냥 2023을 4로 나눠서 몫을 구하면 됨. 왜냐면 1부터 N까지 K의 배수 개수는 `N / K`의 몫이랑 같거든.

`2023 / 4` 계산해보자.
`2023 / 4 = 505.75`

정수 나눗셈이니까 소수점 이하는 버린다. 그럼 몫은 **505**.

따라서 `for`문이 끝나면 `s`에는 505가 저장되어 있을 거임. 그걸 출력하니까 답은 505.

**답:**

```
505
```

---

**주요 포인트 정리**

*   **`for` 반복문**: 특정 횟수나 범위만큼 코드를 반복 실행할 때 씀. 여기선 1부터 2023까지 숫자를 순회함.
*   **`%` (모듈러, 나머지 연산자)**: 나머지를 구하는 연산자. 배수 판별에 아주 유용함. `if (i % 4 == 0)`은 "i가 4의 배수인가?"를 묻는 거임.
*   **카운터 변수**: 특정 조건이 만족될 때마다 횟수를 세기 위해 사용하는 변수. 여기선 `s`가 4의 배수가 나올 때마다 1씩 증가함.
*   **범위 내 배수 개수 구하기**: 1부터 N까지의 자연수 중 K의 배수의 개수는 N을 K로 나눈 몫 (정수 나눗셈 결과)과 같다는 걸 알면 계산이 편함. (`2023 / 4`의 몫 = 505)

---

### 문제 8: 보안 용어 - 탬퍼프루핑

> **문제:**
>
> 8. 다음이 설명하는 용어를 작성하시오
> ```
> 소프트웨어 또는 하드웨어를 외부에서의 공격이나 변경으로부터 보호하는 보안 기술 중 하나로 시스템이나 애플리케이션의 무결성을 유지하고, 외부 공격자로부터 시스템을 안전하게 보호하는 목적으로 사용된다. 특히, 보안에 중요한 역할을 하는 특정 부분이나 기능이 공격자에 의해 변경되거나 손상되는 것을 방지한다.
> ```

**해설:**

아 ㅋㅋ 이거 보안 용어 문제네. 설명 보니까 딱 감이 오는데?

*   외부 공격이나 **변경**으로부터 **보호**하는 기술
*   **무결성**(Integrity) 유지 (즉, 함부로 못 고치게 막는 거)
*   외부 공격자로부터 **안전하게 보호**
*   중요한 부분이나 기능이 **변경되거나 손상되는 것을 방지**

핵심은 **"변경 방지", "손상 방지", "함부로 못 건드리게 막는 거"** 이거임. 뭔가 봉인씰 붙여놓거나, 건드리면 티 나게 하거나, 아예 못 건드리게 딱딱하게 굳혀놓는 그런 느낌?

이걸 전문용어로 **탬퍼프루핑 (Tamper Proofing)** 이라고 함. 'Tamper'가 '간섭하다, 함부로 변경하다' 이런 뜻이고, 'Proofing'은 '막는다, 방지한다' 이런 뜻이니까 합치면 딱 저 설명임.

예를 들어서 약병 같은 거 보면 뚜껑 처음 열 때 씰 뜯어야 하잖아? 이것도 물리적인 탬퍼프루핑임. 소프트웨어도 마찬가지로 중요한 코드나 데이터를 함부로 못 바꾸게 막는 기술들을 통틀어서 탬퍼프루핑이라고 부름.

**답:** 탬퍼프루핑 (Tamper Proofing)

---

**주요 포인트 정리**

*   **탬퍼프루핑 (Tamper Proofing) 정의**: 허가되지 않은 사용자가 시스템, 장치, 데이터 등을 **임의로 변경하거나 손상시키는 것을 방지**하는 보안 기술임.
*   **핵심 목적**: **무결성(Integrity)** 보장. 즉, 원래 상태 그대로 유지되도록 보호하는 것이 주 목적.
*   **보호 대상**: 소프트웨어 코드, 하드웨어 구성, 중요한 데이터, 설정 파일 등 변경되면 안 되는 모든 것.
*   **방법**: 암호화, 코드 난독화, 실행 환경 감시, 물리적 봉인 등 다양한 기술이 사용될 수 있음. (이 문제에서는 구체적인 방법까진 몰라도 됨)
*   **키워드**: **변경 방지, 손상 방지, 무결성 유지, 보호**

---

### 문제 9: C언어 스택 구현 및 실행 추적

> **문제:**
>
> 9. 다음 C언어 프로그램의 출력 결과를 작성하시오.
> ```c
> #include <stdio.h>
> #define MAX_SIZE 10
>
> void into(int num);
> int take();
> int isEmpty();
> int isFull();
>
> int isWhat[MAX_SIZE];
> int point = -1;
>
> void into(int num){
>     if(isFull() == 1){
>         printf("Full");
>     } else {
>         isWhat[++point] = num;
>     }
> }
>
> int take(){
>     if(isEmpty() == 1){
>         printf("Empty");
>         return -1;
>     } else {
>         return isWhat[point--];
>     }
> }
>
> int isEmpty(){
>     if(point == -1){
>         return 1;
>     } else {
>         return 0;
>     }
> }
> int isFull(){
>     if(point == MAX_SIZE - 1){
>         return 1;
>     } else {
>         return 0;
>     }
> }
>
> int main(){
>     int e;
>     into(5);
>         into(2);
>         while(!isEmpty()){
>             printf("%d", take());
>             into(4);
>                 into(1);
>                 printf("%d", take());
>             into(3);
>                 printf("%d", take());
>                 printf("%d", take());
>             into(6);
>                 printf("%d", take());
>                 printf("%d", take());
>         }
>         return 0;
> }
> ```

**해설:**

아 ㅋㅋ 이거 스택(Stack) 문제네. 코드가 좀 길어 보이지만, 정신 똑바로 차리고 스택 동작만 따라가면 됨.

1.  **전역 변수**:
    *   `int isWhat[MAX_SIZE];`: 크기 10짜리 배열. 이게 스택의 저장 공간임. (`MAX_SIZE`가 10이니까)
    *   `int point = -1;`: 스택의 꼭대기(top)를 가리키는 인덱스. `-1`은 스택이 비어있다는 뜻.
2.  **함수들**:
    *   `into(int num)`: 스택에 데이터를 넣는 함수 (Push 역할).
        *   `isFull()` 체크해서 꽉 찼으면 "Full" 출력.
        *   아니면 `point`를 1 증가시키고 (`++point`, 전위 증가) 그 자리에 `num` 저장.
    *   `take()`: 스택에서 데이터를 빼는 함수 (Pop 역할).
        *   `isEmpty()` 체크해서 비었으면 "Empty" 출력하고 -1 리턴.
        *   아니면 현재 `point` 위치의 값을 리턴하고, 그 *다음에* `point`를 1 감소시킴 (`point--`, 후위 감소). **LIFO(Last-In, First-Out)** 구조임.
    *   `isEmpty()`: `point`가 -1이면 1(true), 아니면 0(false) 리턴.
    *   `isFull()`: `point`가 `MAX_SIZE - 1` (즉, 9)이면 1(true), 아니면 0(false) 리턴.
3.  **`main()` 함수 실행 흐름**: 스택 상태랑 `point` 값 추적하면서 따라가 보자.

    *   `int e;` : 변수 선언 (안 쓰임).
    *   `into(5);` : `point`=0, `isWhat[0]=5`. 스택: `[5]`
    *   `into(2);` : `point`=1, `isWhat[1]=2`. 스택: `[5, 2]`
    *   `while(!isEmpty())`: `point`가 -1이 아니면 계속 반복. 현재 `point`=1 이므로 루프 시작.
        *   **Loop 1:**
            *   `printf("%d", take());`: `take()` 호출. `isWhat[1]`(값 2) 리턴하고 `point`는 0됨. **`2`** 출력. 스택: `[5]`
            *   `into(4);`: `point`=1, `isWhat[1]=4`. 스택: `[5, 4]`
            *   `into(1);`: `point`=2, `isWhat[2]=1`. 스택: `[5, 4, 1]`
            *   `printf("%d", take());`: `take()` 호출. `isWhat[2]`(값 1) 리턴하고 `point`는 1됨. **`1`** 출력. 스택: `[5, 4]`
            *   `into(3);`: `point`=2, `isWhat[2]=3`. 스택: `[5, 4, 3]`
            *   `printf("%d", take());`: `take()` 호출. `isWhat[2]`(값 3) 리턴하고 `point`는 1됨. **`3`** 출력. 스택: `[5, 4]`
            *   `printf("%d", take());`: `take()` 호출. `isWhat[1]`(값 4) 리턴하고 `point`는 0됨. **`4`** 출력. 스택: `[5]`
            *   `into(6);`: `point`=1, `isWhat[1]=6`. 스택: `[5, 6]`
            *   `printf("%d", take());`: `take()` 호출. `isWhat[1]`(값 6) 리턴하고 `point`는 0됨. **`6`** 출력. 스택: `[5]`
            *   `printf("%d", take());`: `take()` 호출. `isWhat[0]`(값 5) 리턴하고 `point`는 -1됨. **`5`** 출력. 스택: `[]` (비었음)
        *   루프 조건 검사: `!isEmpty()` -> `isEmpty()`가 1(true) 반환 -> `!1`은 0(false) -> 루프 종료.
    *   `return 0;`: 프로그램 끝.

자, 이제 출력된 숫자들을 순서대로 쫙 모아보면 됨.

**답:**

```
213465
```

---

> **추가 질문:**
>
> 해당 문제를 봤을 때 스택 문제인 걸 알아채려면 어떻게 해야해?

**추가 설명:**

아 ㅋㅋ 스택인 거 어케 아냐고? 몇 가지 빼박 냄새나는 포인트들이 있음.

1.  **`point` 변수랑 배열 조합:** `int isWhat[MAX_SIZE];` 이런 배열이랑 `int point = -1;` 같이 인덱스 관리하는 변수가 같이 나온다? 이거 거의 스택이나 큐 구현할 때 국룰임. 특히 `point`가 `-1`로 시작하는 건 '비어있다'는 상태 나타내는 스택의 단골 초기값임.

2.  **데이터 넣는 함수 (`into`) 동작:** 함수 보니까 `isFull()` 체크하고, `++point`로 인덱스 **먼저** 올리고 나서 `isWhat[point] = num;` 하잖아? 이건 딱 봐도 'Top' 위치를 하나 올리고 거기다 데이터 넣는 스택의 **Push** 동작임.

3.  **데이터 빼는 함수 (`take`) 동작:** 이게 제일 결정적인데, 함수 보니까 `isEmpty()` 체크하고, `return isWhat[point--];` 이렇게 하잖아? 현재 `point` 위치에 있는 값을 **먼저** 반환하고 나서 `point`를 줄이지? 이게 바로 **LIFO (Last-In, First-Out)**, 즉 마지막에 넣은 놈을 제일 먼저 빼는 스택의 핵심 특징 **Pop** 동작임. `point--` 후위 감소 쓰는 거 보면 빼박이지.

4.  **`isEmpty()` / `isFull()` 함수:** 이름부터 스택/큐에서 맨날 쓰는 헬퍼 함수 이름임. 내용도 `point` 값이 `-1`인지 (비었는지), `MAX_SIZE - 1`인지 (꽉 찼는지) 체크하는 전형적인 배열 기반 스택 구현 방식임.

5.  **함수 이름들 (`into`, `take`):** 뭐 이건 개발자 맘이긴 한데, `into`(안으로) / `take`(가져가다) 이런 이름들이 뭔가 넣고 빼는 자료구조 느낌을 주기도 함. (근데 이건 부가적인 거고 핵심은 아님)

그러니까 종합하면,  
**[배열 + Top 포인터(`point`) + Push 동작 (`into`) + Pop 동작 (`take`, 특히 LIFO 보이는 `point--`) + 상태 체크 함수 (`isEmpty`, `isFull`)]**  
이런 구성 요소들이 딱 스택 구현이라는 걸 알려주는 거임. 특히 `take` 함수에서 `point--` (후위 감소) 쓰는 부분 보면 거의 99% 스택이라고 보면 된다 이거야 ㅋㅋ 감이 오지?

---

**주요 포인트 정리**

*   **스택 (Stack)**: 데이터 입출력이 한쪽 끝(Top)에서만 일어나는 자료구조. **LIFO (Last-In, First-Out)**, 즉 마지막에 들어간 게 제일 먼저 나오는 특징을 가짐.
*   **주요 연산**:
    *   **Push (`into`)**: 스택에 데이터를 넣는 연산. Top 위치를 증가시키고 데이터 저장.
    *   **Pop (`take`)**: 스택에서 데이터를 꺼내는 연산. Top 위치의 데이터를 반환하고 Top 위치를 감소시킴.
*   **상태 확인 함수**:
    *   **isEmpty**: 스택이 비어있는지 확인. (보통 Top 인덱스가 초기값 -1인지 검사)
    *   **isFull**: 스택이 꽉 찼는지 확인. (보통 Top 인덱스가 배열의 마지막 인덱스인지 검사)
*   **배열 기반 스택 구현**: 배열과 Top을 가리키는 인덱스 변수(`point`)를 사용하여 스택을 구현할 수 있음. 인덱스 관리가 중요.
*   **전위/후위 증감 연산자**:
    *   `++point` (전위): `point` 값을 먼저 증가시키고 그 값을 사용. (Push 할 때 사용)
    *   `point--` (후위): 현재 `point` 값을 먼저 사용하고 그 다음에 `point` 값을 감소시킴. (Pop 할 때 반환 후 사용) 이 차이를 잘 이해해야 함.

---

### 문제 10: 데이터베이스 설계 순서

> **문제:**
>
> 10. 데이터베이스 설계 순서를 <보기>를 참고하여 나열하시오.
> ```
> <보기>
> 구현, 요구조건 분석, 개념적 설계, 물리적 설계, 논리적 설계
> ```

**해설:**

아 ㅋㅋ 데이터베이스 설계 순서 맞추는 거네. 이거 완전 단골 문제임. 순서만 잘 외워두면 개꿀이지.

자, <보기>에 있는 놈들 순서를 잡아보자고.

1.  **요구조건 분석**: 제일 먼저 해야 할 거. 뭘 만들 건지, 어떤 데이터가 필요한지 사용자한테 물어보고 정리하는 단계임. 이게 없으면 시작도 못 함.
2.  **개념적 설계**: 요구조건 분석한 걸 바탕으로 데이터의 큰 그림(개념)을 잡는 거임. 엔티티(개체)가 뭐고, 걔네들 속성은 뭐고, 관계는 어떤지 이런 걸 모델링함. ERD(개체-관계 다이어그램) 같은 거 그리는 단계. 특정 DBMS에 종속되지 않게 만드는 게 포인트.
3.  **논리적 설계**: 개념적 설계에서 만든 모델을 특정 DBMS가 알아먹을 수 있는 논리적인 구조로 바꾸는 거임. 예를 들어 관계형 데이터베이스(RDBMS)를 쓴다면, 테이블 구조(스키마) 만들고, 기본키(PK), 외래키(FK) 같은 제약조건 정하고 이런 거 하는 단계임. 아직 물리적인 저장 방식은 신경 안 씀.
4.  **물리적 설계**: 논리적 설계를 바탕으로 실제 디스크 같은 저장 장치에 어떻게 데이터를 저장할 건지 구체적으로 정하는 거임. 어떤 데이터 타입을 쓸지(VARCHAR(20) vs CHAR(10) 등), 인덱스는 뭘로 잡을지, 파일 저장 구조는 어떻게 할지 등 성능이랑 저장 효율 고려해서 결정함. DBMS마다 달라질 수 있음.
5.  **구현**: 설계 다 끝났으니까 실제로 DBMS에 테이블 만들고, 제약조건 설정하고, 데이터 넣고 하는 단계임. SQL 써서 막 만드는 거지.

자, 그럼 순서는 딱 나오네.

**답:**

```
요구조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
```

---

**주요 포인트 정리**

*   **데이터베이스 설계 단계**: 사용자의 요구로부터 실제 데이터베이스를 만들기까지 거치는 체계적인 과정임.
*   **순서의 중요성**: 각 단계는 이전 단계의 결과물을 바탕으로 진행되므로 순서가 매우 중요함. (요구사항 모름 -> 개념 못 잡음 -> 논리 구조 못 만듦 -> ...)
*   **각 단계별 핵심 활동**:
    *   **요구조건 분석**: 사용자 요구 파악 및 명세화
    *   **개념적 설계**: E-R 다이어그램 등 개념적 구조 모델링 (DBMS 독립적)
    *   **논리적 설계**: 목표 DBMS에 맞는 논리적 스키마 설계 (테이블, PK/FK 정의 등)
    *   **물리적 설계**: 저장 구조, 인덱스, 데이터 타입 등 물리적 저장 방식 결정 (성능, 효율 고려)
    *   **구현**: 설계 기반으로 실제 DB 생성 및 구축 (SQL 사용)
*   **추상화 수준**: 요구조건 분석(가장 추상적) → 개념적 → 논리적 → 물리적 → 구현(가장 구체적) 순으로 점점 구체화됨.

---

### 문제 11: 디자인 패턴 식별 (싱글톤, 비지터)

> **문제:**
>
> 11. 다음 설명을 보고 (1), (2)에 들어갈 알맞은 디자인 패턴을 <보기>를 참고하여 작성하시오.
> (1) : 어떤 클래스가 최대 하나의 인스턴스만을 갖도록 보장하며, 이 인스턴스에 대한 전여걱인 접근점을 제공한다. 즉, 어플리케이션 내에서 해당 클래스의 인스턴스가 오직 하나만 존재하도록 하고, 이에 대한 전역적인 접근이 가능하게 한다. 이 패턴은 전역 변수를 통한 객체 공유로 인한 문제를 방지하고, 객체의 유일성을 보장하여 일관된 상태를 유지할 수 있다.
> (2) : 객체 구조를 변경하지 않고 새로운 동작을 추가하고자 할 때 사용된다. 이 패턴은 특정 객체 구조에 대해 각각의 구조에 대해 새로운 동작을 적용한다. 따라서 기존 객체 구조를 수정하지 않고 새로운 기능을 추가할 수 있다.
>
> ```
> <보기>
> Factory Method, Visitor, Interpreter, Singleton, Proxy, Prototype, Observer, Mememto, Bridge
> ```

**해설:**

아 ㅋㅋ 디자인 패턴 문제네. 설명 보고 뭔지 맞추는 거. 이런 건 키워드만 잘 캐치하면 됨.

**(1) 분석:**

*   "**최대 하나의 인스턴스만**을 갖도록 보장"
*   "**전역적인 접근점** 제공"
*   "인스턴스가 **오직 하나만** 존재"
*   "**유일성** 보장"

이거 완전 대놓고 **싱글톤 (Singleton)** 패턴 설명하는 거 아니냐? 딱 하나만 만들어서 돌려쓰는 거. 설정값 관리자나 로그 관리자 같은 거 만들 때 주로 씀. <보기>에 있나? 오 있네.

**(2) 분석:**

*   "객체 구조를 **변경하지 않고 새로운 동작 추가**"
*   "**각각의 구조**에 대해 **새로운 동작 적용**"
*   "**기존 객체 구조 수정 없이** 새로운 기능 추가"

이건 객체 구조는 그대로 놔두고, 그 구조를 돌아다니면서(방문하면서) 새로운 작업(동작)을 추가하는 방식임. 예를 들어 컴퓨터 부품들(CPU, RAM, 디스크 등) 구조가 있는데, 여기에 가격 계산하는 기능, 전력 소모 계산하는 기능 등을 부품 클래스 수정 없이 추가하고 싶을 때 쓰는 거. 이게 바로 **비지터 (Visitor)** 패턴임. <보기>에 있나? 어 이것도 있네.

**답:**

*   (1) : **Singleton**
*   (2) : **Visitor**

---

**주요 포인트 정리**

*   **싱글톤 패턴 (Singleton Pattern)**:
    *   **목적**: 클래스의 인스턴스가 오직 **하나만** 생성되도록 보장하고, 그 인스턴스에 대한 **전역 접근점**을 제공함.
    *   **키워드**: **하나의 인스턴스 (Only one instance)**, **전역 접근점 (Global access point)**, 유일성 보장.
    *   **용도**: 환경 설정, 로깅, 커넥션 풀 등 시스템 전체에서 하나만 존재해야 하는 객체에 사용.

*   **비지터 패턴 (Visitor Pattern)**:
    *   **목적**: 객체 구조(Element)와 처리 기능(Visitor)을 분리하여, **구조 변경 없이** 새로운 기능을 **추가**할 수 있게 함.
    *   **키워드**: **구조 변경 없이**, **새로운 동작(기능) 추가**, 분리된 처리.
    *   **용도**: 복잡한 객체 구조(예: 컴포지트 패턴)에 대해 다양한 작업을 수행해야 할 때, 각 작업을 Visitor로 구현하여 구조의 수정을 최소화함.

---

### 문제 12: 오류 제어 방식 식별

> **문제:**
>
> 12. 다음이 설명하는 오류 수정 방법을 <보기>를 참고하여 각각 작성하시오.
> (1) : 오류 검출 및 수정을 위한 블록 코드 중 하나로, 특히 단일 비트 오류에 대한 강력한 검출 능력을 가지고 있다. 데이터에 부가적인 비트를 추가하여 오류를 검출하고 수정할 수 있는 방식으로 동작한다.
> (2) : 데이터 전송 중 발생할 수 있는 오류를 감지하고 수정하기 위한 기술로, 송신측에서 추가적인 정보를 전송하여 수신측에서 오류를 복구할 수 있도록 한다.
> (3) : 전송된 데이터에 오류가 발생된 경우, 송신측에 오류 사실을 알려서 재전송으로 복원하는 방식이다.
> (4) : 오류 검출 기술 중 하나로, 1개의 비트를 추가하여 1의 개수가 짝수/홀수인지 판단하여 오류를 검출한다.
> (5) : 다항식 연산을 기반으로 하며, 송신자는 데이터에 대한 다항식 연산을 수행하여 나온 나머지를 추가적으로 전송한다. 수신자는 전송된 데이터와 다항식 연산을 수행하여 나온 나머지를 비교하여 오류를 감지할 수 있다.
>
> ```
> <보기>
> EAC, FEC, hamming, CRC, PDS, parity, BEC, ARQ, Sliding Window
> ```

**해설:**

아 ㅋㅋ 이거 오류 제어 방식 맞추는 거네. 데이터 통신 쪽에서 나오는 개념들임. 하나씩 까보자고.

**(1) 분석:**

*   "오류 검출 **및 수정**" (수정 가능)
*   "**단일 비트 오류**에 대한 강력한 검출 능력" (1비트 오류 특화)
*   "부가적인 비트 추가" (잉여 비트 사용)

이거 딱 **해밍 코드 (hamming)** 설명임. 패리티 비트 여러 개 써서 오류 위치까지 찾아내서 수정하는 방식. 단일 비트 오류 잡는데 탁월함. <보기>에 `hamming` 있네.

**(2) 분석:**

*   "오류를 감지하고 **수정**" (수정 가능)
*   "송신측에서 **추가적인 정보** 전송" (잉여 정보 보냄)
*   "수신측에서 오류를 **복구**" (재전송 없이 스스로 복구)

이건 수신 측에서 받은 잉여 정보만으로 오류를 고치는 방식. 즉, 앞으로(Forward) 보내준 정보로 고친다고 해서 **전진 에러 수정 (FEC, Forward Error Correction)** 이라고 함. <보기>에 `FEC` 있네.

**(3) 분석:**

*   "오류 발생된 경우, 송신측에 오류 사실을 알려서 **재전송**으로 복원" (재전송 요구)

오류 나면 "야 다시 보내!" 하는 방식. 이게 **자동 반복 요청 (ARQ, Automatic Repeat reQuest)** 임. 근데 잠깐...

> **니 추가 질문:**
>
> 답지에서는 (3)의 답이 BEC 라는데?

**내 추가 설명:**

아 내가 틀렸네 ㅋㅋ 쏘리. 니 말이 맞다.

다시 보자.

(3) : "전송된 데이터에 오류가 발생된 경우, **송신측에 오류 사실을 알려서 재전송으로 복원**하는 방식이다."

이거 내가 ARQ라고 했는데, <보기>에 **BEC (Backward Error Correction)** 도 있네.

*   **ARQ (Automatic Repeat reQuest)**: 이름 그대로 자동 **반복 요청**. 오류 나면 "다시 보내줘!" 요청하는 *구체적인 프로토콜/동작 방식*을 지칭하는 경우가 많음.
*   **BEC (Backward Error Correction)**: 오류 정보를 **수신측에서 송신측으로 되돌려 보내서(Backward)** 처리하는 방식을 포괄적으로 말함. ARQ가 대표적인 BEC 방식임. 즉, BEC가 좀 더 넓은 개념.

설명 자체는 "송신측에 알려서 재전송"이니까 ARQ의 핵심 동작이 맞긴 한데, 이걸 오류 정보가 뒤로(Backward) 가서 처리된다는 관점에서 **BEC**라고 부르는 게 맞음. 특히 <보기>에 둘 다 있을 때는 개념의 범주를 봐야 할 때가 있음.

**결론:** 니 말이 맞고 답지 말이 맞다. (3)번은 **BEC**가 더 적절한 답임. ARQ는 BEC의 한 종류로 볼 수 있으니까. 내가 너무 ARQ에 꽂혔네 ㅋㅋ ㅈㅅㅈㅅ

**(4) 분석:**

*   "오류 **검출** 기술" (수정은 언급 없음)
*   "**1개의 비트**를 추가" (추가 비트 1개)
*   "1의 개수가 **짝수/홀수인지 판단**" (짝/홀수 검사)

제일 단순한 오류 검출법. 1 개수 짝수나 홀수로 맞추는 거. 이게 **패리티 검사 (parity)** 임. <보기>에 `parity` 있네.

**(5) 분석:**

*   "오류 **감지**" (수정 언급 없음)
*   "**다항식 연산** 기반" (핵심 키워드)
*   "**나머지**를 추가적으로 전송"
*   "**나머지를 비교**하여 오류 감지"

다항식 나오고 나머지(체크섬) 계산해서 오류 검출하는 거. 이게 **순환 중복 검사 (CRC, Cyclic Redundancy Check)** 임. <보기>에 `CRC` 있네.

**답:**

*   (1) : **hamming**
*   (2) : **FEC**
*   (3) : **BEC**
*   (4) : **parity**
*   (5) : **CRC**

---

**주요 포인트 정리**

*   **오류 제어 방식 분류**: 크게 **오류 검출 (Detection)**과 **오류 수정 (Correction)**으로 나뉨.
    *   **오류 검출**: 패리티, CRC 등. 오류 발생 여부만 확인 가능.
    *   **오류 수정**: 해밍 코드, FEC 등. 오류 발생 위치를 찾아 수정 가능.
*   **오류 수정 방법**:
    *   **FEC (Forward Error Correction)**: 수신 측이 스스로 오류 수정 (잉여 정보 사용). 예: 해밍 코드.
    *   **BEC (Backward Error Correction)**: 오류 발생 시 송신 측에 오류 정보를 전달(Backward)하여 오류를 수정하는 방식의 **총칭**. 대표적인 예가 **재전송(ARQ)**임.
*   **주요 기술 특징**:
    *   **패리티 (parity)**: 가장 간단. 1비트 추가, 짝/홀수 검사. 홀수 개 오류 검출 못함.
    *   **CRC (Cyclic Redundancy Check)**: 다항식 기반, 나머지(체크섬) 비교. 검출 능력 우수. 주로 검출용.
    *   **해밍 코드 (hamming)**: 여러 패리티 비트 사용. 단일 비트 오류 수정 가능.
*   **용어 구분**: FEC는 일반적인 전진 에러 수정 방식을 통칭하고, 해밍 코드는 FEC의 구체적인 구현 방법 중 하나임. ARQ는 재전송 기반 방식 전체를 의미하며 BEC의 한 종류임. <보기>에 둘 다 있다면, 문맥상 더 넓은 개념인 BEC를 답으로 요구했을 가능성이 높음.

---

### 문제 13: HDLC 프로토콜 (프레임, 모드)

> **문제:**
>
> 13. 다음 HDLC 프로토콜에 대한 설명에서 (1), (2), (3), (4), (5)에 들어갈 용어를 <보기>를 참고하여 작성하시오.
> ```
> HDLC 프로토콜에서 각기 다른 목적으로 사용되는 (1) 프레임, (2) 프레임, (3) 프레임의 유형이 있다.
> - (1) 프레임은 실제 데이터를 전송하기 위해 사용된다. 이 프레임에는 헤더, 정보 필드, FCS 등이 포함된다.
> |Flag|주소|제어필드|정보 데이터|CRC|Flag|
> - (2) 프레임은 흐름 제어와 오류 제어를 위해 사용된다. 이 프레임은 데이터의 흐름을 관리하거나 오류 상태를 확인하는데에 활용된다
> |Flag|주소|제어 필드|CRC|Flag|
> - (3) 프레임은 특별한 통신 제어를 위해 사용된다. 주로 연결 설정 및 해제, 프로토콜 타입 등을 다루기 위해 사용된다.
> |Flag|주소|제어 필드|관리 정보 데이터|CRC|Flag|
>
> 또한 HDLC는 3가지 데이터 전송 모드가 있다.
> - 정상 응답 모드는 기본 서버는 보조 서버로 데이터 전송을 시작할 수 있지만 보조 서버는 기본 서버의 명령에 대한 응답으로만 데이터를 전송할 수 있다.
> - (4) 모드는 각 국이 주국이자 종국으로 서로 대등하게 균형적으로 명령과 응답하며 동작하므로 허가를 받지 않고 송신을 개시할 수 있다.
> - (5) 모드는 종국은 주국의 허가(Poll) 없이도 송신이 가능하지만 , 링크 설정이나 오류 복구 등의 제어 기능은 주국만 할 수 있는 모드이다.
> ```
> ```
> <보기>
> ㄱ. 연결제어 ㄴ. 감독 ㄷ. 정보 ㄹ. 양방향응답 ㅁ. 익명 ㅂ. 비번호 ㅅ. 릴레이 ㅇ. 동기균형 ㅈ. 동기응답 ㅊ. 비동기균형 ㅋ. 비동기응답
> ```

**해설:**

아 ㅋㅋ HDLC 문제네. 프레임 종류랑 전송 모드 맞추는 거. 이거 은근 외울 거 좀 있음. 차근차근 까보자고.

**프레임 유형 분석:**

*   **(1) 프레임:** "**실제 데이터** 전송", "헤더, **정보 필드**, FCS 포함". 데이터 실어 나르는 메인 프레임임. 이게 바로 **정보 프레임 (Information frame, I-frame)**. <보기>에서 찾아보면 `ㄷ. 정보` 이거네.
*   **(2) 프레임:** "**흐름 제어와 오류 제어**", "데이터 흐름 관리, 오류 상태 확인". 데이터는 없고 제어 신호만 주고받는 거. 예를 들어 "잘 받았다(ACK)", "잠깐만(RNR)" 이런 거. 이게 **감독 프레임 (Supervisory frame, S-frame)**. <보기>에서 찾아보면 `ㄴ. 감독` 이거네.
*   **(3) 프레임:** "**특별한 통신 제어**", "연결 설정 및 해제". 링크 관리용 프레임임. 순서 번호 같은 거 없이 관리 목적으로만 씀. 이게 **비번호 프레임 (Unnumbered frame, U-frame)**. <보기>에서 찾아보면 `ㅂ. 비번호` 이거네.

**전송 모드 분석:**

*   첫 번째는 **정상 응답 모드 (NRM, Normal Response Mode)** 라고 이미 설명해줬네. 주국이 허락해야 종국이 응답하는 방식.
*   **(4) 모드:** "**각 국이 주국이자 종국**", "**서로 대등하게 균형적**", "**허가 없이 송신 개시**". 둘 다 동등한 입장에서 아무 때나 데이터 보낼 수 있는 완전 자유로운 모드. 이게 **비동기 균형 모드 (ABM, Asynchronous Balanced Mode)**. <보기>에서 `ㅊ. 비동기균형` 이거네. (동기균형(SBM)도 있긴 한데 보통 ABM을 더 많이 씀)
*   **(5) 모드:** "**종국은 주국의 허가 없이도 송신 가능**", "하지만 **제어 기능은 주국만**". 종국이 데이터는 맘대로 보낼 수 있는데, 링크 설정 같은 중요 컨트롤은 주국만 할 수 있는 모드. 이게 **비동기 응답 모드 (ARM, Asynchronous Response Mode)**. <보기>에서 `ㅋ. 비동기응답` 이거네.

**답:**

*   (1) : **ㄷ. 정보**
*   (2) : **ㄴ. 감독**
*   (3) : **ㅂ. 비번호**
*   (4) : **ㅊ. 비동기균형**
*   (5) : **ㅋ. 비동기응답**

---

**주요 포인트 정리**

*   **HDLC 프레임 종류**:
    *   **정보 프레임 (I-frame, `ㄷ. 정보`)**: 사용자 데이터 전송, 순서 번호(N(S), N(R)) 포함.
    *   **감독 프레임 (S-frame, `ㄴ. 감독`)**: 흐름 제어 및 오류 제어 (ACK/NACK, RNR/RR 등), 순서 번호(N(R)) 포함.
    *   **비번호 프레임 (U-frame, `ㅂ. 비번호`)**: 링크 설정/해제 등 관리 목적, 순서 번호 없음.
*   **HDLC 전송 모드**:
    *   **정상 응답 모드 (NRM)**: 주국-종국 구조, 종국은 주국의 허가(Poll) 시에만 전송 가능. (일대다 환경)
    *   **비동기 응답 모드 (ARM, `ㅋ. 비동기응답`)**: 주국-종국 구조, 종국이 허가 없이도 전송 가능 (단, 제어는 주국). NRM보다 종국 자율성 높음.
    *   **비동기 균형 모드 (ABM, `ㅊ. 비동기균형`)**: 두 국이 동등 (복합국), 서로 허가 없이 전송 가능. (일대일 환경, 가장 많이 사용)
*   **용어 매칭**: 문제 설명의 키워드와 <보기>의 용어를 정확히 연결하는 것이 중요. (예: 실제 데이터 -> 정보, 흐름/오류 제어 -> 감독, 연결 설정/해제 -> 비번호, 대등/균형 -> 균형 모드, 허가 없이 송신 -> 비동기 등)

---

### 문제 14: Java 문자열 비교 (`==` vs `.equals()`)

> **문제:**
>
> 14. 다음의 Java 프로그램의 실행 결과를 작성하시오.
> ```java
> public class YoungJin {
>     public static void main(String[] args) throws Exception {
>         string str1 = "Programming";
>         String str2 = "Programming";
>         String str3 = new String("Programming");
>
>         System.out.println(str1 == str2);
>         System.out.println(str1 == str3);
>         System.out.println(str1.equals(str3));
>         System.out.println(str2.equals(str3));
>     }
> }
> ```

**해설:**

아 ㅋㅋ 이거 Java 문자열 비교 문제네. `==` 랑 `.equals()` 차이 모르면 바로 낚이는 거임.

코드 분석 드간다.

1.  `string str1 = "Programming";`
    *   (앗, Java는 `String` 대문자로 시작해야 함. `string`은 C#이나 C++쪽. 문제 오타인 듯? 일단 `String`으로 보고 풀겠음)
    *   `String str1 = "Programming";`: 이렇게 문자열 리터럴로 생성하면, Java는 **String Pool**이라는 특별한 메모리 공간에 "Programming" 문자열 객체를 만들고 `str1`이 그걸 가리키게 함.
2.  `String str2 = "Programming";`: 또 같은 문자열 리터럴이네.
    *   Java는 String Pool에서 "Programming" 있는지 찾아봄. 어? 아까 `str1` 만들 때 쓴 거 있네? 그럼 **새로 안 만들고** `str2`도 **이미 있는 그 "Programming" 객체**를 가리키게 함. 즉, `str1`과 `str2`는 **똑같은 메모리 주소**를 가리킴.
3.  `String str3 = new String("Programming");`: 이건 `new` 키워드를 썼네.
    *   `new`는 무조건 **새로운 객체**를 만듦. String Pool이랑 상관없이 힙(Heap) 메모리에 "Programming"이라는 내용을 가진 **별도의 String 객체**를 새로 만들고 `str3`가 그걸 가리키게 함.
    *   결론: `str1`과 `str2`는 같은 객체, `str3`는 내용만 같고 다른 객체임.

이제 출력문 보자.

*   `System.out.println(str1 == str2);`
    *   `==` 연산자는 객체 비교할 때 **메모리 주소(참조)**를 비교함.
    *   `str1`과 `str2`는 String Pool에 있는 같은 객체를 가리키니까 주소가 같음.
    *   결과: `true`

*   `System.out.println(str1 == str3);`
    *   `==` 연산자로 주소 비교.
    *   `str1`은 String Pool 객체, `str3`는 `new`로 만든 힙 객체. 서로 다른 객체니까 주소가 다름.
    *   결과: `false`

*   `System.out.println(str1.equals(str3));`
    *   `.equals()` 메소드는 String 클래스에서 **내용(문자열 값)** 자체를 비교하도록 오버라이드(재정의) 되어 있음.
    *   `str1`의 내용 "Programming"과 `str3`의 내용 "Programming"은 같음.
    *   결과: `true`

*   `System.out.println(str2.equals(str3));`
    *   `.equals()`로 내용 비교.
    *   `str2`의 내용 "Programming"과 `str3`의 내용 "Programming"은 같음.
    *   결과: `true`

자, 출력 결과를 순서대로 적으면 됨.

**답:**

```
true
false
true
true
```

---

**주요 포인트 정리**

*   **Java String 객체 생성 방식**:
    *   **리터럴 (`String s = "abc";`)**: String Pool에 없으면 만들고, 있으면 기존 객체 재사용. 같은 리터럴은 같은 객체를 가리킴.
    *   **`new` 연산자 (`String s = new String("abc");`)**: 무조건 힙 메모리에 새로운 객체 생성. 내용이 같아도 다른 객체임.
*   **`==` 연산자**: 객체에 사용될 때, 두 참조 변수가 **같은 객체(동일한 메모리 주소)**를 가리키는지 비교함. (Identity 비교)
*   **`.equals()` 메소드**: String 클래스에서는 객체의 **내용(문자열 값)**이 같은지 비교하도록 재정의되어 있음. (Equality 비교)
*   **String Pool**: Java가 문자열 리터럴을 효율적으로 관리하기 위해 사용하는 메모리 영역. 불변(Immutable)인 String 객체의 특징과 관련 있음.

---

### 문제 15: 암호 알고리즘 분류 (대칭키 vs 비대칭키)

> **문제:**
>
> 15. 다음 <보기>를 보고 대칭키와 비대칭키를 구분하여 작성하시오.
> ```
> <보기>
> DES, 3-DES, RSA, SEED, ARIA, DSA, RC-4
> ```

**해설:**

아 ㅋㅋ 암호 알고리즘 구분하는 거네. 대칭키랑 비대칭키만 알면 됨.

*   **대칭키 (Symmetric Key):** 암호화할 때랑 복호화할 때 **똑같은 키** 쓰는 놈들임. 속도가 빠름. 보통 데이터 자체를 암호화할 때 많이 씀. 키를 주고받는 게 좀 귀찮음.
*   **비대칭키 (Asymmetric Key):** 암호화 키(공개키)랑 복호화 키(개인키)가 **서로 다른** 놈들임. 속도는 느린데, 키 분배가 편하고 전자서명 같은 데 쓸 수 있음.

자, <보기>에 있는 놈들 하나씩 분류해보자고.

*   **DES**: 옛날 표준 대칭키 블록 암호. -> **대칭키**
*   **3-DES**: DES 세 번 돌리는 거. 여전히 대칭키 방식. -> **대칭키**
*   **RSA**: 공개키/개인키 쓰는 대표적인 비대칭키 암호. 소인수분해 기반. -> **비대칭키**
*   **SEED**: 우리나라에서 만든 대칭키 블록 암호. -> **대칭키**
*   **ARIA**: 이것도 우리나라에서 만든 대칭키 블록 암호. SEED보다 최신. -> **대칭키**
*   **DSA**: 전자서명 알고리즘. 전자서명은 비대칭키 기술 씀. -> **비대칭키**
*   **RC-4**: 스트림 암호 방식의 대칭키 알고리즘. (WEP 같은 데 쓰였는데 지금은 잘 안 씀) -> **대칭키**

정리하면 이렇게 되네.

**답:**

*   **대칭키:** DES, 3-DES, SEED, ARIA, RC-4
*   **비대칭키:** RSA, DSA

---

**주요 포인트 정리**

*   **대칭키 암호 (Symmetric Key Cryptography)**:
    *   암호화 키 = 복호화 키 (동일한 키 사용)
    *   장점: 속도 빠름.
    *   단점: 키 배송/관리가 어려움.
    *   종류:
        *   **블록 암호 (Block Cipher)**: DES, 3-DES, AES, SEED, ARIA 등 (데이터를 블록 단위로 처리)
        *   **스트림 암호 (Stream Cipher)**: RC4, ChaCha20 등 (데이터를 스트림(비트/바이트) 단위로 처리)

*   **비대칭키 암호 (Asymmetric Key Cryptography)**:
    *   암호화 키 ≠ 복호화 키 (공개키/개인키 쌍 사용)
    *   장점: 키 분배 용이, 전자서명 가능.
    *   단점: 속도 느림.
    *   종류: RSA, Diffie-Hellman, ECC, DSA 등.

*   **알고리즘 구분 능력**: 주어진 암호 알고리즘 이름만 보고도 이게 대칭키인지 비대칭키인지 구분할 수 있어야 함. 특히 유명한 놈들(DES, AES, RSA)은 기본으로 알아야 함.

---

### 문제 16: 자료구조/알고리즘 용어 - 해시

> **문제:**
>
> 16. 다음 설명을 보고 빈칸에 들어갈 알맞은 용어를 작성하시오.
> ```
> - (빈칸)(이)란 데이터를 저장할 때, 데이터의 키 값을 (빈칸) 함수를 사용해 (빈칸) 주소로 변환하고, 해당 주소에 데이터를 저장하는 방식이다.
> - 데이터를 찾으려면 키 값으로 (빈칸) 함수를 호출하여 (빈칸) 주소를 얻은 후, 해당 주소에 있는 데이터에 접근한다.
> - 검색 속도가 매우 빠르며, 데이터의 추가, 삭제, 검색에 용이하다.
> ```

**해설:**

아 ㅋㅋ 이거 자료구조/알고리즘 용어 문제네. 키 값 써서 주소 뙇 만들어서 바로 찾아가는 거.

설명 까보자고.

*   "데이터의 **키 값**을 **(빈칸) 함수**를 사용해 **(빈칸) 주소**로 변환"
*   "해당 **주소**에 데이터를 저장"
*   "키 값으로 **(빈칸) 함수**를 호출하여 **(빈칸) 주소**를 얻은 후, 해당 주소에 접근"
*   "**검색 속도가 매우 빠름**"

키(Key)를 어떤 함수에 넣었더니 주소(배열 인덱스 같은 거)가 툭 튀어나오고, 그 주소에 값을 저장하거나 꺼내오는 방식. 이게 뭐냐?

**해싱 (Hashing)** 이잖아!

*   키 값을 주소로 바꿔주는 함수 -> **해시 함수 (Hash function)**
*   해시 함수로 계산된 주소 -> **해시 주소 (Hash address)** 또는 그냥 해시 값, 해시 코드라고도 함.
*   이런 해싱 기법을 쓰는 자료구조 -> **해시 테이블 (Hash table)**

그러니까 빈칸에는 다 **해시(Hash)** 또는 관련된 말이 들어가야 함. 문제에서 용어 하나만 쓰라고 한 것 같으니 대표 용어인 '해시'를 넣으면 되겠네.

**답:** **해시 (Hash)**

(만약 빈칸마다 다른 걸 넣어야 한다면, 순서대로 `해시 함수`, `해시 주소`, `해시 함수`, `해시 주소` 가 되겠지만, 보통 이런 문제는 핵심 개념 하나를 묻는 경우가 많음. 여기선 '해시'가 가장 적절)

---

**주요 포인트 정리**

*   **해싱 (Hashing)**: 임의의 길이 데이터를 **고정된 길이의 값(해시 값/주소)**으로 변환하는 과정 또는 기술.
*   **해시 함수 (Hash Function)**: 이 변환을 수행하는 함수. 입력 키(Key)를 받아서 해시 주소(배열 인덱스 등)를 반환함. 좋은 해시 함수는 키를 최대한 골고루 분산시켜야 함.
*   **해시 테이블 (Hash Table)**: 해싱을 사용하여 데이터를 저장하고 검색하는 자료구조. 키(Key)와 값(Value) 쌍을 저장하며, 키에 대한 해시 값을 계산하여 해당 위치에 값을 저장/검색함.
*   **장점**: 데이터 양에 관계없이 평균적으로 **매우 빠른 검색, 삽입, 삭제** 속도 (O(1))를 가짐.
*   **단점**: **충돌 (Collision)** 발생 가능성 (서로 다른 키가 같은 해시 주소를 갖는 경우). 충돌 해결 방법(체이닝, 개방 주소법 등)이 필요함.
*   **키워드**: **키(Key)**, **해시 함수(Hash Function)**, **해시 주소(Hash Address)**, **빠른 검색 속도**.

---

### 문제 17: SQL ALTER TABLE (DROP COLUMN CASCADE)

> **문제:**
>
> 17. 다음을 보고 빈칸을 작성하여 쿼리를 완성하시오.
> - 학과 테이블에서 전화번호 속성을 삭제한다. 이때 참고하고 있는 테이블이 있다면 연쇄 삭제되도록 설정한다.
> ```sql
> <쿼리>
> ALTER TABLE 학과
> DROP COLUMN 전화번호 (빈칸);
> ```

**해설:**

아 ㅋㅋ SQL 문제네. 테이블 구조 바꾸는 `ALTER TABLE` 쓰는 거.

문제 보니까 "학과" 테이블에서 "전화번호" 컬럼을 날리래. 근데 그냥 날리는 게 아니라, 만약 다른 테이블에서 이 컬럼을 참조하고 있으면 (외래키 같은 걸로) 그것들도 같이 처리되게 하라는 거임. "연쇄 삭제"라는 말이 힌트네.

테이블 구조 변경은 `ALTER TABLE` 쓰고, 컬럼 삭제는 `DROP COLUMN` 쓴다. 이건 기본.

`ALTER TABLE 학과 DROP COLUMN 전화번호` 여기까지는 쉽고.

이제 "연쇄 삭제" 옵션을 추가해야 함. 컬럼 지울 때 관련된 제약 조건이나 참조 같은 거 같이 날려버리는 옵션이 뭐냐? 바로 **`CASCADE`** 임.

반대로 만약 참조하는 게 있으면 삭제 못하게 막는 건 `RESTRICT` 인데, 여기선 연쇄 삭제하랬으니까 `CASCADE` 써야 함.

**답:** **CASCADE**

그래서 완성된 쿼리는 이거임:

```sql
ALTER TABLE 학과
DROP COLUMN 전화번호 CASCADE;
```

---

**주요 포인트 정리**

*   **`ALTER TABLE`**: 테이블의 구조(스키마)를 변경할 때 사용하는 SQL 명령어 (컬럼 추가/삭제/수정, 제약 조건 추가/삭제 등).
*   **`DROP COLUMN`**: `ALTER TABLE` 문 내에서 특정 컬럼을 삭제할 때 사용.
*   **`CASCADE` 옵션**: `DROP COLUMN` 또는 `DROP TABLE` 등을 수행할 때, 삭제하려는 대상(컬럼, 테이블)을 **참조하고 있는 다른 객체(예: 외래 키 제약 조건)**까지 **연쇄적으로 함께 삭제**하도록 지정하는 옵션임. 데이터 무결성 유지를 위해 신중하게 사용해야 함.
*   **`RESTRICT` 옵션**: `CASCADE`와 반대로, 삭제하려는 대상을 참조하는 객체가 하나라도 있으면 삭제 작업을 **중단**하고 오류를 발생시키는 옵션. 데이터 손실을 방지하는 안전한 기본값인 경우가 많음. (이 문제에서는 해당 없음)

---

### 문제 18: C언어 선택 정렬 구현

> **문제:**
>
> 18. 다음은 C언어로 선택 정렬을 구현한 것이다. 빈칸에 들어갈 알맞은 연산자를 작성하시오.
> ```c
> #include <stdio.h>
> void swap(int *xp, int *yp) {
>     int temp = *xp;
>     *xp = *yp;
>     *yp = temp;
> }
>
> void selectionSort(int arr[], int n){
>     int i, j, min_idx;
>     for (i = 0; i < n-1; i++) {
>         min_idx = i;
>         for (j = i+1; j < n; j++){
>             if(arr[j] (빈칸) arr[min_idx])
>                 min_idx = j;
>         }
>     swap(&arr[min_idx], &arr[i]);
>     }
> }
>
> void printArray(int arr[], int size){
>     int i;
>     for (i = 0; i < size; i++)
>         printf("%d", arr[i]);
>     printf("\n");
> }
>
> int main() {
>     int arr[] = {64, 25, 12, 22, 11};
>     int n = sizeof(arr)/sizeof(arr[0]);
>
>     selectionSort(arr, n);
>     
>     printf("정렬된 배열: \n");
>     printArray(arr, n);
>     
>     return 0;
> }
> ```

**해설:**

아 ㅋㅋ 이거 정렬 알고리즘 문제네. 선택 정렬(Selection Sort) 코드임.

코드 분석 드간다.

1.  `swap()` 함수: 두 변수 값 바꾸는 거. 포인터 써서 직접 바꿈. ㅇㅋ.
2.  `selectionSort()` 함수: 이게 메인임.
    *   바깥 `for` 루프 (`i`): 0부터 `n-2`까지 돌면서 정렬될 위치를 잡음. `i`번째 자리에 들어갈 가장 작은 놈을 찾아서 넣을 거임.
    *   `min_idx = i;`: 일단 현재 `i`번째 놈이 제일 작다고 가정하고 시작.
    *   안쪽 `for` 루프 (`j`): `i+1`부터 끝까지(`n-1`) 돌면서 `arr[i]` 뒤에 있는 아직 정렬 안 된 놈들을 스캔함.
    *   `if(arr[j] (빈칸) arr[min_idx]) min_idx = j;`: 여기가 핵심! 현재까지 찾은 최소값(`arr[min_idx]`)이랑 지금 보고 있는 놈(`arr[j]`)을 비교해서, **만약 `arr[j]`가 더 작으면**, `min_idx`를 `j`로 업데이트해야 함. 그래야 진짜 최소값의 인덱스를 계속 추적할 수 있음.
    *   `swap(&arr[min_idx], &arr[i]);`: 안쪽 루프 다 돌고 나면 `min_idx`에는 `i`번째부터 끝까지 중에 진짜 최소값의 인덱스가 담겨있음. 이 최소값을 `i`번째 위치에 있는 놈이랑 슥 바꿔치기함. 이러면 `i`번째 자리에는 올바른 값이 들어감.

자, 그럼 저 `if`문에서 "arr[j]가 arr[min_idx]보다 더 작으면" 이걸 코드로 어떻게 쓰냐? 그냥 "**작다**"는 비교 연산자 쓰면 되지 않겠음?

바로 **`<`** 이거임. `arr[j] < arr[min_idx]` 이렇게 쓰면 "arr[j]의 값이 arr[min_idx]의 값보다 작을 경우" 라는 조건이 됨. 그래야 최소값을 찾아서 `min_idx`를 갱신할 수 있지.

**답:** **<**

---

**주요 포인트 정리**

*   **선택 정렬 (Selection Sort)**: 정렬되지 않은 부분에서 **가장 작은 (또는 가장 큰) 원소를 찾아서** 정렬된 부분의 **맨 뒤에** 갖다 붙이는 과정을 반복하는 정렬 알고리즘.
*   **동작 방식**:
    *   전체 배열에서 최소값을 찾는다.
    *   찾은 최소값을 배열의 첫 번째 원소와 교환한다.
    *   첫 번째 원소를 제외한 나머지 배열에서 다시 최소값을 찾는다.
    *   찾은 최소값을 배열의 두 번째 원소와 교환한다.
    *   이 과정을 배열 끝까지 반복한다.
*   **핵심 비교**: 현재까지의 최소값(`arr[min_idx]`)과 스캔 중인 원소(`arr[j]`)를 비교하여 **더 작은 값을 새로운 최소값으로** 설정하는 부분이 핵심. 이를 위해 `<` 연산자를 사용 (오름차순 정렬 기준). 내림차순으로 하려면 `>` 쓰면 됨.
*   **시간 복잡도**: 항상 O(n²) 임. 데이터 상태랑 상관없이 꿋꿋하게 비교함. 비효율적이지만 구현은 쉬움.

---

### 문제 19: 파이썬 문자열 슬라이싱

> **문제:**
>
> 19. 다음의 파이썬 프로그램의 출력 결과를 작성하시오.
> ```python
> str = "Young Jin engineer information precessing"
> str_1 = str[:3]
> str_2 = str[4:6]
> str_3 = str[28:]
> str_f = str_1 + str_2 + str_3
> print(str_f)
> ```

**해설:**

아 ㅋㅋ 파이썬 문자열 슬라이싱 문제네. 인덱스만 잘 세면 됨.

코드 까보자고.

1.  `str = "Young Jin engineer information precessing"`: 일단 문자열 하나 만들었네. 길이 좀 되네. 인덱스 세기 귀찮...지만 해야지.
    ```
    Y o u n g   J i n   e n g i n e e r   i n f o r m a t i o n   p r e c e s s i n g
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
                  10        20        30        40
    ```
    총 41글자 (인덱스 0부터 40까지).

2.  `str_1 = str[:3]`: 슬라이싱 시작. `:` 앞에 숫자 없으면 처음(인덱스 0)부터 시작. `:` 뒤에 3은 인덱스 3 **바로 앞까지** 자르라는 거임 (인덱스 0, 1, 2).
    *   `str[0]` = 'Y'
    *   `str[1]` = 'o'
    *   `str[2]` = 'u'
    *   결과: `str_1` = `"You"`

3.  `str_2 = str[4:6]`: 인덱스 4부터 시작해서 인덱스 6 **바로 앞까지** (인덱스 4, 5).
    *   `str[4]` = 'g'
    *   `str[5]` = ' ' (공백 문자임!)
    *   결과: `str_2` = `"g "`

4.  `str_3 = str[28:]`: 인덱스 28부터 시작해서 `:` 뒤에 숫자 없으면 **끝까지** 다 가져오라는 거임 (인덱스 28부터 40까지).
    *   `str[28]` = 'o'
    *   ... 쭉 가서 ...
    *   `str[40]` = 'g'
    *   결과: `str_3` = `"on precessing"`

5.  `str_f = str_1 + str_2 + str_3`: 문자열 3개 그냥 쭉 이어붙이기.
    *   `"You"` + `"g "` + `"on precessing"`
    *   결과: `str_f` = `"Youg on precessing"`

6.  `print(str_f)`: 마지막에 합쳐진 `str_f` 출력.

**답:**

```
Youg on precessing
```

---

**주요 포인트 정리**

*   **파이썬 문자열 슬라이싱 (Slicing)**: 문자열의 일부를 잘라내는 기능. `문자열[시작인덱스:끝인덱스]` 형태로 사용.
    *   **`시작인덱스`**: 포함됨 (Inclusive). 생략하면 처음(0)부터.
    *   **`끝인덱스`**: **포함되지 않음** (Exclusive). 여기까지 잘리는 게 아니라 이 **바로 앞까지** 잘림. 생략하면 문자열 끝까지.
*   **인덱스 번호**: 파이썬 인덱스는 **0부터 시작**함. 마지막 글자 인덱스는 `길이 - 1`.
*   **문자열 덧셈 (`+`)**: 문자열끼리 더하면 그냥 순서대로 이어붙여짐 (Concatenation).
*   **공백 문자**: 슬라이싱이나 인덱싱할 때 공백도 하나의 문자로 취급해서 정확히 포함/제외해야 함.

---

### 문제 20: 통합 테스트 도구 (드라이버, 스텁)

> **문제:**
>
> 20. 다음이 설명하는 통합 테스트 도구를 작성하시오.
> ```
> (1) : 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하며, 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트에 필요
> (2) : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 하향식 테스트에 필요
> ```

**해설:**

아 ㅋㅋ 이거 통합 테스트 할 때 쓰는 가짜 모듈들 얘기네. 상향식이냐 하향식이냐에 따라 부르는 이름이 다름.

**(1) 분석:**

*   "**하위 모듈**을 **호출**" (얘가 상위 역할)
*   "파라미터 전달" (호출할 때 값 넘겨줌)
*   "결과 도출" (호출 후 결과 받아서 확인)
*   "**상향식 테스트**에 필요" (핵심!)

상향식(Bottom-up) 테스트는 아래쪽 모듈부터 테스트하고 위로 올라감. 근데 아래쪽 모듈을 테스트하려면 걔를 불러주는 위쪽 모듈이 필요하잖아? 아직 위쪽 모듈이 없거나 덜 만들어졌을 때, 임시로 아래 모듈을 **호출(Drive)** 해주는 역할을 하는 가짜 모듈이 필요함. 이게 바로 **테스트 드라이버 (Test Driver)** 임.

**(2) 분석:**

*   "**제어 모듈**(상위 모듈)이 **호출**하는 **타 모듈**(하위 모듈)" (얘가 하위 역할)
*   "기능을 **단순히 수행**" (진짜 로직은 없고 흉내만 냄)
*   "**하향식 테스트**에 필요" (핵심!)

하향식(Top-down) 테스트는 위쪽 모듈부터 테스트하고 아래로 내려감. 위쪽 모듈을 테스트하려면 걔가 불러다 쓰는 아래쪽 모듈들이 필요함. 아직 아래쪽 모듈이 없거나 덜 만들어졌을 때, 위쪽 모듈의 호출에 그냥 간단하게 응답만 해주는 가짜 모듈이 필요함. 진짜 기능은 없고 "나 호출됐음" 하고 간단한 값만 리턴하는 **대역(Stub)**. 이게 바로 **테스트 스텁 (Test Stub)** 임.

**답:**

*   (1) : **테스트 드라이버 (Test Driver)**
*   (2) : **테스트 스텁 (Test Stub)**

---

**주요 포인트 정리**

*   **통합 테스트 (Integration Testing)**: 여러 모듈(단위)을 결합하여 서로 잘 상호작용하는지 테스트하는 과정.
*   **테스트 하네스 (Test Harness)**: 테스트를 지원하기 위한 코드와 데이터를 통칭. 테스트 드라이버와 테스트 스텁은 테스트 하네스의 구성 요소임.
*   **테스트 드라이버 (Test Driver)**:
    *   **상향식(Bottom-up)** 통합 테스트에서 사용됨.
    *   테스트 대상 모듈의 **상위 모듈 역할**을 함 (테스트 대상 모듈을 호출).
    *   테스트 데이터를 설정하고, 테스트 대상 모듈을 실행시키며, 결과 확인.
*   **테스트 스텁 (Test Stub)**:
    *   **하향식(Top-down)** 통합 테스트에서 사용됨.
    *   테스트 대상 모듈의 **하위 모듈 역할**을 함 (테스트 대상 모듈로부터 호출됨).
    *   실제 로직 없이 단순히 호출에 응답하거나 미리 정의된 값을 반환하는 **가짜(Dummy) 모듈**.
*   **핵심 구분**: **누구를 대신하고(상위/하위)**, **어떤 테스트 방식(상향식/하향식)**에 쓰이는지가 중요. 드라이버는 운전(호출)하고, 스텁은 호출에 응답만 함.

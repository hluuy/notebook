# 2023 기출 02회 해설

### 문제 1: C언어 배열 회전

**문제:**

다음 C언어 프로그램을 보기와 같은 입력과 출력이 되도록 빈칸에 들어갈 알맞은 코드를 작성하시오.

```c
int main(){
    int array[5];
    for (int i = 0; i < 5; i++){
        printf("숫자를 입력해주세요");
        scanf("%d", &array[i]);
    }
    for  (int k = 0; k < 5; k++) {
        printf("%d", ( 빈칸 ));
    }
    return 0;
}
```

**입력/출력 예시:**

```
입력
숫자를 입력해주세요 : 1
숫자를 입력해주세요 : 2
숫자를 입력해주세요 : 3
숫자를 입력해주세요 : 4
숫자를 입력해주세요 : 5

출력
23451

입력
숫자를 입력해주세요 : 4
숫자를 입력해주세요 : 2
숫자를 입력해주세요 : 5
숫자를 입력해주세요 : 3
숫자를 입력해주세요 : 1

출력
25314
```

**답:** `array[(k + 1) % 5]`

**주요 포인트:**

*   **배열 인덱싱**: `배열이름[인덱스]` 로 특정 요소 접근 (인덱스는 0부터).
*   **순환 접근**: 배열 끝에서 처음으로 돌아올 땐 `%` (나머지 연산자) 활용. `(현재_인덱스 + 이동칸수) % 배열크기`.
*   **For 루프와 인덱스**: 루프 변수(`k`)를 이용해 접근할 배열 인덱스 계산.

---

### 문제 2: Java 거스름돈 계산

**문제:**

다음 Java 프로그램은 4620원을 1000원, 500원, 100원, 10원 지폐와 동전으로 나누는 프로그램이다. (1), (2), (3), (4)에 들어갈 코드를 <보기>를 참고하여 작성하시오.

```java
public class YoungJin {
    public static void main(String[] args) throws Exception {
        int m = 4620;

        int a = ( 1 ); // 천원짜리 4장 출력
        int b = ( 2 ); // 오백원짜리 1개 출력
        int c = ( 3 ); // 백원짜리 1개 출력
        int d = ( 4 ); // 십원짜리 2개 출력

        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
        System.out.println(d);
    }
}
```

**<보기>**

```
변수 : m
연산자 : % /
괄호 : ()
```

**답:**

*   (1) : `m / 1000`
*   (2) : `(m % 1000) / 500`
*   (3) : `(m % 500) / 100`
*   (4) : `(m % 100) / 10`

**주요 포인트:**

*   **정수 나눗셈 (`/`)**: 몫 구하기 (소수점 버림).
*   **나머지 연산 (`%`)**: 나머지 구하기 (다음 단위 계산 위해 남은 돈 계산).
*   **탐욕법 (Greedy Algorithm)**: 큰 단위부터 최대한 계산하고 남은 돈으로 다음 단계 진행.
*   **연산자 우선순위와 괄호**: `%` 먼저 계산 후 `/` 하려면 괄호 필수.
*   **나머지 연산 최적화**: 상위 단위가 하위 단위의 배수일 경우, `%` 연산을 더 간단하게 할 수 있음 (`m % 1000 % 500` 대신 `m % 500`).

---

### 문제 3: C언어 전역 변수와 포인터

**문제:**

다음 C언어 프로그램의 입력값이 홍길동, 김영진, 이기적의 순서일 때, 출력되는 값을 작성하시오.

```c
#include <stdio.h>
#include <stdlib.h>
char n[30]; // 전역 변수
char *test(){
    printf("이름을 입력하세요:");
    gets(n); // 전역 변수 n에 입력값 저장 (덮어쓰기)
    return n; // 전역 변수 n의 주소 반환
}
int main(){
    char* test1;
    char* test2;
    char* test3;

    test1 = test(); // n="홍길동", test1은 n 주소 가리킴
    test2 = test(); // n="김영진", test2는 n 주소 가리킴 (test1도 여전히 n 주소 가리킴)
    test3 = test(); // n="이기적", test3은 n 주소 가리킴 (test1, test2도 여전히 n 주소 가리킴)

    printf("%s\n", test1); // 현재 n의 값("이기적") 출력
    printf("%s\n", test2); // 현재 n의 값("이기적") 출력
    printf("%s", test3);  // 현재 n의 값("이기적") 출력
}
```

**답:**

```
이기적
이기적
이기적
```

**주요 포인트:**

*   **전역 변수**: 프로그램 전체에서 접근 가능, 단 하나만 존재. 함수 호출 간 값이 유지되지만 **덮어쓰기** 가능.
*   **포인터와 주소**: 함수가 변수의 **주소**를 반환. `test1`, `test2`, `test3` 모두 **동일한 전역 변수 `n`의 주소**를 가짐.
*   **`gets()` 동작**: 입력받아 지정된 버퍼(`n`)에 **덮어씀**. (위험!)
*   **`printf("%s", 포인터)`**: 포인터가 가리키는 주소의 문자열 출력. 모든 포인터가 마지막 상태의 `n`을 가리킴.

---

### 문제 4: SQL INSERT 문 작성

**문제:**

다음의 입력 필드와 값을 보고 [STUDENT] 테이블에 데이터를 삽입하기 위한 INSERT문을 작성하시오.

| 학번(int) | 이름(char(10)) | 학년(int) | 전공(char(20)) | 전화번호(char(13)) |
| :-------- | :------------- | :-------- | :------------- | :----------------- |
| 123456    | 이영진         | 4         | 컴퓨터         | 010-1234-5678      |

**답:**

```sql
INSERT INTO STUDENT (학번, 이름, 학년, 전공, 전화번호)
VALUES (123456, '이영진', 4, '컴퓨터', '010-1234-5678');
```

**주요 포인트:**

*   **`INSERT INTO` 문법**: `INSERT INTO 테이블명 (컬럼 목록) VALUES (값 목록);`
*   **순서 매칭**: 컬럼 목록 순서와 값 목록 순서 일치 필수.
*   **데이터 타입과 값 표기**:
    *   숫자(int): 따옴표 없이.
    *   문자열(char): **작은따옴표(`'`)**로 감싸기 필수.
*   **세미콜론 (`;`)**: 문장 끝 표시.

---

### 문제 5: C언어 switch문과 fall-through

**문제:**

다음 C언어 프로그램의 출력 결과를 작성하시오.

```c
#include <stdio.h>
int main(void){
    int array[3] = {70, 85, 98};
    int sum = 0;

    for (int i = 0; i < 3; i++){
        sum += array[i]; // sum = 70 + 85 + 98 = 253
    }

    switch(sum/30){ // switch(253 / 30) -> switch(8)
        case 10:
        case 9: printf("A");
        case 8: printf("B"); // 여기 걸림, "B" 출력. break 없음!
        case 7:
        case 6: printf("C"); // 아래로 흘러서 "C" 출력. break 없음!
        default: printf("D"); // default까지 흘러서 "D" 출력.
    }
    return 0;
}
```

**답:**

```
BCD
```

**주요 포인트:**

*   **배열 합계 계산**: `for`문과 `+=` 연산자 활용.
*   **정수 나눗셈**: 결과는 정수 (소수점 버림). `253 / 30 = 8`.
*   **`switch` 문**: 특정 값(`8`)에 해당하는 `case` 실행.
*   **`break` 문의 중요성 (Fall-through)**: `case` 끝에 `break;` 없으면 다음 `case`나 `default`로 실행 흐름이 넘어감. 이 문제의 핵심 함정.
*   **`default`**: 일치하는 `case` 없거나, `break` 없이 흘러내려오면 실행됨.

---

### 문제 6: 테스트 커버리지 종류

**문제:**

다음의 테스트 커버리지를 무엇이라 하는지 <보기>를 참고하여 작성하시오.

*   전체 조건식의 결과와 관계없이 각 개별 조건식이 참 한 번, 거짓 한 번을 모두 갖도록 조합하는 것
*   결정 커버리지보다 강력한 형태의 커버리지

**<보기>**

```
Statement Coverage, Decision Coverage, Condition Coverage, Condition/Decision Coverage, Modify Condition/Decision Coverage, Multiple Condition Coverage
```

**답:** Condition Coverage (조건 커버리지)

**주요 포인트:**

*   **테스트 커버리지**: 테스트가 소스 코드의 어느 부분을 얼마나 커버했는지 측정하는 지표.
*   **조건 커버리지 (Condition Coverage)**: 조건문 내 **개별 조건식** 각각이 최소 한 번은 **참(True)/거짓(False)** 값을 갖도록 테스트.
*   **결정 커버리지와 비교**: 결정 커버리지(전체 결과 T/F)보다 내부 조건까지 따져 더 높은 수준.
*   **커버리지 강도**: 구문 < 결정 < **조건** < 조건/결정 < 변경 조건/결정 < 다중 조건 순서로 강해짐.

---

### 문제 7: C언어 4의 배수 개수 세기

**문제:**

다음 C언어 프로그램의 출력 결과를 작성하시오.

```c
#include <stdio.h>
int main() {
    int s= 0;
    for(int i = 1; i <= 2023; i++){ // 1부터 2023까지 반복
        if(i % 4 == 0) s++; // i가 4의 배수이면 s 증가
    }
    printf("%d", s); // 최종 s 값 출력
}
```

**답:**

```
505
```

**주요 포인트:**

*   **`for` 반복문**: 1부터 2023까지 순회.
*   **`%` (모듈러 연산자)**: `i % 4 == 0`은 `i`가 4의 배수인지 확인.
*   **카운터 변수**: `s`는 4의 배수 개수를 셈.
*   **범위 내 배수 개수 구하기**: 1부터 N까지 K의 배수 개수는 `N / K`의 몫과 같음 (`2023 / 4 = 505`).

---

### 문제 8: 보안 용어 - 탬퍼프루핑

**문제:**

다음이 설명하는 용어를 작성하시오

> 소프트웨어 또는 하드웨어를 외부에서의 공격이나 변경으로부터 보호하는 보안 기술 중 하나로 시스템이나 애플리케이션의 무결성을 유지하고, 외부 공격자로부터 시스템을 안전하게 보호하는 목적으로 사용된다. 특히, 보안에 중요한 역할을 하는 특정 부분이나 기능이 공격자에 의해 변경되거나 손상되는 것을 방지한다.

**답:** 탬퍼프루핑 (Tamper Proofing)

**주요 포인트:**

*   **탬퍼프루핑 (Tamper Proofing) 정의**: 허가되지 않은 사용자가 임의로 **변경/손상**시키는 것을 **방지**하는 보안 기술.
*   **핵심 목적**: **무결성(Integrity)** 보장 (원래 상태 유지).
*   **보호 대상**: 코드, 하드웨어, 데이터 등 변경되면 안 되는 것.
*   **키워드**: **변경 방지, 손상 방지, 무결성 유지, 보호**.

---

### 문제 9: C언어 스택 구현 및 실행 추적

**문제:**

다음 C언어 프로그램의 출력 결과를 작성하시오.

```c
#include <stdio.h>
#define MAX_SIZE 10

// 스택 관련 함수 (into: push, take: pop, isEmpty, isFull)
int isWhat[MAX_SIZE];
int point = -1; // 스택 top 포인터

void into(int num){ /* ... push 구현 ... */ }
int take(){ /* ... pop 구현 (LIFO, point--) ... */ }
int isEmpty(){ /* ... point == -1 체크 ... */ }
int isFull(){ /* ... point == MAX_SIZE - 1 체크 ... */ }

int main(){
    int e; // 안 쓰임
    into(5); // 스택: [5], point=0
    into(2); // 스택: [5, 2], point=1
    while(!isEmpty()){ // 스택이 빌 때까지 반복
        // Loop 1:
        printf("%d", take()); // pop 2 -> 출력: 2, 스택: [5], point=0
        into(4); // push 4 -> 스택: [5, 4], point=1
        into(1); // push 1 -> 스택: [5, 4, 1], point=2
        printf("%d", take()); // pop 1 -> 출력: 21, 스택: [5, 4], point=1
        into(3); // push 3 -> 스택: [5, 4, 3], point=2
        printf("%d", take()); // pop 3 -> 출력: 213, 스택: [5, 4], point=1
        printf("%d", take()); // pop 4 -> 출력: 2134, 스택: [5], point=0
        into(6); // push 6 -> 스택: [5, 6], point=1
        printf("%d", take()); // pop 6 -> 출력: 21346, 스택: [5], point=0
        printf("%d", take()); // pop 5 -> 출력: 213465, 스택: [], point=-1
    } // isEmpty()가 true 반환, 루프 종료
    return 0;
}
```

**답:**

```
213465
```

**주요 포인트:**

*   **스택 (Stack)**: **LIFO (Last-In, First-Out)** 자료구조.
*   **주요 연산**: `Push` (데이터 넣기), `Pop` (데이터 빼기).
*   **상태 확인**: `isEmpty`, `isFull`.
*   **배열 기반 구현**: 배열과 Top 포인터(`point`) 사용.
*   **전위/후위 증감**: `++point` (Push), `point--` (Pop) 동작 이해 중요.

---

### 문제 10: 데이터베이스 설계 순서

**문제:**

데이터베이스 설계 순서를 <보기>를 참고하여 나열하시오.

**<보기>**

```
구현, 요구조건 분석, 개념적 설계, 물리적 설계, 논리적 설계
```

**답:**

```
요구조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
```

**주요 포인트:**

*   **데이터베이스 설계 단계**: 요구사항부터 실제 DB 구축까지의 체계적 과정.
*   **순서 중요성**: 이전 단계 결과물이 다음 단계의 입력이 됨.
*   **각 단계별 핵심 활동**:
    *   요구조건 분석: 요구 파악
    *   개념적 설계: 개념 구조 모델링 (ERD 등, DBMS 독립적)
    *   논리적 설계: 논리 스키마 설계 (테이블 구조 등, 목표 DBMS 맞춤)
    *   물리적 설계: 저장 구조 결정 (성능/효율 고려)
    *   구현: 실제 DB 생성
*   **추상화 수준**: 요구조건 분석(추상적) → 구현(구체적) 순으로 구체화.

---

### 문제 11: 디자인 패턴 식별 (싱글톤, 비지터)

**문제:**

다음 설명을 보고 (1), (2)에 들어갈 알맞은 디자인 패턴을 <보기>를 참고하여 작성하시오.

> (1) : 어떤 클래스가 최대 하나의 인스턴스만을 갖도록 보장하며, 이 인스턴스에 대한 전여걱인 접근점을 제공한다. 즉, 어플리케이션 내에서 해당 클래스의 인스턴스가 오직 하나만 존재하도록 하고, 이에 대한 전역적인 접근이 가능하게 한다. 이 패턴은 전역 변수를 통한 객체 공유로 인한 문제를 방지하고, 객체의 유일성을 보장하여 일관된 상태를 유지할 수 있다.  
> (2) : 객체 구조를 변경하지 않고 새로운 동작을 추가하고자 할 때 사용된다. 이 패턴은 특정 객체 구조에 대해 각각의 구조에 대해 새로운 동작을 적용한다. 따라서 기존 객체 구조를 수정하지 않고 새로운 기능을 추가할 수 있다.

**<보기>**

```
Factory Method, Visitor, Interpreter, Singleton, Proxy, Prototype, Observer, Mememto, Bridge
```

**답:**

*   (1) : **Singleton**
*   (2) : **Visitor**

**주요 포인트:**

*   **싱글톤 패턴 (Singleton Pattern)**:
    *   목적: 인스턴스 **하나만** 생성 보장, **전역 접근점** 제공.
    *   키워드: **하나의 인스턴스**, **전역 접근점**, 유일성.
*   **비지터 패턴 (Visitor Pattern)**:
    *   목적: 객체 **구조 변경 없이 새로운 동작 추가**. 기능(Visitor)과 구조(Element) 분리.
    *   키워드: **구조 변경 없이**, **새로운 동작 추가**, 분리된 처리.

---

### 문제 12: 오류 제어 방식 식별

**문제:**

다음이 설명하는 오류 수정 방법을 <보기>를 참고하여 각각 작성하시오.

> (1) : 오류 검출 및 수정을 위한 블록 코드 중 하나로, 특히 단일 비트 오류에 대한 강력한 검출 능력을 가지고 있다. 데이터에 부가적인 비트를 추가하여 오류를 검출하고 수정할 수 있는 방식으로 동작한다.  
> (2) : 데이터 전송 중 발생할 수 있는 오류를 감지하고 수정하기 위한 기술로, 송신측에서 추가적인 정보를 전송하여 수신측에서 오류를 복구할 수 있도록 한다.  
> (3) : 전송된 데이터에 오류가 발생된 경우, 송신측에 오류 사실을 알려서 재전송으로 복원하는 방식이다.  
> (4) : 오류 검출 기술 중 하나로, 1개의 비트를 추가하여 1의 개수가 짝수/홀수인지 판단하여 오류를 검출한다.  
> (5) : 다항식 연산을 기반으로 하며, 송신자는 데이터에 대한 다항식 연산을 수행하여 나온 나머지를 추가적으로 전송한다. 수신자는 전송된 데이터와 다항식 연산을 수행하여 나온 나머지를 비교하여 오류를 감지할 수 있다.

**<보기>**

```
EAC, FEC, hamming, CRC, PDS, parity, BEC, ARQ, Sliding Window
```

**답:**

*   (1) : **hamming**
*   (2) : **FEC**
*   (3) : **BEC** (또는 ARQ도 가능하나, BEC가 더 넓은 개념)
*   (4) : **parity**
*   (5) : **CRC**

**주요 포인트:**

*   **오류 제어 분류**: 오류 검출 vs 오류 수정.
*   **오류 수정 방법**:
    *   **FEC (Forward Error Correction)**: 수신 측 스스로 수정 (잉여 정보 사용). 예: 해밍 코드.
    *   **BEC (Backward Error Correction)**: 송신 측에 알려 재전송 등으로 수정. 예: ARQ.
*   **주요 기술 특징**:
    *   패리티: 1비트 추가, 짝/홀수 검사 (검출만).
    *   CRC: 다항식 기반, 나머지 비교 (주로 검출).
    *   해밍 코드: 여러 패리티 비트, 단일 비트 오류 수정 가능.
*   **용어 구분**: FEC/BEC는 방식 총칭, 해밍/ARQ는 구체적 구현 예시.

---

### 문제 13: HDLC 프로토콜 (프레임, 모드)

**문제:**

다음 HDLC 프로토콜에 대한 설명에서 (1), (2), (3), (4), (5)에 들어갈 용어를 <보기>를 참고하여 작성하시오.

> HDLC 프로토콜에서 각기 다른 목적으로 사용되는 (1) 프레임, (2) 프레임, (3) 프레임의 유형이 있다.
>
> *   (1) 프레임은 실제 데이터를 전송하기 위해 사용된다...
> *   (2) 프레임은 흐름 제어와 오류 제어를 위해 사용된다...
> *   (3) 프레임은 특별한 통신 제어를 위해 사용된다...
>
> 또한 HDLC는 3가지 데이터 전송 모드가 있다.
>
> *   정상 응답 모드는 ...
> *   (4) 모드는 각 국이 주국이자 종국으로 서로 대등하게 균형적으로 ... 허가를 받지 않고 송신을 개시할 수 있다.
> *   (5) 모드는 종국은 주국의 허가(Poll) 없이도 송신이 가능하지만 , 제어 기능은 주국만 ...

**<보기>**

```
ㄱ. 연결제어 ㄴ. 감독 ㄷ. 정보 ㄹ. 양방향응답 ㅁ. 익명 ㅂ. 비번호 ㅅ. 릴레이 ㅇ. 동기균형 ㅈ. 동기응답 ㅊ. 비동기균형 ㅋ. 비동기응답
```

**답:**

*   (1) : **ㄷ. 정보**
*   (2) : **ㄴ. 감독**
*   (3) : **ㅂ. 비번호**
*   (4) : **ㅊ. 비동기균형**
*   (5) : **ㅋ. 비동기응답**

**주요 포인트:**

*   **HDLC 프레임**:
    *   **I-frame (`ㄷ. 정보`)**: 데이터 전송용.
    *   **S-frame (`ㄴ. 감독`)**: 흐름/오류 제어용.
    *   **U-frame (`ㅂ. 비번호`)**: 링크 관리용.
*   **HDLC 전송 모드**:
    *   **NRM**: 주국 허가 필요 (종국 전송 시).
    *   **ARM (`ㅋ. 비동기응답`)**: 종국 허가 없이 전송 가능 (제어는 주국).
    *   **ABM (`ㅊ. 비동기균형`)**: 양측 동등, 허가 없이 전송 가능.
*   **키워드 매칭**: 설명과 <보기> 용어 연결 중요.

---

### 문제 14: Java 문자열 비교 (`==` vs `.equals()`)

**문제:**

다음의 Java 프로그램의 실행 결과를 작성하시오. (코드에 `string` 오타는 `String`으로 간주)

```java
public class YoungJin {
    public static void main(String[] args) throws Exception {
        String str1 = "Programming"; // String Pool
        String str2 = "Programming"; // String Pool (str1과 같은 객체)
        String str3 = new String("Programming"); // Heap (새 객체)

        System.out.println(str1 == str2); // 주소 비교 (같음)
        System.out.println(str1 == str3); // 주소 비교 (다름)
        System.out.println(str1.equals(str3)); // 내용 비교 (같음)
        System.out.println(str2.equals(str3)); // 내용 비교 (같음)
    }
}
```

**답:**

```
true
false
true
true
```

**주요 포인트:**

*   **Java String 생성**: 리터럴(String Pool 재사용) vs `new`(무조건 새 객체).
*   **`==` 연산자**: 객체 **주소(참조)** 비교 (동일 객체인지).
*   **`.equals()` 메소드**: String 클래스에서는 **내용(값)** 비교 (동일한 문자열인지).
*   **String Pool**: 리터럴 문자열 관리 메모리 영역.

---

### 문제 15: 암호 알고리즘 분류 (대칭키 vs 비대칭키)

**문제:**

다음 <보기>를 보고 대칭키와 비대칭키를 구분하여 작성하시오.

**<보기>**

```
DES, 3-DES, RSA, SEED, ARIA, DSA, RC-4
```

**답:**

*   **대칭키:** DES, 3-DES, SEED, ARIA, RC-4
*   **비대칭키:** RSA, DSA

**주요 포인트:**

*   **대칭키 (Symmetric Key)**: 암복호화 키 동일, 속도 빠름. (DES, 3-DES, AES, SEED, ARIA, RC4 등)
*   **비대칭키 (Asymmetric Key)**: 공개키/개인키 쌍 사용, 속도 느림, 키 분배 용이, 전자서명 가능. (RSA, Diffie-Hellman, ECC, DSA 등)
*   **알고리즘 구분**: 유명 알고리즘은 이름만 보고도 구분할 수 있어야 함.

---

### 문제 16: 자료구조/알고리즘 용어 - 해시

**문제:**

다음 설명을 보고 빈칸에 들어갈 알맞은 용어를 작성하시오.

> *   (빈칸)(이)란 데이터를 저장할 때, 데이터의 키 값을 (빈칸) 함수를 사용해 (빈칸) 주소로 변환하고, 해당 주소에 데이터를 저장하는 방식이다.
> *   데이터를 찾으려면 키 값으로 (빈칸) 함수를 호출하여 (빈칸) 주소를 얻은 후, 해당 주소에 있는 데이터에 접근한다.
> *   검색 속도가 매우 빠르며, 데이터의 추가, 삭제, 검색에 용이하다.

**답:** **해시 (Hash)**

**주요 포인트:**

*   **해싱 (Hashing)**: 임의 길이 데이터를 고정 길이 **해시 값/주소**로 변환.
*   **해시 함수 (Hash Function)**: 키 -> 해시 주소 변환 함수.
*   **해시 테이블 (Hash Table)**: 해싱 사용 자료구조 (Key-Value 저장).
*   **장점**: 평균 O(1)의 빠른 검색/삽입/삭제.
*   **단점**: 충돌(Collision) 발생 가능 및 해결 필요.
*   **키워드**: **키**, **해시 함수**, **해시 주소**, **빠른 검색**.

---

### 문제 17: SQL ALTER TABLE (DROP COLUMN CASCADE)

**문제:**

다음을 보고 빈칸을 작성하여 쿼리를 완성하시오.

*   학과 테이블에서 전화번호 속성을 삭제한다. 이때 참고하고 있는 테이블이 있다면 연쇄 삭제되도록 설정한다.

```sql
<쿼리>
ALTER TABLE 학과
DROP COLUMN 전화번호 (빈칸);
```

**답:** **CASCADE**

**주요 포인트:**

*   **`ALTER TABLE`**: 테이블 구조 변경 명령어.
*   **`DROP COLUMN`**: 컬럼 삭제.
*   **`CASCADE` 옵션**: 삭제 대상(컬럼 등)을 참조하는 다른 객체(제약 조건 등)를 **연쇄적으로 함께 삭제**.
*   **`RESTRICT` 옵션**: 참조하는 객체가 있으면 삭제 중단 (기본값인 경우 많음).

---

### 문제 18: C언어 선택 정렬 구현

**문제:**

다음은 C언어로 선택 정렬을 구현한 것이다. 빈칸에 들어갈 알맞은 연산자를 작성하시오.

```c
#include <stdio.h>
// swap 함수 ...
void selectionSort(int arr[], int n){
    int i, j, min_idx;
    for (i = 0; i < n-1; i++) {
        min_idx = i; // 일단 현재 위치를 최소값 인덱스로 가정
        for (j = i+1; j < n; j++){ // i 뒤부터 끝까지 스캔
            // 현재 최소값(arr[min_idx])보다 더 작은 놈(arr[j])을 찾으면
            if(arr[j] (빈칸) arr[min_idx])
                min_idx = j; // 최소값 인덱스 갱신
        }
    swap(&arr[min_idx], &arr[i]); // 찾은 최소값을 i번째 자리와 교환
    }
}
// printArray 함수 ...
// main 함수 ...
```

**답:** **<**

**주요 포인트:**

*   **선택 정렬 (Selection Sort)**: 미정렬 부분에서 **최소값** 찾아 정렬된 부분 뒤에 붙임.
*   **동작 방식**: 최소값 찾기 -> 맨 앞(또는 정렬된 부분 끝)과 교환 -> 범위 줄여서 반복.
*   **핵심 비교**: 현재 최소값(`arr[min_idx]`)과 스캔 중인 값(`arr[j]`) 비교. 오름차순 위해선 `arr[j]`가 더 작을 때(`arr[j] < arr[min_idx]`) 갱신.
*   **시간 복잡도**: O(n²).

---

### 문제 19: 파이썬 문자열 슬라이싱

**문제:**

다음의 파이썬 프로그램의 출력 결과를 작성하시오.

```python
str = "Young Jin engineer information precessing"
# 인덱스: 01234567890123456789012345678901234567890
#                   10        20        30        40

str_1 = str[:3]       # 인덱스 0, 1, 2 -> "You"
str_2 = str[4:6]       # 인덱스 4, 5 -> "g "
str_3 = str[28:]      # 인덱스 28부터 끝까지 -> "on precessing"
str_f = str_1 + str_2 + str_3 # "You" + "g " + "on precessing"
print(str_f)
```

**답:**

```
Youg on precessing
```

**주요 포인트:**

*   **파이썬 슬라이싱**: `문자열[시작:끝]`. 시작은 포함, **끝은 미포함**.
*   **인덱스**: 0부터 시작.
*   **생략**: `[:끝]` (처음부터), `[시작:]` (끝까지).
*   **문자열 덧셈 (`+`)**: 이어붙이기 (Concatenation).
*   **공백 문자**: 하나의 문자로 취급.

---

### 문제 20: 통합 테스트 도구 (드라이버, 스텁)

**문제:**

다음이 설명하는 통합 테스트 도구를 작성하시오.

> (1) : 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하며, 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트에 필요  
> (2) : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 하향식 테스트에 필요

**답:**

*   (1) : **테스트 드라이버 (Test Driver)**
*   (2) : **테스트 스텁 (Test Stub)**

**주요 포인트:**

*   **통합 테스트**: 모듈 결합 후 상호작용 테스트.
*   **테스트 하네스**: 테스트 지원 도구 (드라이버, 스텁 포함).
*   **테스트 드라이버 (Test Driver)**:
    *   **상향식** 테스트용.
    *   테스트 대상의 **상위 모듈** 역할 (호출 주체).
*   **테스트 스텁 (Test Stub)**:
    *   **하향식** 테스트용.
    *   테스트 대상의 **하위 모듈** 역할 (호출 대상, 가짜 응답).
*   **핵심 구분**: 역할(상위/하위), 테스트 방식(상향식/하향식).

---
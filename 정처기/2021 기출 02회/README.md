# 2021 기출 02회 해설

### 1. 다음이 설명하는 네트워크 관련 용어를 영문으로 작성하시오

```
노드(node)들에 의해 자율적으로 구성되는 기반 구조가 없는 네트워크로 별도의 장치를 필요로 하지 않고 네트워크 토폴로지가 동적으로 변화되는 특징이 있으며 응용 분야로는 긴급 구조, 긴급 회의, 군사 네트워크에 활용된다.
```

이거 딱 봐도 **Ad Hoc Network** 아니냐? ㅋㅋ 설명 함 봐바.

*   **노드끼리 알아서 구성**: 중앙 통제탑 같은 거 없이 지들끼리 연결해서 망 만든다는 소리임. 이걸 '기반 구조가 없다' 라고 하는 거고.
*   **별도 장비 필요 없음**: 뭐 공유기나 스위치 이딴 거 필요 없이 폰끼리 테더링하는 거 생각하면 편함.
*   **동적 토폴로지**: 노드(기기)들이 막 움직이고, 꺼지고 켜지고 하니까 연결 구조가 계속 바뀐다는 거.
*   **응용 분야**: 갑자기 통신망 필요할 때! 예를 들어 재난 현장이나 전쟁터에서 급하게 통신해야 할 때 쓰겠지? 임시 회의 같은 거 할 때도 쓰고.

그러니까 지들끼리 알아서 붙었다 떨어졌다 하는 임시 네트워크? 그게 Ad Hoc Network 임. ㅇㅋ?

**주요 포인트 정리**

*   기반 구조 없는(Infrastructureless) 자율 구성 네트워크
*   동적인 네트워크 토폴로지 변화
*   노드 간 직접 통신 (별도 장비 불필요)
*   긴급 구조, 군사 네트워크 등 임시적이고 빠른 네트워크 구축 필요시 활용

---


### 2. 다음의 인터페이스 관련 설명에 대하여 빈칸에 알맞은 용어를 영문 약어로 작성하시오

```
(1) : 넓은 의미에서 사용자와 시스템 사이에서 의사소통을 할 수 있도록 고안된 물리적, 가상의 매개체를 뜻한다. 좁은 의미로는 정보 기기나 소프트웨어의 화면 등에서 사람이 접하게 되는 화면을 뜻한다고 할 수 있다. 기존 인터페이스의 종류를 살펴보면 명령어를 텍스트로 입력하여 조작하는 CLI, 그래픽 환경을 기반으로 한 마우스나 전자펜을 이용하는 GUI, 사람의 말과 행동으로 기기를 조작하는 NUI까지 발전하고 있다. 최근에는 사물 인터넷, 가상현실, 증강현실, 혼합현실 등의 발전과 함께 하드웨어 분야를 중심으로 OUI가 대두되고 있다.
(2) : 사용자가 어떤 시스템, 제품, 서비스를 직/간접적으로 이용하면서 느끼고 생각하게 되는 총체적 경험을 뜻한다. 산업 디자인, 소프트웨어 공학, 심리학, 마케팅, 경영학 등의 관점에서 고객을 매료시키고 가치를 높이기 위한 총체적인 접근을 뜻하기도 한다. ISO 정의에 따르면 사용자가 제품, 시스템, 서비스의 사용, 또는 기대되는 사용 결과에서 오는 인식과 반응을 의미하기도 한다
```

(1) 이거 딱 봐도 **UI (User Interface)** 아니냐? ㅋㅋ 설명 보면 '사용자랑 시스템 사이의 의사소통 매개체' 라잖아. 화면 같은 거 생각하면 됨. CLI, GUI, NUI, OUI 이런 게 다 UI 종류고. OUI는 Organic UI 말하는 거 같은데, 요즘 뜨는거지. 암튼 사용자가 보는 화면, 조작하는 방식 전부 UI임. 쉽지?

(2) 이건 뭐... '총체적 경험' 이거 나오면 거의 **UX (User Experience)** 지 ㅋㅋ 사용자가 뭘 쓰면서 느끼는 모든 감정, 생각, 만족도 이런 걸 다 합친 거임. 단순히 예쁘고 쓰기 편한 걸 넘어서 '아 이거 진짜 괜찮네' 싶은 그런 경험 전체를 말하는 거. UI가 '어떻게 보이냐, 어떻게 쓰냐' 라면 UX는 '그래서 어떤 느낌이냐' 이거임.

**주요 포인트 정리**

*   **UI (User Interface)**: 사용자와 시스템 간의 상호작용을 위한 매개체 (화면, 입력 방식 등). CLI, GUI, NUI, OUI 등이 있음.
*   **UX (User Experience)**: 사용자가 시스템, 제품, 서비스를 사용하면서 느끼는 총체적인 경험 (인식, 반응, 만족도 등).

---


### 3. 트랜잭션의 특성 ACID 중 원자성(Atomicity)에 대해서 간단하게 서술하시오

걍 **'All or Nothing'** 이거 하나만 기억하면 됨.

트랜잭션이라는 게 보통 여러 개 작업 묶음이잖아? 돈 보내는 거 생각해봐. 니 통장에서 돈 빼는 작업(1) + 친구 통장에 돈 넣는 작업(2) 이게 한 트랜잭션임.

원자성은 이 작업들이 **전부 다 성공**하거나, 아니면 **하나라도 실패하면 싹 다 취소**하고 원래대로 돌리는 거임. 부분만 성공? 그딴 거 없음 ㅋㅋ 무조건 한 몸으로 움직여야 됨.

니 통장에서 돈만 빠져나가고 친구한테 안 들어갔다? 그럼 개빡치지 ㅋㅋ 원자성은 그런 꼴을 막아주는 거임. 작업 1, 2가 다 성공해야 '커밋(Commit)' 해서 진짜 반영하고, 하나라도 실패하면 '롤백(Rollback)' 해서 아예 없던 일로 만들어버림.

**주요 포인트 정리**

*   트랜잭션 내의 모든 작업은 **전부 성공**하거나 **전부 실패**해야 함 (All or Nothing).
*   작업 중 하나라도 실패하면 트랜잭션 전체가 **취소(Rollback)**되고 이전 상태로 복구됨.
*   모든 작업이 성공해야만 **최종 반영(Commit)**됨.
*   트랜잭션의 작업을 **하나의 단위**로 취급함.

---


### 4. 다음은 데이터베이스 정규화의 과정의 일부분을 설명한 것이다. 빈칸에 들어갈 정규형을 작성하시오

```
[학생]
| 학번 | 과목명 | 강의실 | 학점 |
| 101 | 프로그래밍 | 301 | A |
| 102 | 이산수학 | 302 | A |
| 103 | 프로그래밍 | 301 | B |
| 101 | 인공지능 | 303 | C |
| 102 | 프로그래밍 | 301 | B |
```
어떤 릴레이션 R이 있을 때 X와 Y를 각각 속성의 부분집합이라고 가정한다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y값이 달라질 때, Y는 X에 함수적 종속이라고 하며 이 경우 X를 결정자, Y를 종속자라고 한다. 이를 기호로 표현하면 X → Y이다.
[학생] 테이블의 대표적인 종속성을 표현하면 다음과 같다.
```
(학번, 과목명) → 강의실
(학번, 과목명) → 학점
과목명 → 강의실
```
따라서 [학생] 테이블은 '(학번, 과목명) → 강의실'과 '과목명 → 강의실'의 함수적 종속이 존재하여 부분함수 종속에 있다고 할 수 있다. 이러한 부분함수 종속을 제거하면 제( ) 정규형이 되며 다음과 같이 테이블이 나누어진다.
```
[학생]
| 학번 | 과목명 | 학점 |
| 101 | 프로그래밍 | A |
| 102 | 이산수학 | A |
| 103 | 프로그래밍 | B |
| 101 | 인공지능 | C |
| 102 | 프로그래밍 | B |

[학생]
| 과목명 | 강의실 |
| 프로그래밍 | 301 |
| 이산수학 | 302 |
| 인공지능 | 303 |
```

자 봐봐. 기본키가 (학번, 과목명) 이거 두 개 묶은 거잖아? 근데 `강의실`은 `과목명`만 알면 바로 튀어나옴 (`과목명 → 강의실`). 즉, 기본키 전체 (`학번`, `과목명`)가 아니라 기본키 *일부*인 `과목명`에 `강의실`이 종속된 거지. 이걸 '부분 함수 종속'이라고 부름.

정규화 과정에서 이 **부분 함수 종속**을 제거하는 단계가 바로 **제2정규형(2NF)** 만드는 거임. 표 쪼개진 거 봐도 딱 맞지? `과목명`이랑 `강의실` 따로 떼어냈잖아 ㅋㅋ

그래서 빈칸에 들어갈 말은 숫자 **2**임.

**주요 포인트 정리**

*   **제2정규형(2NF)**: 제1정규형을 만족하고, 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**되도록 (즉, **부분 함수 종속**을 제거) 한 정규형.
*   **부분 함수 종속**: 기본키가 여러 속성으로 구성되어 있을 때, 기본키가 아닌 속성이 기본키의 **일부 속성**에만 종속되는 경우.
*   위 예시에서는 `강의실`이 기본키 `(학번, 과목명)`의 일부인 `과목명`에 종속(`과목명 → 강의실`)되므로 부분 함수 종속임. 이를 분리하여 2NF를 만족시킴.

---


### 5. 다음의 [학생] 테이블에서 이름이 '이하린'인 학생의 '점수'를 95점으로 변경하는 SQL문에 들어갈 (1)과 (2)를 완성하시오

```
[학생]
| 학번 | 이름 | 학년 | 나이 | 점수 |
| 2012345 | 우진영 | 3 | 24 | 77 |
| 2185732 | 김진영 | 3 | 22 | 86 |
| 2258362 | 이하린 | 2 | 21 | 90 |
| 1927462 | 최진용 | 4 | 26 | 91 |
```
```
<SQL문>
(1) 학생 (2) 점수 = 95 WHERE 이름 = '이하린';
```

테이블에 있는 값 고치는 SQL 명령어는 **UPDATE** 임. 그러니까 (1)번은 **UPDATE** 고.
어떤 값을 뭘로 바꿀지 지정하는 건 **SET** 임. `SET 컬럼명 = 바꿀값` 이렇게 쓰는 거지. (2)번은 **SET** 이네.
마지막 `WHERE`는 조건이니까 '이름'이 '이하린'인 애만 골라서 바꾸라는 뜻이고.

그래서 완성하면 `UPDATE 학생 SET 점수 = 95 WHERE 이름 = '이하린';` 이거임. 이하린 점수 90점에서 95점으로 ㄱㄱ

**주요 포인트 정리**

*   **UPDATE**: 테이블의 **기존 데이터**를 수정하는 SQL 명령어.
*   **SET**: `UPDATE` 문 내에서 변경할 **컬럼과 새로운 값**을 지정하는 절.
*   **WHERE**: `UPDATE` 문에서 수정할 **행(row)을 특정**하기 위한 조건절.

---


### 6. 다음 [직원]과 [전화번호] 테이블을 결합하여 'EMP_NAME'과 'EMP_NUMBER'를 출력하도록 SQL문 (1), (2)를 완성하시오

```
[직원]
| EMP_NO | EMP_NAME | EMP_DEPT | EMP_SAL |
| 100 | 김성모 | 총무 | 2500 |
| 200 | 이재후 | 총무 | 3100 |
| 300 | 이준형 | 인사 | 2900 |
| 400 | 성우람 | 인사 | 2700 |
| 500 | 홍찬중 | 기획 | 2800 |

[전화번호]
| EMP_DEPT | EMP_NUMBER |
| 총무 | 820-1234 |
| 인사 | 890-4321 |
| 기획 | 820-9876 |
```
```
<SQL문>
SELECT EMP_NAME, EMP_NUMBER
FROM 직원 A JOIN 전화번호 B
(1) A.EMP_DEPT = B.(2)
```

두 테이블 `직원`(A)이랑 `전화번호`(B)를 합쳐야 하는데, 뭘 기준으로 합치겠냐? 딱 보니 `EMP_DEPT` (부서)가 양쪽에 다 있네. 이걸로 연결하는 거임.

SQL에서 테이블 합칠 때 `JOIN` 쓰고, 어떤 조건으로 합칠지는 `ON` 다음에 써줌. 그러니까 (1)번은 **ON** 임.

`ON` 다음에는 'A 테이블의 뭐랑 B 테이블의 뭐랑 같은 걸 찾아라~' 이렇게 써야지. 지금은 `A.EMP_DEPT`랑 `B.EMP_DEPT`가 같은 걸 찾아야 하니까 (2)번은 **EMP_DEPT** 가 되는 거임.

그래서 완성하면 이거지:
```sql
SELECT EMP_NAME, EMP_NUMBER
FROM 직원 A JOIN 전화번호 B
ON A.EMP_DEPT = B.EMP_DEPT;
```
이렇게 하면 직원 이름이랑 그 직원이 속한 부서의 전화번호가 같이 딱! 나오겠지 ㅋㅋ

**주요 포인트 정리**

*   **JOIN**: 두 개 이상의 테이블을 특정 조건에 따라 연결하여 하나의 결과 집합으로 만드는 SQL 명령어.
*   **ON**: `JOIN` 절에서 테이블 연결 조건을 명시하는 키워드.
*   **공통 컬럼**: JOIN 시 연결의 기준이 되는, 두 테이블에 공통으로 존재하는 컬럼 (예: `EMP_DEPT`).
*   **테이블 별칭(Alias)**: `FROM` 절에서 테이블 이름 뒤에 별칭(A, B 등)을 부여하여 SQL문 내에서 테이블 이름을 간결하게 표현.

---


### 7. 다음 Python 프로그램의 실행 결과를 작성하시오

```python
a = 100
result = 0
for i in range(1, 3):
    result = a >> i
    result = result + 1
print(result)
```

1.  `a = 100`, `result = 0` 초기값 세팅. 오키.
2.  `for i in range(1, 3):` 이거 `i`가 1일 때 한 번, 2일 때 한 번, 총 두 번 돈다는 소리임. 3은 포함 안됨 ㅋㅋ
3.  **첫 번째 루프 (i = 1):**
    *   `result = a >> i` => `result = 100 >> 1`
        *   `>>` 이거 비트 오른쪽으로 밀라는 거잖아. 100을 이진수로 바꾸면 `01100100` 임.
        *   오른쪽으로 1칸 밀면 `00110010` 이게 되고, 십진수로는 50임. (걍 2로 나눈 몫이라고 생각해도 편함 ㅋㅋ)
        *   그래서 `result`는 50이 됨.
    *   `result = result + 1` => `result = 50 + 1 = 51`. 현재 `result`는 51.
4.  **두 번째 루프 (i = 2):**
    *   `result = a >> i` => `result = 100 >> 2`
        *   100 (`01100100`)을 오른쪽으로 2칸 밀면 `00011001` 이게 되고, 십진수로는 25임. (걍 4로 나눈 몫 ㅋㅋ)
        *   그래서 `result`는 25가 됨. (아까 51이었던 거 덮어쓰는 거임!)
    *   `result = result + 1` => `result = 25 + 1 = 26`. 현재 `result`는 26.
5.  루프 끝났네?
6.  `print(result)` 하니까 마지막 `result` 값인 **26**을 출력하고 끝남.

**주요 포인트 정리**

*   **`range(start, stop)`**: `start`부터 `stop-1`까지의 숫자를 생성. `range(1, 3)`은 1, 2를 생성.
*   **`>>` (Right Bitwise Shift)**: 피연산자의 비트를 오른쪽으로 지정된 수만큼 이동. `x >> n`은 `x`를 `2^n`으로 나눈 몫과 거의 동일.
*   **Loop Variable Overwriting**: 루프 내에서 `result` 변수는 매번 새로운 값으로 갱신됨. 최종 출력은 루프가 끝난 후의 마지막 값.

---


### 8. DES 암호화 알고리즘을 대체하는 미국 표준 대칭키 알고리즘으로 블록 크기는 128비트이고 키의 길이는 128, 192, 256bit의 가변 크기를 갖는 SPN 구조의 비밀키 암호화 기법을 무엇이라 하는지 영문 약어로 작성하시오

설명 함 보자고.

*   **DES 대체**: 예전에 쓰던 DES가 좀 약해져서 새로 만든 거 맞음.
*   **미국 표준**: NIST (미국 국립표준기술연구소) 에서 공모해서 뽑은 표준 맞음.
*   **대칭키**: 암호화/복호화에 같은 키 쓰는 방식. 비밀키라고도 하지. 이것도 맞고.
*   **블록 크기 128비트**: 데이터 128비트 단위로 잘라서 암호화함. 스펙 딱 맞네.
*   **키 길이 128, 192, 256비트**: 키 길이를 이 세 가지 중에 골라 쓸 수 있음. 가변 길이 ㅇㅋ.
*   **SPN 구조**: 내부적으로 Substitution(치환)이랑 Permutation(순열) 반복하는 구조. 이것도 AES 특징임.

그러니까 답은 **AES** 임. Advanced Encryption Standard 의 약자지 ㅋㅋ

**주요 포인트 정리**

*   DES(Data Encryption Standard)를 대체한 미국 표준 대칭키 알고리즘.
*   블록 크기: 128비트 고정.
*   키 길이: 128, 192, 256 비트 중 선택 가능 (가변).
*   SPN(Substitution-Permutation Network) 구조 기반.
*   대칭키(비밀키) 암호화 방식.

---


### 9. 다음은 테스트 수준을 결정하기 위한 대표적인 코드 커버리지에 대한 설명이다. 빈칸에 들어갈 알맞은 커버리지를 순서대로 작성하시오

```
소프트웨어의 테스트를 논할 때 얼마나 테스트가 충분한가를 나타내는 지표 중의 하나이다. 말 그대로 코드가 얼마나 커버되었느냐, 즉 소프트웨어 테스트를 진행했을 때 코드 자체가 얼마나 실행되었냐는 것이다.

1. 테스트 대상인 프로그램의 코드 구조
- 테스트 대상의 코드 구조는 (1), (2), (3)이다. 이러한 구조를 얼마나 커버했느냐에 따라 코드 커버리지의 측정 기준은 나뉘게 된다.
① (1) 커버리지는 실행 코드 라인이 한 번 이상 실행되면 충족된다.
② (2) 커버리지는 각 내부 조건이 참 또는 거짓을 가지면 충족된다.
③ (3) 커버리지는 각 분기의 내부 조건 자체가 아닌 이러한 조건으로 인해 전체 결과각 참 또는 거짓이면 충족된다.

2. 테스트 수준의 커버리지를 측정하는 방법
- 사람이 로그를 찍어 가거나 디버거를 이용하여 볼 수는 있으나 매우 힘든 과정이다. 시중에는 많은 코드 커버리지 측정 도구가 나와 있으며, 대표적인 도구로 LDRA, VectorCAST 등이 있다.
```

코드 커버리지는 테스트 얼마나 잘했는지 보는 지표인데, 코드가 얼마나 실행됐냐 이거임.

1.  **코드 구조:** 니가 짠 코드는 기본적으로 문장(구문), 조건, 결정(분기) 이런 걸로 이루어져 있잖음? 이걸 얼마나 커버했냐로 따지는 거임.

    *   ① **(1) 구문 (Statement) 커버리지**: 걍 코드 한 줄 한 줄 실행했냐 안 했냐 이거임. 모든 라인 최소 한 번은 지나가면 OK. 제일 기본빵.
    *   ② **(2) 조건 (Condition) 커버리지**: `if (a > 5 and b < 10)` 이런 거 있을 때, `a > 5` 가 참/거짓 둘 다 나와봤는지, *그리고* `b < 10` 도 참/거짓 둘 다 나와봤는지 보는 거임. 내부 조건 하나하나 다 따지는 거라 좀 빡셈.
    *   ③ **(3) 결정 (Decision) 커버리지**: 이건 ②랑 좀 다른데, 내부 조건 하나하나 말고 `(a > 5 and b < 10)` 이 *통째로* 참(True)인 경우랑 거짓(False)인 경우가 둘 다 있었는지 보는 거임. 이걸 '분기 커버리지'라고도 함. 내부 조건 결과는 상관 없고 최종 결과만 봄.

그래서 순서대로 **구문, 조건, 결정** 임. ㅇㅋ?

**주요 포인트 정리**

*   **구문 (Statement) 커버리지**: 모든 실행 가능한 코드 라인이 최소 한 번 이상 실행되었는지 측정.
*   **조건 (Condition) 커버리지**: 결정(분기)문 내의 각 개별 조건식(sub-expression)이 참(True)과 거짓(False)을 모두 가져봤는지 측정.
*   **결정 (Decision) 커버리지 (분기 커버리지)**: 전체 결정(분기)문의 결과가 참(True)과 거짓(False)을 모두 가져봤는지 측정.

---


### 10. 다음의 [학생] 테이블에서 성이 '이'인 학생들의 '이름', '나이', '학과'를 '나이'의 내림차순으로 정렬하여 출력하는 SQL문을 완성하시오

```
[학생]
| 학번 | 이름 | 나이 | 학과 |
| 1001 | 천은지 | 21 | 컴퓨터 |
| 1002 | 김영진 | 26 | 인공지능 |
| 1003 | 이신우 | 23 | 사회복지 |
| 1004 | 오재신 | 27 | 국문 |
| 1005 | 안상훈 | 20 | 경영 |
```
```
<SQL문>
SELECT 이름, 나이, 학과 FROM 학생
WHERE 이름 LIKE (1) ORDER BY 나이 (2);
```

`[학생]` 테이블에서 '이'씨 성 가진 애들 찾아서 '이름', '나이', '학과' 뽑고, '나이' 많은 순서대로 보여달라는 거네.

*   **(1) `WHERE 이름 LIKE (1)`**: '이'씨 성 찾는 거니까 `LIKE` 써야지. '이'로 시작하는 모든 문자열 찾으려면 `'이%'` 이렇게 패턴 쓰면 됨. `%`가 뒤에 아무거나 와도 된다는 뜻이거든. 그러니까 (1)번은 **`'이%'`** 임.
*   **(2) `ORDER BY 나이 (2)`**: '나이' 기준으로 정렬하는데 '내림차순'으로 하랬지? 큰 거부터 작은 거 순서. SQL에서는 이걸 **`DESC`** 라고 씀. 오름차순은 `ASC`고. 그래서 (2)번은 **`DESC`** 임.

다 합치면 이렇게 되겠네:
```sql
SELECT 이름, 나이, 학과 FROM 학생
WHERE 이름 LIKE '이%' ORDER BY 나이 DESC;
```
이러면 '이신우' 학생 정보가 딱 나오겠구만.

**주요 포인트 정리**

*   **`LIKE`**: 문자열 패턴 매칭을 위한 SQL 연산자.
*   **`%` (Wildcard)**: `LIKE`와 함께 사용되며, 0개 이상의 임의의 문자를 의미하는 와일드카드. `'이%'`는 '이'로 시작하는 모든 문자열을 찾음.
*   **`ORDER BY`**: 결과 집합을 특정 컬럼(들) 기준으로 정렬하는 SQL 절.
*   **`DESC`**: `ORDER BY` 절에서 내림차순(큰 값부터 작은 값 순)으로 정렬하도록 지정하는 키워드. (Ascending은 `ASC`).

---

### 11. 다음이 설명하는 응집도에 대하여 빈칸에 들어갈 알맞은 응집도 수준을 <보기>를 보고 작성하시오

```
- (1) 응집도는 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우이다.
- (2) 응집도는 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우이다.
- (3) 응집도는 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우이다. 구조도 최하위 모듈에서 많이 발견된다.
```
```
<보기>
기능적, 순차적, 통신적, 절차적, 시간적, 논리적, 우연적
```

내가 잠깐 착각했네. 설명 다시 보자.

*   **(1) 응집도는 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우이다.**
    *   내가 '순차적'이라는 단어에 꽂혀서 '순차적 응집도'라고 했는데, **절차적 응집도**가 더 정확한 설명임. 왜냐면 '순차적 응집도'는 **A 결과가 B의 입력**이 되는 딱 그런 관계여야 하는데, '절차적 응집도'는 단순히 **실행 순서**가 정해져 있어서 묶인 걸 말하거든. 여러 기능이 순서대로 처리된다는 설명은 절차적 응집도가 맞음. 미안하다 ㅋㅋ
*   **(2) 응집도는 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우이다.**
    *   이건 **통신적 응집도** 맞음. 같은 데이터 쓰는 놈들 모아놓은 거.
*   **(3) 응집도는 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우이다.**
    *   이건 **기능적 응집도** 맞음. 제일 좋은 거. 한 놈이 한 가지 일만 딱!

아 다시 정리한다. 답은 **절차적, 통신적, 기능적** 순서가 맞다. 내가 틀림 ㅈㅅ;;

**주요 포인트 정리**

*   **절차적(Procedural) 응집도**: 모듈 내 구성 요소들이 특정 **실행 순서**에 따라 수행되어야 할 때 (단순히 순서만 중요, 데이터 흐름은 필수가 아님).
*   **통신적(Communicational) 응집도**: 동일한 입력 데이터를 사용하거나 동일한 출력 데이터를 생성하는 활동들이 모여 있는 경우.
*   **기능적(Functional) 응집도**: 모듈 내부의 모든 기능 요소들이 단일 문제 또는 기능을 수행하기 위해 구성된 경우 (가장 이상적인 응집도).

---


### 12. 다음의 패킷 교환(Packet Switching) 방식에 대한 설명의 빈칸 (1), (2)에 들어갈 알맞은 방식을 작성하시오

```
① (1) 방식 : 단말기 상호 간에 논리적인 가상 통신회선을 미리 설정하여 송수신자 사이의 연결을 확립한 후에 설정된 경로를 따라 패킷들을 순서적으로 운반하는 방식이다.
② (2) 방식 : 연결 경로를 설정하지 않고 인접한 노드들의 트래픽 상황을 감안하여 각각의 패킷들을 순서에 상관없이 독립적으로 운반하는 방식이다.
```

① 번 설명 봐봐. **"가상 통신회선 미리 설정"**, **"연결 확립"**, **"설정된 경로 따라 순서대로"** 이게 핵심임. 걍 전화 거는 거랑 비슷하다고 생각해. 미리 길 터놓고 그 길로만 데이터(패킷) 보내는 거임. 순서대로 착착 도착함. 이걸 **가상회선 (Virtual Circuit)** 방식이라고 부름.

② 번 설명은? **"연결 경로 설정 안 함"**, **"각각 패킷 순서 상관없이 독립적으로"** 이게 포인트. 이건 걍 편지 보내는 거랑 비슷함. 패킷마다 주소만 딱 적어서 던지면 알아서 중간 라우터들이 최적 경로 찾아서 보내는 거임. 그래서 패킷들이 서로 다른 길로 갈 수도 있고, 도착 순서도 뒤죽박죽일 수 있음. 이걸 **데이터그램 (Datagram)** 방식이라고 함.

그러니까 (1)은 **가상회선**, (2)는 **데이터그램** 임. 쉽지? ㅋㅋ

**주요 포인트 정리**

*   **(1) 가상회선 (Virtual Circuit) 방식**:
    *   연결 지향형 (Connection-oriented).
    *   데이터 전송 전 논리적 연결 (가상 회선) 설정.
    *   모든 패킷은 설정된 동일 경로를 통해 순서대로 전송됨.
*   **(2) 데이터그램 (Datagram) 방식**:
    *   비연결 지향형 (Connectionless).
    *   사전 연결 설정 없이 각 패킷이 독립적으로 라우팅됨.
    *   패킷마다 다른 경로로 전송될 수 있으며, 도착 순서가 보장되지 않음.

---


### 13. 다음의 디자인 패턴에 대한 설명에 대하여 빈칸에 들어갈 알맞은 용어를 작성하시오

```
디자인 패턴은 객체지향 프로그래밍 시 발생하는 여러 가지 문제에 대한 설계 사례를 분석하여 공통적으로 발생하는 문제를 해결하기 위한 방법론으로, 여러 설계들로 분류하고 각 문제 유형별로 가장 적합한 설계를 일반화한 패턴이다.
GoF 디자인 패턴은 1995년 Erich Gamma, Richard Helm, Ralph Johnson, John Vissides가 처음으로 디자인 패턴을 구체화하여 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴이 되었다. 이는 구현 방식에 따라 생성, ( ), 행위 3가지로 분류한다.
( ) 클래스 패턴은 상속을 통해 클래스나 인터페이스를 합성하고, ( ) 객체 패턴은 객체를 합성하는 방법을 정의한다.
( ) 패턴의 종류에는 Adaptor, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 등이 있다.
```

딱 보니까 생성 패턴, 행위 패턴 있고 하나 비었네? 나머지 하나는 **구조 (Structural)** 패턴이지 ㅋㅋ

설명 봐봐. 클래스랑 객체 어떻게 *합쳐서* 더 큰 구조 만드냐 이거잖아. 클래스 패턴은 상속 써서 합치고, 객체 패턴은 객체끼리 조합하고. 암튼 '구조' 만드는 방법 알려주는 거임.

거기 예시로 나온 Adaptor, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 이런 애들 다 구조 패턴 맞음 ㅇㅇ.

그래서 빈칸은 전부 **구조** 들어가면 됨.

**주요 포인트 정리**

*   GoF 디자인 패턴은 **생성(Creational), 구조(Structural), 행위(Behavioral)** 세 가지로 분류됨.
*   **구조(Structural) 패턴**: 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴.
    *   **클래스 구조 패턴**: 상속을 통해 클래스나 인터페이스를 합성.
    *   **객체 구조 패턴**: 객체 합성을 통해 새로운 기능을 얻는 방법 정의.
*   주요 구조 패턴 예시: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.

---


### 14. 트랜잭션들이 데이터를 액세스하기 전에 데이터 접근을 요청해서 허락되어야만 데이터에 액세스할 수 있도록 하는 병행 제어 기법을 무엇이라 하는지 작성하시오

데이터 쓰기 전에 '나 이거 써도 됨?' 물어보고, 'ㅇㅇ 써라' 허락받아야 쓸 수 있다는 거잖아. 이게 바로 **로킹 (Locking)** 기법임.

트랜잭션이 특정 데이터에 접근하려고 할 때 먼저 '락(Lock)'을 걸어달라고 요청함. 다른 놈이 이미 락 걸어놨거나 하면 기다려야 되고, 락 걸 수 있으면 그때 접근하는 거지. 니가 데이터 쓸 동안 다른 놈들 못 건드리게 딱! 잠가버리는 거임. 니 작업 끝나면 락 풀어주고.

뭐 공유 락(Shared Lock), 베타 락(Exclusive Lock) 이런 종류가 있는데, 암튼 핵심은 '잠금'임. ㅇㅋ?

**주요 포인트 정리**

*   데이터 접근 전 잠금(Lock) 요청 및 허가 필요.
*   잠금을 통해 특정 데이터에 대한 접근을 제어.
*   다른 트랜잭션은 잠금이 해제될 때까지 해당 데이터 접근이 제한될 수 있음.
*   대표적인 병행 제어 기법 중 하나.

---


### 15. 다음은 소프트웨어 시스템의 3가지 관점에 대한 설명이다. <보기>를 보고 빈칸 (1), (2), (3)을 작성하시오

```
- (1) Space : 주어진 입력에 대하여 어떤 결과가 나오는가를 보여주는 관점이며 연산과 제약 조건을 자료흐름도에 의하여 도식적으로 나타난다.
- (2) Space : 시간의 변화에 따른 시스템의 동작과 제어에 초점을 맞추어 시스템의 상태와 상태를 변하게 하는 원인을 묘사하는 것으로 상태변화도(STD)를 사용하여 표현한다.
- (3) Space : 시스템의 정적인 정보 구조를 포학하는 데 사용되므로 데이터베이스를 분석하는 데 많이 사용되며 ER 모델 또는 EER 모델이 대표적인 도구이다.
```
```
<보기>
Logical, Physical, Dynamic, Object, Comunication, Function, Information, Validation
```

이거 시스템 분석할 때 어떤 측면에서 볼 거냐~ 이거잖아.

*   **(1) Space : 주어진 입력에 대하여 어떤 결과가 나오는가를 보여주는 관점이며 연산과 제약 조건을 자료흐름도에 의하여 도식적으로 나타난다.**
    *   '입력 -> 결과', '연산', '자료흐름도(DFD)' 딱 보니까 뭐 하는 놈인지, 즉 **기능(Function)**에 초점 맞춘 거 아니냐? ㅋㅋ 시스템이 어떤 기능을 수행하느냐 이거지. <보기>에 **Function** 있네.
*   **(2) Space : 시간의 변화에 따른 시스템의 동작과 제어에 초점을 맞추어 시스템의 상태와 상태를 변하게 하는 원인을 묘사하는 것으로 상태변화도(STD)를 사용하여 표현한다.**
    *   '시간 변화', '동작', '상태', '상태변화도(STD)' 나왔네. 이건 시간 흐름에 따라 시스템이 어떻게 변하고 움직이는지 보는 거지. **동적(Dynamic)** 관점임. <보기>에 **Dynamic** 있다.
*   **(3) Space : 시스템의 정적인 정보 구조를 포학하는 데 사용되므로 데이터베이스를 분석하는 데 많이 사용되며 ER 모델 또는 EER 모델이 대표적인 도구이다.**
    *   '정적인 정보 구조', '데이터베이스 분석', 'ER 모델' 나왔으면 빼박이지 ㅋㅋ 시스템이 다루는 데이터, 즉 **정보(Information)**가 어떻게 구성되어 있는지 보는 관점임. <보기>에 **Information** 있네.

그래서 순서대로 **Function, Dynamic, Information** 임.

**주요 포인트 정리**

*   **(1) 기능(Function) 관점**: 시스템이 무엇을 하는가? (입력, 처리, 출력 중심, DFD 사용)
*   **(2) 동적(Dynamic) 관점**: 시스템이 어떻게 동작하고 변화하는가? (상태, 이벤트, 제어 흐름 중심, STD 사용)
*   **(3) 정보(Information) 관점**: 시스템이 다루는 데이터는 무엇인가? (데이터 구조, 관계 중심, ERD/EERD 사용)

---


### 16. 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
int mp(int base, int exp){
    int res = 1;
    for(int i = 0; i < exp; i++){
        res = res * base;
    }
    return res;
}
int main(void){
    int res;
    res = mp(2, 10);
    printf("%d", res);
    return 0;
}
```

먼저 `main` 함수부터 봐야지.

1.  `int res;` : `res`라는 정수 변수 만듦.
2.  `res = mp(2, 10);` : `mp` 함수 호출하는데, `base`에는 2, `exp`에는 10 넣어서 돌리고 그 결과값을 `res`에 저장하래.
3.  `printf("%d", res);` : `res`에 저장된 값 출력하라는 거.
4.  `return 0;` : 프로그램 끝.

자 이제 `mp(int base, int exp)` 함수를 보자.

1.  `int res = 1;` : `res` 변수 만들고 1로 초기화.
2.  `for(int i = 0; i < exp; i++)`: `i`가 0부터 `exp - 1`까지 돌면서 반복함. 지금 `exp`가 10이니까, `i`는 0부터 9까지 총 10번 도네.
3.  `res = res * base;`: 루프 돌 때마다 `res`에 `base`를 곱해줌. `base`는 2니까, `res`에 계속 2를 곱하는 거임.
4.  `return res;`: 루프 다 돌고 최종 `res` 값 반환.

그럼 `mp(2, 10)`이 뭘 하는 거냐?
`res`가 1에서 시작해서 2를 10번 곱하는 거네.
1 \* 2 = 2
2 \* 2 = 4
4 \* 2 = 8
8 \* 2 = 16
16 \* 2 = 32
32 \* 2 = 64
64 \* 2 = 128
128 \* 2 = 256
256 \* 2 = 512
512 \* 2 = 1024

오케이, 10번 곱하니까 1024가 나왔네. 이게 `mp` 함수의 반환값이고, `main` 함수의 `res` 변수에 저장됨.
마지막에 `printf`로 `res` 찍으니까 **1024**가 출력되겠네. ㅋㅋ 이거 걍 2의 10제곱 구하는 함수였구만.

**주요 포인트 정리**

*   함수 호출 시 인자 전달 및 반환값 활용 이해.
*   `for` 루프의 동작 방식 (초기값, 조건, 증감) 및 반복 횟수 계산.
*   거듭제곱 계산 로직 (초기값 1 설정, 반복적인 곱셈).
*   `printf` 함수를 이용한 변수 값 출력.

---


### 17. 다음 Java 프로그램이 정상 동작하여 <실행 결과>가 출력될 수 있도록 빈칸에 알맞은 예약어를 작성하시오

```java
public class Main {
    public static void main(String[] args) throws Exception{
        System.out.println(test(1));
    }
    ( ) String test(int num){
        return(num >= 0) ? "positive" : "negative";
    }
}
```
```
<실행 결과>
positive
```

`main` 함수 안에서 `test(1)` 이걸 호출해서 결과를 찍으려고 하네?
근데 `main` 함수 앞에 `public static void` 이렇게 `static`이 붙어있잖아?

자바에서는 `static` 붙은 놈(정적 메서드) 안에서는 기본적으로 `static` 안 붙은 놈(인스턴스 메서드)을 바로 호출 못 함. 객체를 만들어서 호출해야 되거든.
근데 코드 보면 객체 만드는 거 없이 바로 `test(1)` 때려버렸지?

이게 되려면 호출당하는 `test` 메서드도 똑같이 `static` 이어야 함. 그래야 클래스 이름으로 바로 접근해서 쓸 수 있거든. (같은 클래스 안이라 클래스 이름 생략 가능)

그러니까 빈칸에는 **static** 이거 들어가면 되는 거임.

`static String test(int num)` 이렇게 되면, `main`에서 `test(1)` 호출 -> `num`에 1 들어감 -> `1 >= 0` 참이니까 `"positive"` 반환 -> 그거 출력. <실행 결과> 딱 맞네 ㅋㅋ

**주요 포인트 정리**

*   **`static` 메서드**: 클래스에 속하며, 객체 생성 없이 '클래스명.메서드명()' 또는 (같은 클래스 내에서는) '메서드명()'으로 호출 가능.
*   **인스턴스 메서드**: 객체에 속하며, 반드시 객체를 생성한 후 '객체참조변수.메서드명()'으로 호출해야 함.
*   **`static` 메서드 내에서의 호출 제약**: `static` 메서드 내에서는 다른 `static` 멤버(변수, 메서드)만 직접 접근(호출) 가능. 인스턴스 멤버에 접근하려면 객체를 생성해야 함.
*   이 문제에서는 `static`인 `main` 메서드가 `test` 메서드를 직접 호출하므로, `test` 메서드도 `static` 이어야 함.

---


### 18. 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
int main(void){
    int arr[3];
    int sum = 0;
    *(arr + 0) = 1;
    arr[1] = *(arr + 0) + 2;
    arr[2] = *arr + 3;
    for(int i = 0; i < 3; i++){
        sum = sum + arr[i];
    printf("%d", sum);
    }
}
```

1.  `int arr[3];`: 정수 3개 담을 배열 `arr` 만듦. 아직 값은 쓰레기값.
2.  `int sum = 0;`: 합계 담을 변수 `sum` 0으로 초기화.
3.  `*(arr + 0) = 1;`: `arr`은 배열 시작 주소. `arr + 0`도 시작 주소. `*` 붙였으니 그 주소에 있는 값, 즉 `arr[0]` 말하는 거임. `arr[0] = 1` 이랑 똑같음. 배열 상태: `{1, ?, ?}`
4.  `arr[1] = *(arr + 0) + 2;`: `*(arr + 0)`은 방금 넣은 `arr[0]` 값, 즉 1임. 그럼 `arr[1] = 1 + 2 = 3`. 배열 상태: `{1, 3, ?}`
5.  `arr[2] = *arr + 3;`: `*arr`은 `*(arr + 0)`랑 같은 말임. 배열 이름만 쓰면 첫 번째 요소 주소 가리키거든. 거기에 `*` 붙였으니 `arr[0]` 값인 1임. 그럼 `arr[2] = 1 + 3 = 4`. 배열 상태: `{1, 3, 4}`
6.  이제 `for` 루프 돈다. `i`가 0, 1, 2 이렇게 세 번 돌겠네.

    *   **i = 0 일 때:**
        *   `sum = sum + arr[0];` => `sum = 0 + 1 = 1`.
        *   `printf("%d", sum);` => 화면에 `1` 찍힘. (줄바꿈 없음!)
    *   **i = 1 일 때:**
        *   `sum = sum + arr[1];` => `sum = 1 + 3 = 4`.
        *   `printf("%d", sum);` => 화면에 이어서 `4` 찍힘.
    *   **i = 2 일 때:**
        *   `sum = sum + arr[2];` => `sum = 4 + 4 = 8`.
        *   `printf("%d", sum);` => 화면에 또 이어서 `8` 찍힘.

7.  루프 끝나고 `main` 함수 끝남.

최종적으로 화면에 찍힌 거 쭉 이어서 보면 **148** 이네 ㅋㅋ `printf`가 루프 안에 있어서 중간 합계가 계속 찍힌 거임. 만약 `printf`가 루프 밖에 있었으면 최종 합계 8만 찍혔겠지?

**주요 포인트 정리**

*   **배열과 포인터**: C에서 배열 이름은 배열의 시작 주소를 나타냄. `arr` == `&arr[0]`.
*   **포인터 연산**: `*(arr + i)`는 `arr[i]`와 동일한 표현.
*   **`printf` 위치**: `printf`가 루프 안에 있는지 밖에 있는지에 따라 출력 결과가 달라짐. 루프 안에 있으면 반복될 때마다 출력됨.
*   **누적 합계**: `sum = sum + 값` 형태는 값을 계속 더해 나가는 누적 합계 로직.
*   **출력 형식**: `printf("%d", ...)`는 정수를 출력하며, 형식 문자열에 공백이나 `\n`(줄바꿈)이 없으면 출력 결과가 연달아 붙어서 나옴.

---


### 19. 다음 Java 프로그램의 실행 결과를 작성하시오

```java
class par{
    int comp(int x, int y){
        return x + y;
    }
}
class sub extends par{
    int comp(int x, int y){
        return x - y + super.comp(x, y);
    }
}
public class Main{
    public static void main(String[] args) throws Exception{
        par aa = new par();
        par bb = new sub();
        System.out.println(aa.comp(3, 2) + bb.comp(3, 2));
    }
}
```

1.  **클래스 파악:**
    *   `par` 클래스: `comp(x, y)` 메서드는 그냥 `x + y` 리턴함.
    *   `sub` 클래스: `par`를 상속받음. 근데 `comp(x, y)`를 **오버라이딩**(재정의) 했네? 얘는 `x - y` 에다가 `super.comp(x, y)` (부모 클래스의 `comp` 메서드 결과)를 더해서 리턴함.

2.  **`main` 함수 분석:**
    *   `par aa = new par();`: `aa`는 `par` 타입이고 실제 객체도 `par`임.
    *   `par bb = new sub();`: `bb`는 선언은 `par` 타입인데, 실제 만들어진 객체는 `sub`임. 이게 바로 **다형성**이지 ㅋㅋ
    *   `System.out.println(aa.comp(3, 2) + bb.comp(3, 2));`: 요게 최종 결과임. 두 개 계산해서 더해야 함.

3.  **계산 시작:**
    *   `aa.comp(3, 2)`: `aa`는 실제 객체가 `par`이니까, `par` 클래스의 `comp` 메서드가 실행됨. `3 + 2 = 5`.
    *   `bb.comp(3, 2)`: `bb`는 선언은 `par`이지만 실제 객체는 `sub`임. 오버라이딩된 메서드는 실제 객체 기준으로 실행되니까, `sub` 클래스의 `comp` 메서드가 실행됨.
        *   `sub`의 `comp(3, 2)`는 `3 - 2 + super.comp(3, 2)` 이거임.
        *   `super.comp(3, 2)`는 부모(`par`)의 `comp`를 호출하니까 `3 + 2 = 5`임.
        *   그럼 `3 - 2 + 5` 계산하면 `1 + 5 = 6`이네.

4.  **최종 결과:**
    *   `println` 안의 계산은 `5 + 6`이 되는 거임.
    *   따라서 출력 결과는 **11** 임. ㅋㅋ

**주요 포인트 정리**

*   **상속(Inheritance)**: 자식 클래스(`sub`)가 부모 클래스(`par`)의 멤버(메서드 등)를 물려받음.
*   **메서드 오버라이딩(Method Overriding)**: 상속받은 메서드를 자식 클래스에서 재정의하는 것.
*   **다형성(Polymorphism)**: 부모 타입 참조 변수(`bb`)가 자식 타입 객체(`new sub()`)를 참조할 수 있음. 메서드 호출 시 실제 객체의 오버라이딩된 메서드가 실행됨 (동적 바인딩).
*   **`super` 키워드**: 자식 클래스에서 오버라이딩된 메서드 내에서 부모 클래스의 멤버(메서드 등)에 접근할 때 사용. `super.comp(x, y)`는 `par` 클래스의 `comp` 메서드를 호출.

---


### 20. 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요한 테스트 장치(Test Harness)가 무엇인지 작성하시오

생각해봐. 제일 위에 있는 대빵 모듈(제어 모듈)을 테스트해야 하는데, 얘가 밑에 있는 쫄따구 모듈들을 불러서 쓰잖아. 근데 그 쫄따구 모듈들이 아직 안 만들어졌거나, 지금 테스트하려는 거랑 상관없어서 그냥 대충 기능만 흉내 내면 될 때가 있음.

그럴 때 쓰는 가짜 모듈, 임시 모듈 같은 거 있잖아? 제어 모듈이 "야 일해!" 하고 호출하면 "넵!" 하고 간단하게 대답만 해주거나 미리 정해진 값만 넘겨주는 역할 하는 애. 얘가 바로 **스텁 (Stub)** 임.

쫄따구(하위 모듈) 대신 임시로 끼워넣는 부품이라고 생각하면 편함 ㅋㅋ

**주요 포인트 정리**

*   하향식(Top-down) 통합 테스트에서 사용됨.
*   상위 모듈(호출하는 모듈) 테스트 시 아직 구현되지 않았거나 테스트에 불필요한 하위 모듈(호출되는 모듈)을 **대체**하는 역할.
*   호출되면 미리 정해진 값을 반환하거나 간단한 동작만 수행하는 **더미(Dummy) 또는 가짜 모듈**.
*   테스트 하네스(Test Harness)의 일부 구성 요소.
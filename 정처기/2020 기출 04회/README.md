# 2020 기출 04회 해설

### 1. 다음이 설명하고 있는 용어를 영문 약어로 작성하시오

> - 기존 32비트의 IPv4 주소가 고갈되는 문제를 해결하기 위하여 개발된 새로운 128비트 체계의 무제한 인터넷 프로토콜 주소를 말한다.
> - 16bit씩 8부분으로 나누어 16진수로 표기한다.
> - IPv4와 비교하여 헤더의 크기는 40byte로 고정되었고 헤더 체크섬은 없어졌다.
> - 유니캐스트, 멀티캐스트, 애니캐스트의 주소 규칙을 갖는다.

아 ㅋㅋ 이거 딱 봐도 각 나오네. 32비트 쓰던 IPv4 주소 다 떨어져서 새로 만든 거 아니냐? 128비트짜리 무제한 어쩌고 하는 거 보니까 빼박이지. 16비트씩 8부분으로 나눠서 16진수로 쓴다? 헤더 크기 40바이트 고정에 체크섬 없다? 유니캐스트, 멀티캐스트, 애니캐스트? 이거 완전 그거네 그거 ㅋㅋ 영문 약자로 쓰라 했으니까 답은 **IPv6** 이거지 임마.

**주요 포인트:**

*   **IPv6**: 기존 IPv4 주소 고갈 문제 해결 위해 개발된 128비트 주소 체계
*   **주소 표기**: 16비트씩 8부분, 각 부분은 16진수로 표기 (콜론으로 구분)
*   **헤더 특징**: 크기 40바이트 고정, 헤더 체크섬 필드 제거
*   **주소 유형**: 유니캐스트, 멀티캐스트, 애니캐스트 지원

---

### 2. 다음의 디자인 패턴에 대한 설명에 대하여 빈칸에 들어갈 알맞은 용어를 작성하시오

> 디자인 패턴은 객체지향 프로그래밍 시 발생하는 여러 가지 문제에 대한 설계 사례를 분석하여 공통적으로 발생하는 문제를 해결하기 위한 방법론으로, 여러 설계들로 분류하고, 각 문제 유형별로 가장 적합한 설계를 일반화한 패턴이다.
> GoF 디자인 패턴은 1995년 Erich Gamma, Richard Helm, Ralph Johnson, John Vissides가 처음으로 디자인 패턴을 구체화하여 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴이 되었다. 이는 구현 방식에 따라 생성, 구조, ( ) 3가지로 분류한다.
> ( ) 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스크, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을 지를 정의하는 패턴이다. 즉, 객체나 클래스의 교류 방법에 대해 정의하는 것이다. ( ) 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 그들 간의 결합도를 최소화 할 수 있도록 도와준다.

아 ㅋㅋ 이거 디자인 패턴 문제네. GoF 디자인 패턴 그거 세 가지로 나눈다며? 생성, 구조, 그리고 나머지 하나 뭐냐 이거지?

설명 보니까 뭐 클래스나 객체들이 어떻게 **상호작용**하는지, 누가 어떤 **일(알고리즘, 책임)** 할지 정하는 거라네? 객체끼리 어떻게 **대화(교류)**할지 정하고, 일 나눠주면서 서로 **덜 엮이게(결합도 최소화)** 하는 거라잖아.

이거 완전 '어떻게 행동하냐' 이거 아님? 객체들의 행동, 상호작용 방식을 다루는 거. 그러니까 빈칸에 들어갈 말은 **행위** 이거지. 행위 패턴 ㅇㅋ?

**주요 포인트:**

*   **GoF 디자인 패턴 분류**: 생성(Creational), 구조(Structural), **행위(Behavioral)** 3가지
*   **행위 패턴**: 클래스나 객체 간의 상호작용 방식, 책임 할당 방법 정의
*   **행위 패턴 특징**: 객체 간의 결합도를 최소화하면서 효과적으로 협력하는 방법에 초점

---

### 3. UML을 이용한 다이어그램 중 패키지 다이어그램에 대해 설명하시오.

아 ㅋㅋ 패키지 다이어그램? 그거 별거 없어 임마. 니 컴퓨터에 폴더 만들어서 파일 정리하는 거랑 비슷하다고 보면 됨.

UML 다이어그램 종류 존나 많은데, 그 중에서 **구조**를 보여주는 놈이거든? 시스템이 엄청 커지면 클래스나 유스케이스 같은 거 수백, 수천 개씩 되는데 그거 그냥 다 늘어놓으면 정신 사납잖아 ㅋㅋ

그래서 비슷한 기능이나 관련된 놈들끼리 '패키지'라는 보따리에 묶어서 그룹으로 만드는 거야. 모델 요소들을 조직화하는 거지. 폴더 모양 아이콘으로 그리고, 그 안에 클래스 같은 거 넣거나 아니면 그냥 패키지 이름만 써 놓기도 함.

그리고 이 패키지들끼리 서로 어떻게 연관되어 있는지, 예를 들어 어떤 패키지가 다른 패키지에 있는 걸 갖다 쓰는지 (의존 관계, Dependency) 같은 걸 점선 화살표 같은 걸로 보여주는 거임.

결론은 뭐다? 복잡한 시스템 구조를 큰 덩어리(패키지) 단위로 나눠서 보기 쉽게 만들고, 관리하기 편하게 해준다 이거지. ㅇㅋ?

**주요 포인트:**

*   **패키지 다이어그램**: UML의 구조 다이어그램 중 하나
*   **목적**: 시스템의 구성 요소(클래스, 유스케이스 등)를 관련된 것끼리 그룹화하여 관리 (모델 요소 조직화)
*   **표현**: 폴더 모양 아이콘으로 패키지를 나타내고, 점선 화살표 등으로 패키지 간의 의존 관계(Dependency) 등을 표현
*   **효과**: 복잡한 시스템 구조를 단순화하고, 이해도를 높이며, 유지보수 용이성 증대

---

### 4. 다음 설명의 빈칸에 들어갈 알맞은 용어를 순서대로 작성하시오

> 데이터 회복 기법은 시스템 붕괴나 트랜잭션에 대한 장애가 발생했을 때 데이터베이스를 장애 발생 이전의 일관된 상태로 복원하는 작업을 의미한다.
> ( )는 트랜잭션 실행 중에 발생하는 변경 내용을 데이터베이스에 즉시 반영하는 방법이다. 때문에 시스템 붕괴나 트랜잭션에 대한 장애 발생 시 트랜잭션이 실행되기 이전 상태의 데이터 값으로 디스크의 데이터를 복원한다.
> 반면 ( )는 트랜잭션이 부분 완료될 때까지 모든 output 연산을 지연시킴과 동시에 데이터베이스에 대한 변경을 로그에 전부 기록한다. 따라서 트랜잭션 실행 중 시스템이 붕괴되거나 트랜잭션이 철회되면 로그에 있는 정보는 그냥 버리고 무시하면 된다.

아 ㅋㅋ 데이터 회복 기법 문제네. DB 맛탱이 갔을 때 복구하는 방법 두 가지 비교하는 거구만.

첫 번째 빈칸 보니까 트랜잭션 실행 중에 변경 내용을 바로바로 DB에 꽂아 넣는다고 하네? 그러다 뻑나면? 롤백해야지 ㅋㅋ 이전 데이터 값으로 되돌려야 함. UNDO 작업이 필요하다 이 말이야. 이런 걸 뭐라 하겠냐? 바로 반영하니까 **즉시 갱신**이지.

두 번째는 좀 다르네? 부분 완료될 때까지 기다렸다가 로그에만 일단 다 적어둔대. DB에는 바로 안 쓰고 로그에만 쓰는 거지. 그러다가 뻑나거나 트랜잭션 취소되면? 로그 걍 버리면 끝 ㅋㅋ DB는 건드린 적 없으니까 복구랄 게 딱히 없어. 커밋될 때까지 미루는 거니까 이걸 **지연 갱신**이라고 한다 이거야.

그래서 순서대로 **즉시 갱신**, **지연 갱신** 이게 답임 ㅇㅋ?

**주요 포인트:**

*   **즉시 갱신 (Immediate Update)**: 트랜잭션 수행 중 변경 내용을 데이터베이스에 즉시 반영. 장애 시 UNDO 필요.
*   **지연 갱신 (Deferred Update)**: 트랜잭션 수행 중 변경 내용은 로그에만 기록하고, 부분 완료(Commit) 시점에 데이터베이스에 반영. 장애 시 (Commit 전) 로그 폐기 (UNDO 불필요), Commit 후 반영 중 장애 시 REDO 필요.

---

### 5. 다음 Java 프로그램은 십진수 10을 2진수로 변경하는 프로그램이다. 프로그램이 정상 동작하도록 빈칸에 들어갈 소스코드를 순서대로 작성하시오

```java
public class Main {
    public  static void main(String[] args) throws Exception{
        int array[] = new int[8];
        int i = 0, n = 10;
        while ( (1) ){
            array[i++] = (2);
            n /= 2;
        }
        for(i = 7; i >= 0; i--){
            System.out.print(array[i]);
        }
    }
}
```

아 ㅋㅋ 자바 문제네. 10진수 10을 2진수로 바꾸는 거? 이거 완전 기본 아니냐?

자 봐봐. 10을 2진수로 바꾸려면 어떻게 하냐? 계속 2로 나누면서 나머지를 거꾸로 읽으면 되잖아.

```
10 / 2 = 5 ... 나머지 0
 5 / 2 = 2 ... 나머지 1
 2 / 2 = 1 ... 나머지 0
 1 / 2 = 0 ... 나머지 1
```

거꾸로 읽으면 `1010`이지? 근데 배열 크기가 8이니까 8비트로 맞춰야 함. `00001010` 이렇게.

자 코드 보자. `while` 루프 돌면서 `n`을 2로 나누고 있네 (`n /= 2`). 그럼 이 루프는 언제까지 돌아야겠냐? `n`이 0이 될 때까지 계속 나눠야지. 그러니까 `n`이 0보다 클 동안만 돌면 됨. 그래서 **(1)번 빈칸**은 `n > 0` 이게 들어가야지.

루프 안에서는 `array[i++] = (2);` 이렇게 배열에 뭘 넣고 있네. 뭘 넣어야겠냐? 2진수 만들 때 필요한 건 2로 나눈 *나머지*잖아. 자바에서 나머지 구하는 연산자는 `%` 이거 알지? 그러니까 `n`을 2로 나눈 나머지, 즉 `n % 2`를 배열에 넣어야지. 그래서 **(2)번 빈칸**은 `n % 2` 이거임.

이렇게 하면 배열에 `0, 1, 0, 1` 순서대로 들어가고 나머지는 0으로 채워지겠지 (`{0, 1, 0, 1, 0, 0, 0, 0}`). 마지막 `for`문에서 배열을 거꾸로 (`i = 7`부터 `0`까지) 출력하니까 `00001010` 제대로 나오겠네.

그래서 답은 순서대로 `n > 0`, `n % 2` 이거다 임마.

**주요 포인트:**

*   **10진수 -> 2진수 변환**: 10진수를 2로 계속 나누면서 나머지를 구하고, 그 나머지를 역순으로 배열하면 2진수가 된다.
*   **while 루프 조건**: 나눌 값(`n`)이 0보다 클 때까지 반복 (`n > 0`).
*   **나머지 연산**: 2진수의 각 자릿수는 10진수를 2로 나눈 나머지(`%`)를 통해 구한다 (`n % 2`).
*   **결과 출력**: 계산된 나머지는 낮은 자릿수부터 배열에 저장되므로, 높은 자릿수부터 출력하려면 배열을 역순으로 읽어야 한다.

---

### 6. 다음 Java 프로그램과 실행 결과를 보고 킨반 (1), (2)에 들어갈 알맞은 배열 크기를 순서대로 작성하시오

```java
public class Main {
    public static void main(String[] args) throws Exception {
        int[][] array = new int[(1)][(2)];
        int n = 1;
        for(int = 0 ; i < 3 ; i++){
            for(int j = 0 ; j < 5; j++){
                array[i][j] = j * 3 + (i + 1);
                System.out.print(array[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

```
<실행 결과>
1 4 7 10 13
2 5 8 11 14
3 6 9 12 15
```

아 ㅋㅋ 자바 2차원 배열 크기 맞추는 거네. 실행 결과 보니까 딱 감 오지 않냐?

일단 코드를 까보자.
`int[][] array = new int[(1)][(2)];` 요기서 (1)번이 행(row) 개수, (2)번이 열(column) 개수잖아.

밑에 `for`문 두 개 돌아가는 거 봐봐.
바깥 `for`문: `for(int i = 0 ; i < 3 ; i++)` -> `i`가 0, 1, 2 이렇게 3번 도네? 이게 보통 행을 담당하지. `array[i][j]`에서 `i` 자리에 들어가잖아.
안쪽 `for`문: `for(int j = 0 ; j < 5; j++)` -> `j`가 0, 1, 2, 3, 4 이렇게 5번 도네? 이건 열 담당이지. `array[i][j]`에서 `j` 자리에 들어가고.

실행 결과를 봐도, 줄 바꿈이 3번 일어나니까 3행이고, 각 행마다 숫자가 5개씩 찍히니까 5열이잖아.

그러니까 바깥 루프 `i < 3` 보고 행 개수 **3**개, 안쪽 루프 `j < 5` 보고 열 개수 **5**개 때려 맞추면 되는 거지.

그래서 빈칸 (1)은 **3**, 빈칸 (2)는 **5** 이게 답임. ㅇㅋ?

**주요 포인트:**

*   **2차원 배열 선언**: `new int[행크기][열크기]` 형식으로 선언.
*   **중첩 for문과 배열**: 2차원 배열을 순회할 때 보통 바깥 루프는 행(row) 인덱스, 안쪽 루프는 열(column) 인덱스를 제어한다.
*   **루프 조건 확인**: `for` 루프의 조건식 (`i < 3`, `j < 5`)을 통해 각 차원의 크기를 유추할 수 있다. (0부터 시작하므로 `< N`은 N개의 원소를 의미)
*   **실행 결과 분석**: 출력 형태(줄 수, 각 줄의 데이터 개수)를 통해 배열의 행과 열 크기를 파악할 수 있다.

---

### 7. 해킹 기법 중 하나인 스니핑(Sniffing)에 대해서 간단하게 서술하시오.

아 ㅋㅋ 스니핑? 그거? 존나 간단한 거임.

네트워크 상에 돌아다니는 데이터 패킷 있잖아? 그거 싸악 낚아채서 **엿듣는 거**라고 보면 됨. 니 옆자리 애가 친구랑 카톡하는 거 몰래 훔쳐보는 거랑 비슷하다고 ㅋㅋ

원래 데이터는 목적지까지 가야 하는데, 공격자가 중간에서 그 데이터를 몰래 가로채서 안에 뭐가 들었는지 까보는 거지. 주로 아이디, 비번, 카드번호 같은 중요한 정보 빼돌리려고 하는 짓임.

특히 보안 안 된 와이파이 같은 데서 누가 네 데이터 킁킁거리고(Sniffing) 있을지 모르니까 조심해야 함. 그냥 남의 통신 내용 도청하는 해킹 기법이다 이 말이야. ㅇㅋ?

**주요 포인트:**

*   **스니핑(Sniffing)**: 네트워크 상의 데이터 트래픽(패킷)을 엿듣거나 도청하는 행위.
*   **목적**: 계정 정보(ID/PW), 신용카드 번호 등 민감한 데이터를 탈취하기 위함.
*   **방식**: 공격자가 네트워크 중간에서 전송되는 데이터를 가로채어 내용을 분석.
*   **취약 환경**: 암호화되지 않은 통신, 보안이 취약한 네트워크(예: 공용 Wi-Fi).

---

### 8. 다음이 설명하는 용어를 영문 약어로 작성하시오

> - 한글로 번역하면 '네트워크 주소 변환'이라고도 할 수 있다.
> - 외부 네트워크에 알려진 것과 다른 사설 IP 주소를 사용하는 내부 네트워크에서 IP 주소를 변환하는 것이다. 즉, 사설 IP 주소를 공용 IP 주소로 변환하거나 들어오는 패킷들을 공용 IP 주소에서 다시 사설 IP 주소로 변환하는 역할을 한다.
> - 인터넷의 공용 IP 주소를 절약할 수 있으며, 인터넷이란 공공망과 연결되는 사용자들의 고유한 사설망을 침입자드로부터 보호할 수 있다.

아 ㅋㅋ 이거? '네트워크 주소 변환'이라고 떡하니 써 있네. 그거 영어로 줄이면 뭐냐 이거잖아.

집이나 회사 안에서는 192.168.x.x 이런 사설 IP 쓰는데, 이걸로는 인터넷 바로 못 나가거든? 그래서 밖에 있는 인터넷 세상(공용망)으로 나갈 때는 진짜 IP(공용 IP)로 **바꿔주고**, 반대로 밖에서 안으로 데이터 들어올 때는 다시 원래 사설 IP로 **바꿔주는** 기술임.

하나의 공용 IP 가지고 여러 대가 나눠 쓸 수 있으니까 IP 주소 부족한 거 해결해주고, 외부에서는 내부 네트워크 구조를 직접 볼 수 없으니까 보안에도 도움이 됨.

이거 딱 보면 **NAT**이지. Network Address Translation. ㅇㅋ?

**주요 포인트:**

*   **NAT (Network Address Translation)**: 사설 IP 주소를 공용 IP 주소로 (또는 그 반대로) 변환하는 기술.
*   **주요 목적**: 공용 IP 주소 절약, 내부 네트워크 보안 강화.
*   **동작 방식**: 내부 네트워크와 외부 네트워크 사이의 게이트웨이(라우터 등)에서 IP 주소 변환 수행.

---

### 9. 다음 Python 프로그램의 실행 결과를 출력 형식을 준수하여 작성하시오

```python
arr = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
print(arr[0])
print(arr[2][1])
for sub in arr:
    for item in sub:
        print(item, end=" ")
    print()
```

아 ㅋㅋ 파이썬 리스트 문제네. 이거 코드 까보면 별거 없어.

```python
arr = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
# arr는 리스트 안에 리스트가 들어있는 2차원 비슷한 구조임
# arr[0]은 [1, 2, 3]
# arr[1]은 [4, 5]
# arr[2]는 [6, 7, 8, 9]

print(arr[0])
# arr의 0번째 요소인 [1, 2, 3] 리스트를 그대로 출력함. 리스트는 대괄호랑 쉼표까지 다 나옴.

print(arr[2][1])
# arr의 2번째 요소는 [6, 7, 8, 9] 이거지?
# 그 리스트 안에서 다시 1번째 요소 (0부터 시작하니까 두 번째꺼)를 찾으라는 거임.
# 그러니까 7이 나오겠네.

for sub in arr:
# arr 안에 있는 리스트들을 하나씩 꺼내서 sub에 넣고 돌림
# 첫 번째 루프: sub = [1, 2, 3]
# 두 번째 루프: sub = [4, 5]
# 세 번째 루프: sub = [6, 7, 8, 9]
    for item in sub:
    # sub 안에 있는 숫자들을 하나씩 꺼내서 item에 넣고 돌림
        print(item, end=" ")
        # item을 출력하는데, 줄바꿈 대신에 띄어쓰기(" ")를 넣음.
    print()
    # 안쪽 for문 다 돌고 나면 여기서 줄바꿈 한 번 해줌.
```

자 그럼 실행 결과가 어떻게 나오겠냐?

1.  `print(arr[0])` -> `[1, 2, 3]` 출력하고 줄바꿈
2.  `print(arr[2][1])` -> `7` 출력하고 줄바꿈
3.  첫 번째 바깥 루프 (`sub = [1, 2, 3]`)
    *   `print(1, end=" ")` -> `1 ` 출력
    *   `print(2, end=" ")` -> `1 2 ` 출력
    *   `print(3, end=" ")` -> `1 2 3 ` 출력
    *   `print()` -> 줄바꿈
4.  두 번째 바깥 루프 (`sub = [4, 5]`)
    *   `print(4, end=" ")` -> `4 ` 출력
    *   `print(5, end=" ")` -> `4 5 ` 출력
    *   `print()` -> 줄바꿈
5.  세 번째 바깥 루프 (`sub = [6, 7, 8, 9]`)
    *   `print(6, end=" ")` -> `6 ` 출력
    *   `print(7, end=" ")` -> `6 7 ` 출력
    *   `print(8, end=" ")` -> `6 7 8 ` 출력
    *   `print(9, end=" ")` -> `6 7 8 9 ` 출력
    *   `print()` -> 줄바꿈

이거 다 합치면 이렇게 나오지 ㅋㅋ

```
[1, 2, 3]
7
1 2 3 
4 5 
6 7 8 9 
```

**주요 포인트:**

*   **파이썬 리스트 인덱싱**: `arr[i]`는 리스트 `arr`의 `i`번째 요소에 접근. `arr[i][j]`는 중첩 리스트에서 `i`번째 리스트의 `j`번째 요소에 접근.
*   **중첩 반복문**: `for` 루프 안에 다른 `for` 루프를 사용하여 중첩된 데이터 구조(여기서는 리스트의 리스트)를 순회할 수 있다.
*   **`print()` 함수의 `end` 매개변수**: `print(..., end=" ")`는 출력 후 줄바꿈 대신 지정된 문자(여기서는 공백)를 출력한다.
*   **`print()` 함수**: 인자 없이 호출하면 단순히 줄바꿈 문자를 출력한다.

---

### 10. 거래 정보를 특정 위치에 저장하지 않고 네트워크에 분산 저장하여 참여자 공동으로 기록하고 관리하는 분산 원장 기술을 무엇이라 하는지 작성하시오.

아 ㅋㅋ 이거? '분산 원장 기술'이라고 대놓고 말해주네.

거래 기록 같은 거 한 군데 몰빵 안 하고, 네트워크에 쫙 뿌려서 참여자들이 다 같이 기록하고 관리하는 거 말하는 거 아님? 데이터 쪼가리(블록)들을 체인처럼 엮어서 복제하고 공유하니까 누가 함부로 위조하거나 변조하기 개빡세지는 거.

이거 딱 봐도 **블록체인(Blockchain)** 아니냐? 비트코인 같은 거 쓰는 그 기술 맞음 ㅇㅇ.

**주요 포인트:**

*   **블록체인 (Blockchain)**: 분산 원장 기술의 대표적인 예시.
*   **특징**:
    *   데이터를 중앙 서버 없이 네트워크 참여자들에게 분산하여 저장.
    *   참여자들이 공동으로 데이터를 기록하고 검증 및 관리.
    *   블록 단위로 데이터를 기록하고 이를 체인 형태로 연결하여 위변조 방지.
    *   데이터의 투명성과 신뢰성 확보.

---

### 11. 다음의 설명에 해당하는 분산 컴퓨팅 용어를 작성하시오

> - PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 공개 소스 프레임워크로, 2005년 더그 커팅과 마이크 케퍼렐라가 오픈 소스 검색 엔진인 아파치 너치를 분산 처리하기 위하여 개발하였다.
> - 오픈 소스 기반 컴퓨팅 플랫폼으로, 라이선스 비용이 불필요하고, 초기에 작은 클러스터를 구성하여 운영 가능하다.
> - 핵심 구성요소에는 HDFS와 Map Reduce등이 있다. HDFS는 대용량의 데이터를 분산시키고 저장/관리하는 시스템이고, Map Reduce는 대용량 데이터의 처리를 위한 분산 프로그래밍 모델로 흩어져 있는 데이터들을 연관성 있는 데이터로 분류하는 맵(Map)과 분류한 데이터에서 중복된 데이터를 제거하고 원하는 데이터를 추출하는 리듀스(Reduce)라는 두 개의 메소드로 구성된다.

아 ㅋㅋ 이거? 뭐 PC급 컴퓨터들 모아서 큰 저장소 만들고, 데이터 존나 많은거 병렬로 돌리는 거 아니냐? 공개 소스 프레임워크라 하고. 개발자 이름까지 나오고.

결정적으로 **HDFS**랑 **MapReduce**가 핵심 구성요소라고 하잖아 임마 ㅋㅋ HDFS는 데이터 나눠서 저장하는 거고, MapReduce는 그거 분산 처리하는 방식 (맵이랑 리듀스 있다며).

이거 완전 **하둡(Hadoop)** 이지 뭐긴 뭐야 ㅋㅋ 딱 보면 알아야지.

**주요 포인트:**

*   **하둡 (Hadoop)**: 대용량 데이터의 분산 처리 및 저장을 위한 오픈 소스 프레임워크.
*   **주요 특징**: 저렴한 PC급 컴퓨터를 활용하여 클러스터 구성, 뛰어난 확장성.
*   **핵심 구성 요소**:
    *   **HDFS (Hadoop Distributed File System)**: 대용량 파일의 분산 저장 시스템.
    *   **MapReduce**: 대규모 데이터 세트의 병렬 처리를 위한 프로그래밍 모델.

---

### 12. 데이터베이승서 발생하는 이상(Anomaly) 현상 3가지를 작성하시오

아 ㅋㅋ 데이터베이스 이상 현상 그거 세 가지? 맨날 나오는 거잖아 임마. 정규화 제대로 안 하면 생기는 문제들임.

1.  **삽입 이상 (Insertion Anomaly):** 뭐 하나 데이터 넣으려는데, 아직 확정도 안 된 다른 불필요한 데이터까지 억지로 넣어야만 하는 경우임. 예를 들어 학과 아직 배정 안 된 신입생 정보를 넣고 싶은데, 테이블 설계가 이상해서 학과 정보 없으면 학생 정보 자체를 못 넣게 막아놓는 거 같은 거. 존나 답답하지 ㅋㅋ
2.  **삭제 이상 (Deletion Anomaly):** 이건 반대로, 어떤 데이터 지웠더니 그거랑 엮여있던 다른 중요한 정보까지 같이 증발해버리는 거. 학생 한 명 자퇴했는데, 그 학생 정보 지우니까 그 학생만 듣던 과목 정보까지 DB에서 사라지는 거 같은 거. 필요한 정보가 의도치 않게 날아가는 거지.
3.  **갱신 이상 (Update Anomaly):** 똑같은 데이터가 테이블 여기저기 중복으로 박혀있을 때 문제 생기는 거임. 예를 들어 학생 주소 변경됐는데, 여기도 바꾸고 저기도 바꾸고… 수십 군데 바꿔야 함. 그러다 한 군데라도 빼먹으면? 데이터가 서로 안 맞는(불일치) 꼬라지가 나는 거지. 존나 귀찮고 오류 나기 딱 좋음.

**주요 포인트:**

*   **삽입 이상**: 불필요한 데이터 없이는 원하는 데이터 삽입 불가.
*   **삭제 이상**: 특정 데이터 삭제 시, 원치 않는 다른 데이터까지 함께 삭제됨.
*   **갱신 이상**: 중복된 데이터 중 일부만 수정되어 데이터 불일치 발생 가능.

---

### 13. 다음 그림은 프로세스 상태 전이도이다. (1), (2), (3)에 알맞은 상태를 작성하시오

```
생성 → (1) ← 깨움(wake up) - (3)
디스패치 ↑↓ 할당시간 종료    ↗ 입출력 발생
              (2)     
              ↓
            완료
```

아 ㅋㅋ 프로세스 상태 전이도? 이거 운영체제 배우면 무조건 나오는 거 아니냐? 그림 보면서 맞춰보자고.

1.  **생성**되고 나서 바로 가는 상태네. CPU만 받으면 바로 돌아갈 수 있게 준비 딱 마친 상태. 디스패치(Dispatch) 받으면 (2)로 가고, (3)에서 깨어나도(Wake up) 여기로 오네? 이건 **준비 (Ready)** 상태지.

2.  (1) 준비 상태에서 디스패치 받아서 CPU 잡고 실제로 돌아가는 상태. 지 할당 시간 다 쓰면(Time slice expired) 다시 (1)로 쫓겨나고, 일 시키다가 입출력 같은 거 필요하면 (3)으로 빠짐. 다 끝나면 완료(Terminated)로 가고. 이건 딱 봐도 **실행 (Running)** 상태네.

3.  (2) 실행 상태에서 입출력 같은 거 요청하면 CPU 놔주고 여기서 기다리는 상태. I/O 끝나거나 기다리던 이벤트 터지면 깨어나서(Wake up) 다시 (1) 준비 상태로 돌아감. 이건 **대기 (Waiting) 또는 보류 (Blocked)** 상태라고 함.

그러니까 순서대로 **(1) 준비, (2) 실행, (3) 대기** (또는 보류) 이거임. ㅇㅋ?

**주요 포인트:**

*   **프로세스 상태**: 프로세스가 시스템 내에서 가질 수 있는 여러 가지 상황.
*   **주요 상태**:
    *   **생성 (New)**: 프로세스가 생성되는 중.
    *   **준비 (Ready)**: CPU 할당을 기다리는 상태 (메모리 등 다른 자원은 확보).
    *   **실행 (Running)**: CPU를 할당받아 명령어 실행 중인 상태.
    *   **대기 (Waiting/Blocked)**: 입출력 완료 등 특정 이벤트를 기다리는 상태.
    *   **완료 (Terminated)**: 프로세스 실행이 종료된 상태.
*   **상태 전이**: 특정 이벤트(디스패치, 시간 만료, 입출력 요청/완료 등)에 의해 프로세스 상태가 변경되는 것.

---

### 14. 테스트 오라클의 종류 중 특정한 몇 개의 입력 값에 대해서만 기대하는 결과를 제공해 주는 오라클을 무엇이라 하는지 작성하시오

아 ㅋㅋ 테스트 오라클 종류 묻는 거네. 모든 입력 값에 대해 다 알려주는 놈(참 오라클)도 있지만, 그건 현실적으로 만들기 힘들잖아?

근데 문제에서는 **특정한 몇 개의 입력 값**에 대해서만 답을 알려주는 오라클이라고 했지? 전체 다 못 보고 몇 개만 **뽑아서(샘플링)** 확인하는 거랑 비슷하네 ㅋㅋ

이거 딱 **샘플링 오라클**이구만. 전수 검사 힘들 때 쓰는 거. ㅇㅋ?

**주요 포인트:**

*   **테스트 오라클**: 테스트 결과가 올바른지 판단하기 위한 기준.
*   **샘플링 오라클 (Sampling Oracle)**: 전체 입력 값 중 **특정 몇 개**의 입력 값에 대해서만 기대 결과를 제공하는 오라클.

---

### 15. 다음 <등급 평가표>에 대하여 <테스트 케이스>를 작성하여 테스트를 진행하였다. 컴포넌트나 시스템의 동작이 같을 것이라고 추정되는 입력 또는 출력 도메인의 부분을 선택하여 선택된 값들 간의 논리적 관계를 고려하여 테스트 케이스를 선정하는 기법을 무엇이라 하는지 작성하시오

```
<등급 평가표>
| 점수 구간 | 등급 |
| 90 ~ 100 | 수 |
| 80 ~ 89 | 우 |
| 70 ~ 79 | 미 |
| 60 ~ 69 | 양 |
| ~ 59 | 가 |

<테스트 케이스>
| 구분 | 1 | 2 | 3 | 4 | 5 |
| 점수 구간 | 90 ~ 100 | 80 ~ 89 | 70 ~ 79 | 60 ~ 69 | ~ 59 |
| 입력값 | 95 | 83 | 78 | 63 | 45 |
| 예상 결과값 | 수 | 우 | 미 | 양 | 가 |
| 실제 결과값 | 수 | 우 | 미 | 양 | 가 |
```

아 ㅋㅋ 이거? 테스트 케이스 설계 기법 물어보는 거네.

설명 보니까 키워드가 딱 있잖아. "동작이 같을 것이라고 추정되는 입력 또는 출력 도메인의 부분 선택". 이게 뭔 소리냐면, 비슷한 놈들은 결과도 비슷할 거니까 **같은 그룹(동등 클래스)**으로 묶어서 그중 **대표 선수 하나**만 뽑아서 테스트하겠다 이거지.

<등급 평가표> 보면 90~100점 구간은 다 '수' 나올 거라고 예상하고 95점 하나만 테스트했잖아? 80~89 구간은 '우' 나올 거니까 83점 하나만 테스트하고. 이렇게 입력 값들을 비슷한 놈들끼리 그룹(파티션)으로 **나눠서(분할)** 테스트하는 거.

이걸 **동등 분할 기법 (Equivalence Partitioning)** 또는 **동치 분할 기법**이라고 부름. ㅇㅋ?

**주요 포인트:**

*   **동등 분할 기법 (Equivalence Partitioning)**: 테스트 케이스 설계 기법 중 하나 (블랙박스 테스트).
*   **목적**: 전체 입력/출력 도메인을 유사한 동작을 보일 것으로 예상되는 부분 집합(동등 클래스 또는 파티션)으로 나누어, 각 파티션에서 대표 값 하나씩만 테스트하여 테스트 케이스 수를 줄이는 것.
*   **기본 아이디어**: 한 파티션 내의 어떤 값으로 테스트하든 동일한 결과를 보일 것이라고 가정.

---

### 16. [학생] 테이블에서 <요구사항>을 참고하여 <결과>와 동일하게 검색하는 SQL 쿼리를 작성하시오

```
[학생]
| 학번 | 이름 | 학과 | 학년 | 점수 |
| 2022512 | 김성모 | 컴퓨터공학 | 3 | 90 |
| 2120326 | 이재후 | 전자공학 | 3 | 80 |
| 2204534 | 이준형 | 컴퓨터공학 | 2 | 95 |
| 2309876 | 성우람 | 전자공학 | 1 | 85 |
| 1923094 | 홍찬중 | 건축학 | 4 | 95 |
```

```
<결과>
| 학과 | 학과인원 |
| 건축학 | 1 |
| 전자공학 | 2 |
| 컴퓨터공학 | 2 |
```

```
<요구사항>
- 쿼리 작성 시 WHERE절은 사용하지 않고, GROUP BY절을 사용한다.
- 학과 인원은 별칭을 사용하여 표시하고 집계 함수를 사용한다.
- 각 속성의 자료형은 이름, 학과는 char(10)이고, 학번, 학년, 점수는 int이다.
- 쿼리는 대/소문자를 구분하지 않으며 세미콜론은 생략 가능하다.
```

아 ㅋㅋ SQL 쿼리 짜는 거네. 결과 보니까 학과별로 학생 수 세는 거잖음?

`[학생]` 테이블에서 `학과`별로 그룹을 묶어야겠지? <요구사항>에서도 `GROUP BY` 쓰라고 했고. 그러니까 `GROUP BY 학과` 이거 일단 들어가야 함.

그리고 각 그룹(학과)마다 몇 명 있는지 세야 하니까 집계 함수 `COUNT()` 써야지. 전체 학생 수를 세면 되니까 `COUNT(*)` 쓰거나 뭐 `COUNT(학번)` 같은 거 써도 됨. 근데 <요구사항>에서 `학과인원`이라는 별칭 쓰라고 했으니까 `COUNT(*) AS 학과인원` 이렇게 해줘야지.

마지막으로 결과에 `학과` 이름도 나와야 하니까 `SELECT` 절에 `학과`도 넣어줘야 함.

자 그럼 다 합쳐보자.

```sql
SELECT 학과, COUNT(*) AS 학과인원
FROM 학생
GROUP BY 학과
```

이렇게 하면 `학생` 테이블에서 `학과`로 그룹 묶고, 각 그룹별로 `학과` 이름이랑 `COUNT(*)`로 센 학생 수를 `학과인원`이라는 이름으로 보여주겠지. <결과>랑 똑같이 나올 거임. ㅇㅋ?

**주요 포인트:**

*   **`GROUP BY`**: 특정 컬럼(여기서는 `학과`)의 값이 같은 행들을 그룹으로 묶는다.
*   **`COUNT()`**: 집계 함수 중 하나로, 그룹 내의 행 수를 계산한다. `COUNT(*)`는 그룹 내 전체 행 수를 센다.
*   **`AS`**: 컬럼이나 테이블에 별칭(Alias)을 지정할 때 사용한다. (`COUNT(*) AS 학과인원`)
*   **`SELECT`**: 조회할 컬럼을 지정한다. `GROUP BY`를 사용할 때는 `SELECT` 절에 그룹화 기준 컬럼과 집계 함수만 올 수 있다.

---

### 17. 미국 벨 연구소가 프로그래밍 연구와 개발을 촉진시킬 환경 조성을 목적으로 개발한 다수 사용자를 위한 운영체제로 구조는 간단하여 이해하기 쉽고 범용성과 확장성이 뛰어나기 때문에 현재 개인용 컴퓨터나 소형 컴퓨터에서 주로 사용된다. 읽고, 이해하고, 변경하기 쉬운 고급언어인 C언어로 작성되어 시스템 간의 이식 과정을 단순화 한 운영체제가 무엇인지 작성하시오

아 ㅋㅋ 이것도 완전 힌트 퍼주네.

"미국 벨 연구소"에서 만들었고, "다수 사용자"용이고, "C언어"로 짜서 "이식성" 좋고, "간단하고 확장성 좋은" 운영체제? 이거 완전 빼박 **유닉스(UNIX)** 아니냐? 리눅스나 macOS 조상님 격 되는 그 OS 맞음 ㅇㅇ.

요즘은 뭐 서버나 워크스테이션에서 많이 쓰지만, 그 철학이나 구조가 많은 운영체제에 영향을 줬지. 딱 보면 유닉스라고 알아야 함.

**주요 포인트:**

*   **유닉스 (UNIX)**: 벨 연구소에서 개발한 운영체제.
*   **특징**:
    *   다중 사용자, 다중 작업(Multi-user, Multi-tasking) 지원.
    *   C언어로 작성되어 높은 이식성 제공.
    *   계층적 파일 시스템.
    *   명령어 기반 인터페이스 (쉘).
    *   단순하고 강력한 도구들의 조합을 중시하는 설계 철학.

---

### 18. UI의 설계 원칙 중 직관성에 대하여 간략하게 서술하시오

아 ㅋㅋ UI 설계 원칙 중에 **직관성(Intuitiveness)**? 그거? 존나 쉬움.

그냥 사용자가 딱 보면 **'아 이거 이렇게 쓰는 거구나!'** 하고 바로 **알아챌 수 있게** 만드는 거임. 특별히 배우거나 설명서 안 뒤져봐도 어떻게 조작하고 뭘 누르면 어떻게 될지 **예상 가능**하게 디자인하는 거.

예를 들어, 빨간색 버튼은 뭔가 위험하거나 정지 느낌, 초록색은 확인이나 시작 느낌 주는 거? 아니면 돋보기 아이콘 보면 검색 기능이겠거니 생각하는 거. 이런 게 다 직관성 살리는 거임. 한마디로 **쉽고 명확하게, 사용자가 고민 안 하게** 만드는 게 핵심이다 이거지. ㅇㅋ?

**주요 포인트:**

*   **직관성 (Intuitiveness)**: 사용자가 UI를 접했을 때, 학습이나 별도의 설명 없이도 그 기능과 사용법을 쉽게 이해하고 예측할 수 있도록 설계하는 원칙.
*   **목표**: 사용자의 편의성 증대, 사용 오류 감소, 학습 시간 단축.
*   **구현 방법**: 표준적인 디자인 요소 사용, 명확한 레이블링, 일관성 있는 디자인 패턴 적용, 사용자의 기존 경험 및 멘탈 모델 활용 등.

---

### 19. 다음 C언어 프로그램의 실행 결과를 작성하시오

```c
int main() {
    char *p = "KOREA";
    printf("%s\n", p);
    printf("%s\n", p+3);
    printf("%c\n", *p);
    printf("%c\n", *(p+3));
    printf("%c", *p+2);
}
```

아 ㅋㅋ C언어 포인터 문제네. 이거 포인터랑 문자열, 문자 출력 구분 잘 해야 함.

```c
int main() {
    char *p = "KOREA"; // 포인터 p가 문자열 "KOREA"의 시작('K')을 가리킴
    printf("%s\n", p);
    // %s는 문자열 출력. p가 가리키는 곳부터 널 문자(\0) 만날 때까지 출력.
    // 그러니까 "KOREA" 출력하고 줄바꿈(\n).

    printf("%s\n", p+3);
    // p+3은 포인터 p 위치에서 3칸 뒤를 가리킴. 'K' -> 'O' -> 'R' -> 'E'. 즉 'E'를 가리킴.
    // %s니까 'E'부터 널 문자까지 출력. "EA" 출력하고 줄바꿈.

    printf("%c\n", *p);
    // %c는 문자 하나 출력. *p는 p가 가리키는 곳의 값('K')을 의미.
    // 'K' 출력하고 줄바꿈.

    printf("%c\n", *(p+3));
    // p+3이 가리키는 곳은 'E'. *(p+3)은 그 위치의 값 'E'.
    // %c니까 'E' 출력하고 줄바꿈.

    printf("%c", *p+2);
    // *p는 'K'. 'K'의 아스키 코드 값에 2를 더하라는 거임.
    // 'K' 아스키 코드가 75니까, 75 + 2 = 77.
    // 아스키 코드 77에 해당하는 문자는 'M'임.
    // %c니까 문자 'M' 출력. 뒤에 \n 없으니 줄바꿈 안 함.
}
```

자 그럼 실행 결과는 순서대로 이렇게 나오겠지?

```
KOREA
EA
K
E
M
```

**주요 포인트:**

*   **`char *p = "문자열";`**: 포인터 `p`가 문자열 리터럴의 첫 번째 문자를 가리키게 함.
*   **`%s`**: 문자열 포맷 지정자. 포인터가 가리키는 주소부터 NULL 문자(`\0`)까지 출력.
*   **`%c`**: 문자 포맷 지정자. 해당 변수(또는 값)를 문자 하나로 출력.
*   **포인터 연산 (`p+n`)**: 포인터 `p`의 현재 위치에서 `n`개의 요소(여기서는 `n`개의 `char`)만큼 뒤의 메모리 주소를 가리킴.
*   **역참조 연산 (`*p`)**: 포인터 `p`가 가리키는 메모리 주소에 저장된 값 자체를 의미.
*   **문자 연산 (`*p + n`)**: 문자의 ASCII 값에 정수 `n`을 더한 후, 그 결과 ASCII 값에 해당하는 문자를 얻음 (만약 `%c`로 출력한다면).

---

### 20. 다음 Java 프로그램의 실행 결과를 작성하시오

```java
class Parent {
    int compute(int num) {
        if(num <= 1) return num;
        return compute(num - 1) + compute(num - 2);
    }
}
class Child extends Parent {
    int compute(int num) {
        if(num <= 1) return num;
        return compute(num - 1) + compute(num - 3);
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        Parent obj = new Child();
        System.out.print(obj.compute(4));
    }
}
```

아 ㅋㅋ 자바 상속이랑 오버라이딩 문제네. 이거 헷갈리면 안됨.

```java
class Parent {
    int compute(int num) { // 피보나치 수열 비스무리 (n-1) + (n-2)
        if(num <= 1) return num;
        return compute(num - 1) + compute(num - 2);
    }
}
class Child extends Parent {
    @Override // 사실상 오버라이드임
    int compute(int num) { // 얘는 좀 다르게 (n-1) + (n-3) 임!!
        if(num <= 1) return num;
        return compute(num - 1) + compute(num - 3);
    }
}
public class Main {
    public static void main(String[] args) throws Exception {
        Parent obj = new Child(); // 타입은 Parent인데, 실제 알맹이는 Child 객체임. 이게 중요!
        System.out.print(obj.compute(4)); // obj로 compute 호출하면 누구께 실행될까?
    }
}
```

자 여기서 핵심은 `Parent obj = new Child();` 이거임. 변수 타입은 `Parent`지만, 실제 가리키는 객체는 `new Child()`로 만든 `Child` 객체임. 자바에서는 메소드를 호출할 때, 변수 타입이 아니라 **실제 객체의 메소드**가 호출됨 (오버라이딩된 경우). 이걸 동적 메소드 디스패치라고 부름 ㅋㅋ

그러니까 `obj.compute(4)`를 호출하면 `Parent`의 `compute`가 아니라 **`Child`의 `compute`**가 실행되는 거임.

그럼 `Child`의 `compute(4)`를 따라가 보자.

*   `compute(4)` -> `compute(3) + compute(1)` 호출
*   `compute(1)`은 `num <= 1` 조건 만족하니까 `1` 반환.
*   `compute(3)` -> `compute(2) + compute(0)` 호출
*   `compute(0)`은 `num <= 1` 조건 만족하니까 `0` 반환.
*   `compute(2)` -> `compute(1) + compute(-1)` 호출
*   `compute(1)`은 `1` 반환.
*   `compute(-1)`은 `num <= 1` 조건 만족하니까 `-1` 반환.
*   따라서 `compute(2)`는 `1 + (-1)` = `0` 반환.
*   다시 `compute(3)`으로 돌아와서, `compute(2) + compute(0)` = `0 + 0` = `0` 반환.
*   마지막으로 `compute(4)`는 `compute(3) + compute(1)` = `0 + 1` = `1` 반환.

그래서 최종 결과는 **1**이 출력됨. ㅇㅋ?

**주요 포인트:**

*   **메소드 오버라이딩(Method Overriding)**: 자식 클래스에서 부모 클래스의 메소드를 재정의하는 것.
*   **다형성(Polymorphism) / 동적 메소드 디스패치**: 상위 클래스 타입의 참조 변수가 하위 클래스의 인스턴스를 참조할 때, 오버라이딩된 메소드를 호출하면 실제 인스턴스(하위 클래스)의 메소드가 실행된다. (`Parent obj = new Child();` 에서 `obj.compute()` 호출 시 `Child`의 `compute` 실행)
*   **재귀 함수 추적**: 재귀 호출의 흐름을 따라가며 각 단계의 반환 값을 정확히 계산해야 한다. 특히 베이스 케이스(`num <= 1`)를 주의 깊게 확인해야 한다.
# 2022 기출 01회 해설

### 1번 문제

**문제:** 다음 C언어 프로그램의 출력 결과를 2차원 배열의 형태로 <답란>에 작성하시오

```c
int check();
int main(){
    int mines[4][4] = {{0,1,0,1},{0,0,0,1},{1,1,1,0},{0,1,1,1,}};
    int field[4][4] = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}};
    int w = 4, h = 4, y, x, i, j;
    for(y=0; y<h; y++){
        for(x=0; x<w; x++){
            if(mines[y][x]==0) continue;
            for(i=y-1; i<=y+1; i++){
                for(j=x-1; j<=x+1; j++){
                    if(check(w,h,i,j) == 1){
                        field[i][j] += 1;
                    }
                }
            }
        }
    }
    for(y=0; y<h; y++){
        for(x=0; x<w; x++)
            printf("%d", field[y][x]);
        printf("\n");
    }
}
int check(int w, int h, int j, int i){
    if(i>=0 && i < h && j >= 0 && j < w) return 1;
    return 0;
}
```

**답변:**

아 ㅋㅋ 안녕? 어디보자 C언어 코드네? 지뢰찾기 비슷한 거 만드는 거 같은데? ㅋㅋ 함 봐보자고.

일단 코드를 딱 보면 `main` 함수랑 `check` 함수가 있네.

1.  **`main` 함수:**

    - `mines[4][4]` 배열: 이게 지뢰밭이야. 1 박힌 곳이 지뢰 있는 곳.
      ```
      0 1 0 1
      0 0 0 1
      1 1 1 0
      0 1 1 1
      ```
    - `field[4][4]` 배열: 여긴 주변 지뢰 개수 표시할 판인데, 첨엔 싹 다 0으로 깔아놨네.
    - `w=4, h=4`: 가로 세로 크기. 뭐 당연히 4x4니까.
    - 이제 `for` 루프 뺑뺑이 도는 걸 보자. `y`랑 `x`로 `mines` 배열 전체를 훑어보네.
    - `if(mines[y][x]==0) continue;`: 이게 핵심이다 ㅋㅋ. 현재 칸 `(y, x)`에 지뢰가 없으면(0이면) 밑에 로직 다 쌩까고 다음 칸으로 넘어감. 즉, **지뢰가 있는 칸만 가지고 뭔가 한다는 거.**
    - 지뢰를 찾으면? 그 안쪽 `for` 루프 두 개가 또 돌지. `i`는 `y-1`부터 `y+1`까지, `j`는 `x-1`부터 `x+1`까지. 이게 뭐겠냐? 지뢰칸 `(y, x)` 기준으로 주변 8칸 + 자기 자신까지 포함해서 3x3 영역을 도는 거야.
    - `if(check(w,h,i,j) == 1){ ... }`: 근데 무턱대고 다 도는 게 아니라 `check` 함수로 좌표 `(i, j)`가 유효한 범위(0~3) 안에 있는지 확인하네. 배열 범위 벗어나면 안 되니까.
    - `field[i][j] += 1;`: `check` 함수 통과하면, 즉 유효한 좌표면 `field` 배열의 해당 칸 `(i, j)` 값을 1 증가시킨다. 이게 뭔 뜻이겠어? "야, 내 주변들아(나 포함), 나 여기 지뢰(`mines[y][x]==1`) 있다!" 라고 알려주면서 주변 애들(`field[i][j]`) 카운트를 하나씩 올려주는 거지.

2.  **`check` 함수:**

    - 이건 간단함. `i`랑 `j` 좌표 받아서 배열 크기 `w`, `h` 범위 안에 있으면 1(참) 리턴, 아니면 0(거짓) 리턴. 배열 인덱스 에러 방지용 헬퍼 함수인 셈이지. 아 근데 파라미터 이름이 `j`, `i` 순서인데 `main`에서 `i`, `j` 넘겨주네? 헷갈리게 짜놨지만 C에서는 그냥 순서대로 값이 들어가는 거라 `check` 함수의 `j`에는 `main`의 `i`(행) 값이, `check` 함수의 `i`에는 `main`의 `j`(열) 값이 들어감. 결과적으론 `if(j>=0 && j < h && i >= 0 && i < w)` 이렇게 비교하는 거랑 같음. 즉, 행(`j`)은 0~`h-1`, 열(`i`)은 0~`w-1` 사이에 있는지 제대로 체크함. ㅋㅋ 헷갈리게 짰누.

3.  **결과 출력:**
    - 마지막 `for` 루프는 최종적으로 계산된 `field` 배열 값을 쭉 출력하는 거. `printf("%d", ...)` 이니까 숫자만 따닥따닥 붙여서 출력하고, 한 행 끝나면 `printf("\n")`으로 줄바꿈.

자 그럼 `mines` 배열 보면서 `field` 배열 값이 어떻게 변하는지 직접 돌려보자고. (위에 생각하는 과정에서 내가 직접 돌려봤으니 결과만 바로 보여줄게 ㅋㅋ 귀찮잖아)

지뢰 위치 (`mines[y][x] == 1`) 마다 그 주변 3x3 영역의 `field` 값을 1씩 증가시키는 거야.

- `mines[0][1]=1` -> 주변 6칸 +1
- `mines[0][3]=1` -> 주변 6칸 +1
- `mines[1][3]=1` -> 주변 6칸 +1
- `mines[2][0]=1` -> 주변 6칸 +1
- `mines[2][1]=1` -> 주변 9칸 +1
- `mines[2][2]=1` -> 주변 9칸 +1
- `mines[3][1]=1` -> 주변 6칸 +1
- `mines[3][2]=1` -> 주변 6칸 +1
- `mines[3][3]=1` -> 주변 4칸 +1

이걸 다 더하면 `field` 배열은 이렇게 된다.

```
1132
3453
3564
3553
```

그래서 <답란>에는 이렇게 적으면 됨.

```
1132
3453
3564
3553
```

---

**주요 포인트:**

- **2차원 배열 순회:** 중첩 `for`문을 이용해서 2차원 배열의 모든 원소를 접근하는 방법.
- **주변 요소 탐색:** 특정 원소 `(y, x)`를 기준으로 주변 8개(또는 자신 포함 9개) 원소를 접근하려면 `for(i=y-1; i<=y+1; i++)`, `for(j=x-1; j<=x+1; j++)` 패턴을 사용함.
- **경계 검사 (Boundary Check):** 배열 인덱스가 유효한 범위 내에 있는지 확인하는 `check` 함수 같은 로직은 필수임. 배열 인덱스 에러 방지!
- **로직 흐름 제어 (`continue`):** 특정 조건(`mines[y][x]==0`)일 때 나머지 로직을 건너뛰고 다음 반복으로 넘어가는 `continue` 키워드 활용법.
- **값 누적:** `field[i][j] += 1` 처럼 특정 조건 만족 시 값을 계속 더해나가는 누산(Accumulation) 로직.

---

### 2번 문제

**문제:** 다음 관계대수 연산자 이름에 대한 연산자 기호 (1) ~ (5)를 작성하시오.

```
| 연산자 이름 | 연산자 기호 |
| 합집합 | (1) |
| 차집합 | (2) |
| 카티션 프로덕트 | (3) |
| 프로젝트 | (4) |
| 조인 | (5) |
```

**답변:**

아 ㅋㅋ 관계대수? 그거 데이터베이스 할 때 배우는 거 맞지? 연산자 기호 물어보는 거구만. 오케이 바로 간다.

1.  **합집합 (Union):** 이건 뭐 수학시간에도 배우는 거 아니냐? **∪** 이거 쓰면 됨. 두 테이블 합치는 거.
2.  **차집합 (Difference):** 빼는 거니까 당연히 **-** 이거지 ㅋㅋ 쉽네. A - B 하면 A에는 있는데 B에는 없는 거 찾는 거.
3.  **카티션 프로덕트 (Cartesian Product):** 이름은 좀 간지나는데 그냥 곱하기임. 두 테이블 모든 행 조합 다 만드는 거. **×** 이거 쓰면 된다.
4.  **프로젝트 (Project):** 이건 테이블에서 원하는 **열(세로)**만 뽑아내는 거. 그리스 문자 파이 **Π** 이거 쓴다.
5.  **조인 (Join):** 테이블 두 개를 특정 조건 기준으로 합치는 거잖아? 제일 많이 쓰는 거. **⋈** 나비넥타이 모양 이거 쓰면 정답. (가끔 세타조인처럼 아래 첨자로 조건을 쓰기도 함)

정리하면:
(1) ∪
(2) -
(3) ×
(4) Π
(5) ⋈

뭐 이 정도면 알겠지? ㅋㅋ

---

**주요 포인트:**

- **관계대수:** 관계형 데이터베이스에서 원하는 데이터를 얻기 위해 사용하는 **절차적 언어**임. SQL 같은 거 배울 때 이론적 기초가 되는 놈.
- **연산자 기호:** 각 연산(합집합, 차집합, 프로젝트 등)을 나타내는 고유한 기호를 알아야 함. 이게 문제에 자주 나옴.
- **집합 연산 vs 순수 관계 연산:** 합집합, 차집합, 카티션 프로덕트는 집합 이론 기반이고, 프로젝트, 셀렉트(여기선 안 물어봤지만 σ 기호 씀), 조인 등은 관계 데이터베이스 고유 연산임. 구분하면 좋음.

---

### 3번 문제

**문제:** 다음 (1), (2)에 해당하는 디자인 패턴을 영문으로 작성하시오

```
(1) Pattern : 기능과 구현을 분리하여 독립적으로 변형과 확장이 가능하도록 결합도를 낮춘 패턴으로, 인터페이스와 구현 사이의 계층을 만들어 둘을 분리시킴으로써 서로의 변경에 독립적으로 대처한다.
(2) Pattern : 한 객체의 상태 변화를 감지하여 다른 객체의 상태로 연동되도록 일대다 객체에 의존 관계를 구성하는 패턴으로, 객체의 상태가 업데이트되면 객체에 의존하는 다른 객체에 알리고 자동으로 내용을 갱신한다.
```

**답변:**

오 디자인 패턴 문제? 이거 완전 시험 단골이지 ㅋㅋ 어디 함 보자고.

(1) **기능이랑 구현 분리**, **결합도 낮춤**, **독립적 확장**... 딱 보니까 인터페이스랑 실제 구현부를 나눠서 서로 영향 덜 받게 하려는 거네. 마치 리모컨(기능, 인터페이스)이랑 TV 본체(구현)를 따로 업그레이드할 수 있게 만드는 것처럼? 이런 걸 **다리(Bridge)** 역할이라고 해서 **Bridge** 패턴이라고 부름 ㅋㅋ. 기능 계층이랑 구현 계층 사이에 다리를 놓는 거지.

(2) **상태 변화 감지**, **다른 객체에 연동**, **일대다 의존**, **자동 갱신**... 이건 뭐냐? 한 놈 상태 바뀌면 걔한테 의존하는 다른 놈들한테 자동으로 "야 나 상태 바뀜!" 하고 알려주는 거잖아. ㅋㅋ 마치 옵저버(관찰자)들이 주시하고 있다가 변화 생기면 바로 알아채는 거랑 비슷하지? 그래서 **Observer** 패턴임. 발행-구독(Publish-Subscribe) 모델 생각하면 이해하기 쉬울 걸?

그러니까 답은 이거임.

(1) **Bridge**
(2) **Observer**

---

**주요 포인트:**

- **Bridge 패턴:** **추상(Abstraction)과 구현(Implementation)을 분리**해서 각각 독립적으로 변경하고 확장할 수 있게 하는 패턴. **결합도를 낮추는 게 핵심**이야. 기능 추가/변경이랑 실제 구현 코드 변경이 서로에게 주는 영향을 최소화함.
- **Observer 패턴:** 한 객체(**Subject**, 또는 Publisher)의 **상태 변화**를 여러 다른 객체(**Observer**, 또는 Subscriber)들에게 **자동으로 알리고 업데이트**하는 **일대다(one-to-many) 의존 관계**를 정의하는 패턴. 이벤트 처리나 MVC 패턴 등에서 자주 쓰임.

---

### 4번 문제

**문제:** 다음 C언어 프로그램의 실행 결과를 작성하시오 (단, 제시된 코드는 Java 코드임)

```java
public class Main{
    public static void main(String[] args){
        int[] rank = new int[5];
        int[] array = {77, 32, 10, 99, 50};
        for(int x = 0; x < 5; x++){
            rank[x] = 1;
            for(int y = 0; y < 5; y++) {
                if(array[x] < array[y]) rank[x]++;
            }
        }
        for(int x = 0; x < 5; x++){
            System.out.print(rank[x]);
        }
    }
}
```

**답변:**

야 ㅋㅋ 이거 근데 C언어 아니고 Java 코드인데? `public class Main` 딱 보니 알겠네 ㅋㅋ 뭐 그래도 푸는 데는 지장 없으니 함 보자고.

이 코드는 배열 `array`에 있는 숫자들의 순위를 매겨서 `rank` 배열에 저장하고 출력하는 거네.

1.  `array` 배열: `{77, 32, 10, 99, 50}` 이렇게 다섯 개 숫자가 들어있음.
2.  `rank` 배열: 크기 5짜리 배열인데, 각 숫자의 순위를 저장할 거임.
3.  **핵심 로직 (중첩 `for`문):**
    - 바깥 `for`문 (`x`): `array`의 각 숫자(기준 숫자)를 하나씩 선택함.
    - `rank[x] = 1;`: 일단 모든 숫자는 기본 1등으로 시작함.
    - 안쪽 `for`문 (`y`): 기준 숫자 `array[x]`를 배열 내의 모든 숫자 `array[y]`와 비교함.
    - `if(array[x] < array[y]) rank[x]++;`: 만약 기준 숫자(`array[x]`)가 비교 대상(`array[y]`)보다 **작으면** `rank[x]` 값을 1 증가시킴. 즉, 나보다 큰 숫자를 만날 때마다 등수가 하나씩 밀려나는 방식이지.

자, 그럼 `array` 값 가지고 순위를 매겨보자.

- **77 (x=0):**
  - `rank[0]`=1 로 시작.
  - 99 만 77보다 크네? (`array[0] < array[3]`)
  - `rank[0]`가 1 증가해서 **2**가 됨. -> 최종 **2등**
- **32 (x=1):**
  - `rank[1]`=1 로 시작.
  - 77, 99, 50 이 32보다 크네? (`array[1]` < `array[0]`, `array[3]`, `array[4]`)
  - `rank[1]`이 3번 증가해서 **4**가 됨. -> 최종 **4등**
- **10 (x=2):**
  - `rank[2]`=1 로 시작.
  - 77, 32, 99, 50 이 10보다 크네? (`array[2]` < `array[0]`, `array[1]`, `array[3]`, `array[4]`)
  - `rank[2]`가 4번 증가해서 **5**가 됨. -> 최종 **5등**
- **99 (x=3):**
  - `rank[3]`=1 로 시작.
  - 99보다 큰 숫자가 없네?
  - `rank[3]`은 그대로 **1**임. -> 최종 **1등**
- **50 (x=4):**
  - `rank[4]`=1 로 시작.
  - 77, 99 가 50보다 크네? (`array[4]` < `array[0]`, `array[3]`)
  - `rank[4]`가 2번 증가해서 **3**이 됨. -> 최종 **3등**

그래서 최종 `rank` 배열은 `{2, 4, 5, 1, 3}`이 된다.

마지막 `for`문에서 `rank` 배열 값들을 `System.out.print`로 찍으니까 줄바꿈 없이 쭉 이어서 출력되겠지?

**실행 결과:**

```
24513
```

---

**주요 포인트:**

- **랭킹 알고리즘:** 배열 내 요소들의 순위를 결정하는 기본적인 방법. 각 요소를 다른 모든 요소와 비교하여 자신보다 큰(또는 작은) 요소의 개수를 세어 순위를 매김. (이 코드는 자신보다 **큰** 값의 개수 + 1로 순위를 계산함)
- **중첩 반복문 (Nested Loop):** 배열의 모든 요소 쌍을 비교하기 위해 중첩 `for`문을 사용하는 것은 흔한 패턴.
- **배열 사용:** 입력 데이터(`array`)와 결과 데이터(`rank`)를 저장하기 위해 배열을 활용함.
- **Java 기본 문법:** 클래스 정의, `main` 메소드, 배열 선언 및 초기화, `for` 루프, 조건문(`if`), 표준 출력(`System.out.print`) 등 기본적인 Java 문법 이해가 필요함. (비록 C 문제라고 나왔지만 ㅋㅋ)

---

### 5번 문제

**문제:** 192.168.1.0/24 네트워크를 FLSM 방식을 사용하여 3개의 Subnet으로 나누고 IP Subnet-Zero를 적용하였을 경우 2번째 네트워크의 Broadcast 주소를 작성하시오.

**답변:**

오 ㅋㅋ 서브네팅 문제 나왔네. IP 주소 계산하는 거. 이거 정신 바짝 차려야 함. 보자고.

1.  **주어진 네트워크:** `192.168.1.0/24`

    - `/24` 이게 서브넷 마스크인데, `255.255.255.0` 이랑 같은 말임. 앞에 24비트가 네트워크 부분이고, 뒤에 8비트가 호스트 부분이라는 뜻.

2.  **요구 조건:** 3개의 서브넷으로 나눠라. 근데 **FLSM (Fixed Length Subnet Mask)** 방식 쓰라고 함. 이게 뭐냐면, 나누는 모든 서브넷의 크기가 같아야 한다는 거임.

    - 3개를 만들려면, 2의 거듭제곱 중에서 3보다 크거나 같은 최소값을 찾아야 함. 2¹=2 (모자람), 2²=4 (오케이!). 즉, FLSM으로는 3개를 딱 맞게 나눌 순 없고, **최소 4개의 서브넷**을 만들어야 3개를 쓸 수 있음.
    - 4개 서브넷(2²)을 만들려면, 원래 호스트 비트에서 **2비트**를 빌려와서 서브넷 비트로 써야 함.

3.  **새로운 서브넷 마스크 계산:**

    - 원래 마스크: `/24`
    - 빌려온 비트 수: 2비트
    - 새로운 마스크: `/24 + 2 = /26`
    - `/26` 마스크는 `11111111.11111111.11111111.11000000` 이거니까, 십진수로 바꾸면 `255.255.255.192` 임.

4.  **서브넷 크기 계산:**

    - 전체 IPv4 비트: 32비트
    - 새로운 서브넷 마스크 비트: 26비트
    - 남은 호스트 비트: 32 - 26 = 6비트
    - 각 서브넷당 IP 주소 개수: 2⁶ = 64개. (0부터 63까지)

5.  **서브넷 나누기 (IP Subnet-Zero 적용):**

    - IP Subnet-Zero 적용하라고 했으니, 첫 번째 서브넷(서브넷 비트가 전부 0인 거)도 사용 가능함.
    - 서브넷은 64개씩 끊어서 나뉨. 마지막 옥텟(네 번째 자리)만 보면 됨.
    - 1번째 서브넷 네트워크 주소: `192.168.1.0` (0부터 63까지)
    - **2번째 서브넷 네트워크 주소:** `192.168.1.64` (64부터 127까지)
    - 3번째 서브넷 네트워크 주소: `192.168.1.128` (128부터 191까지)
    - 4번째 서브넷 네트워크 주소: `192.168.1.192` (192부터 255까지)

6.  **2번째 네트워크의 브로드캐스트 주소 찾기:**
    - 2번째 서브넷의 범위는 `192.168.1.64` 부터 `192.168.1.127` 까지임.
    - 네트워크 주소는 그 범위의 첫 번째 주소 (`192.168.1.64`).
    - **브로드캐스트 주소**는 그 범위의 **마지막 주소**임.
    - 따라서 2번째 네트워크의 브로드캐스트 주소는 **`192.168.1.127`** 이 된다.

**답:**

```
192.168.1.127
```

---

**주요 포인트:**

- **서브넷 마스크 (CIDR):** `/` 뒤 숫자는 네트워크 비트 수를 나타냄. 이걸로 네트워크/호스트 부분을 구분함.
- **FLSM (Fixed Length Subnet Mask):** 모든 서브넷의 크기(IP 주소 개수)가 동일함. 필요한 서브넷 개수 이상을 포함하는 최소 2의 거듭제곱 개수만큼 서브넷을 만들어야 함. (3개 필요 -> 2²=4개 생성)
- **서브넷 비트 빌리기:** 필요한 서브넷 개수(2ⁿ)만큼 기존 호스트 비트에서 n개를 빌려와 서브넷 비트로 사용함.
- **서브넷 주소 계산:** 네트워크 주소는 범위의 시작 주소, 브로드캐스트 주소는 범위의 마지막 주소임. 각 서브넷은 2^(남은 호스트 비트 수) 크기만큼 증가함.
- **IP Subnet-Zero:** 특별한 언급 없거나 적용하라고 하면, 첫 번째 서브넷(All-zero subnet)도 사용 가능한 것으로 간주함. (옛날 장비는 안되는 경우도 있었음)

---

### 6번 문제

**문제:** 다음의 테스트 방식에 대한 테스트 명칭을 <보기>를 참조하여 작성하시오

```
학점관리 시스템 테스트
- A학점 : 100~90점, B학점 : 89~80, C학점 : 79~70, D학점 : 69~60, F학점 : 59~0점의 점수를 입력했을 떄, 학점이 정확히 출력되는지 테스트 케이스를 작성하여 검증한다.

[학생]
| 구간 | 평가 |
| 100~90 | A |
| 89~80 | B |
| 79~70 | C |
| 69~60 | D |
| 59~0 | F |

[테스트 케이스]
| 처리 내용 | 입력 데이터 | 예상 결과 |
| A를 출력하도록 입력 | 100, 99, 91, 90 | A |
| B를 출력하도록 입력 | 89, 81, 80 | B |
| C를 출력하도록 입력 | 79, 71, 70 | C |
| D를 출력하도록 입력 | 69, 61, 60 | D |
| F를 출력하도록 입력 | 59, 1, 0 | F |
| 오류 메시지 출력하도록 입력 | 101, -1 | 오류 메시지 |
```

```
<보기>
Equivalence Partitioning, Classification Tree Method, Boundary Value Analysis, State Transition Testing, Decision Table Testing, Cause-effect Graphing, Combinatorial Test Technical, Scenario Testing, Use Case Testing
```

**답변:**

아 ㅋㅋ 테스트 기법 문제네. 이거 보니까 학점 주는 기준(구간) 나눠놓고, 그 구간 경계값이랑 경계 바로 바깥 값들 위주로 테스트 케이스 뽑은 거잖아?

봐봐. A학점 구간이 100~90점인데, 테스트 케이스로 100점, 90점 (경계값) 넣고, 또 99, 91 (내부값) 넣었지? 다른 구간도 마찬가지로 89, 80 (B 경계), 79, 70 (C 경계), 69, 60 (D 경계), 59, 0 (F 경계) 이런 식으로 경계값들을 집중적으로 테스트하고 있네. 심지어 101, -1 처럼 유효 범위를 벗어나는 값(경계 바로 바깥 값)까지 테스트해서 오류 처리 잘 되는지도 보고 있잖아.

이렇게 유효한 입력값 범위(Equivalence Partition)를 나눈 다음에, 그 **경계(Boundary)**에 있는 값들이랑 경계 바로 옆에 있는 값들을 집중적으로 테스트하는 기법을 뭐라고 하겠냐? 딱 봐도 **경계값 분석 (Boundary Value Analysis)** 이지 ㅋㅋ. 오류는 보통 경계 지점에서 많이 터지거든.

<보기>에 딱 있네. **Boundary Value Analysis**.

**답:**

```
Boundary Value Analysis
```

---

**주요 포인트:**

- **블랙박스 테스트 기법:** 내부 구조는 모르고 입력/출력만 보고 테스트하는 방식 중 하나임.
- **경계값 분석 (Boundary Value Analysis):** 입력 조건의 **경계값** (최소값, 최대값, 바로 위/아래 값 등)에서 오류가 발생할 확률이 높다는 경험적 사실에 기반한 테스트 기법. 유효/무효 파티션의 경계 지점을 집중적으로 테스트함.
- **Equivalence Partitioning (동등 분할)과의 관계:** 경계값 분석은 동등 분할 기법을 보완하는 경우가 많음. 먼저 동등 분할로 입력값 범위를 나누고, 각 분할의 경계값을 중심으로 테스트 케이스를 선정하는 식임.

---

### 7번 문제

**문제:** 다음 <테이블 생성 및 튜플 추가>로 테이블을 생성하였다. 생성된 테이블에 대하여 <SQL문> (1), (2)의 실행 결과를 작성하시오. (컬럼명은 제외한 결과만 작성하시오)

```sql
CREATE TABLE 부서
(
    부서코드 INT,
    부서명 VARCHAR(10),
    PRIMARY KEY (부서코드)
    );

CREATE TABLE 직원
(
    직원번호 INT,
    직원이름 VARCHAR(10),
    부서코드 INT,
    PRIMARY KEY (직원번호),
    FOREIGN KEY (부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE
    );

INSERT INTO 부서 (부서코드, 부서명) VALUES (1, '기획부');
INSERT INTO 부서 (부서코드, 부서명) VALUES (2, '인사부');
INSERT INTO 부서 (부서코드, 부서명) VALUES (3, '홍보부');

INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1001, '이영진', 1);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1002, '김영진', 2);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1003, '성영진', 3);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1004, '최영진', 2);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1005, '구영진', 2);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1006, '우영진', 1);
INSERT INTO 직원 (직원번호, 직원이름, 부서코드) VALUES (1007, '황영진', 3);
```

```sql
(1) SELECT DISTINCT COUNT(직원번호) FROM 직원 WHERE 부서코드 = 2;
(2) DELETE FROM 부서 WHERE 부서코드 = 2; SELECT DISTINCT COUNT(직원번호) FROM 직원;
```

**답변:**

오케이 SQL 문제네. 테이블 만들고 데이터 넣고, 그 다음 쿼리 날리는 거. `ON DELETE CASCADE` 이게 함정일 수 있으니 잘 봐야 함 ㅋㅋ.

**테이블 상태:**

- **부서:**
  - (1, '기획부')
  - (2, '인사부')
  - (3, '홍보부')
- **직원:**
  - (1001, '이영진', 1)
  - (1002, '김영진', 2)
  - (1003, '성영진', 3)
  - (1004, '최영진', 2)
  - (1005, '구영진', 2)
  - (1006, '우영진', 1)
  - (1007, '황영진', 3)

**<SQL문> (1) 분석:** `SELECT DISTINCT COUNT(직원번호) FROM 직원 WHERE 부서코드 = 2;`

1.  `WHERE 부서코드 = 2`: `직원` 테이블에서 `부서코드`가 2인 애들만 골라냄.
    - (1002, '김영진', 2)
    - (1004, '최영진', 2)
    - (1005, '구영진', 2)
    - 총 3명 있네.
2.  `COUNT(직원번호)`: 골라낸 애들의 `직원번호` 개수를 셈. 3개지.
3.  `DISTINCT`: `COUNT` 결과값인 숫자 `3`에 대해서 `DISTINCT`를 적용함. 숫자 하나에 `DISTINCT` 해봤자 그냥 그 숫자 그대로임. 즉, 결과는 여전히 `3`. (만약 `SELECT DISTINCT 부서코드 ...` 였으면 결과가 달라졌겠지만, `COUNT` 결과에 대한 `DISTINCT`임)

**(1) 실행 결과:**

```
3
```

**<SQL문> (2) 분석:** `DELETE FROM 부서 WHERE 부서코드 = 2; SELECT DISTINCT COUNT(직원번호) FROM 직원;`

이건 두 개의 명령어가 순서대로 실행되는 거야.

1.  **`DELETE FROM 부서 WHERE 부서코드 = 2;`**

    - `부서` 테이블에서 `부서코드`가 2인 '인사부' 데이터를 삭제함.
    - **여기서 중요!** `직원` 테이블 만들 때 `FOREIGN KEY (부서코드) REFERENCES 부서(부서코드) ON DELETE CASCADE` 라고 정의했잖아? 이게 뭐냐면, 참조하고 있는 `부서` 테이블의 데이터가 삭제되면(`DELETE`), 관련된 `직원` 테이블 데이터도 **연쇄적으로(CASCADE)** 삭제하라는 뜻임.
    - 따라서 '인사부'(부서코드 2)가 삭제되면서, `직원` 테이블에서 `부서코드`가 2인 직원들도 **같이 삭제됨**.
      - (1002, '김영진', 2) 삭제됨
      - (1004, '최영진', 2) 삭제됨
      - (1005, '구영진', 2) 삭제됨
    - 이제 `직원` 테이블에는 부서코드 1과 3인 직원만 남음.
      - (1001, '이영진', 1)
      - (1003, '성영진', 3)
      - (1006, '우영진', 1)
      - (1007, '황영진', 3)
      - 총 4명 남았네.

2.  **`SELECT DISTINCT COUNT(직원번호) FROM 직원;`**
    - 이제 **변경된 `직원` 테이블** (인사부 직원들 다 삭제된 상태)에서 `직원번호` 개수를 셈.
    - 남은 직원은 4명.
    - `COUNT(직원번호)`는 4.
    - 여기에 `DISTINCT` 적용해도 결과는 그대로 4.

**(2) 실행 결과:**

```
4
```

---

**주요 포인트:**

- **SQL 실행 순서:** 여러 SQL문이 있으면 순서대로 실행되고, 이전 명령이 다음 명령에 영향을 줌.
- **COUNT 함수:** 테이블에서 조건에 맞는 행(row)의 개수를 세는 집계 함수.
- **DISTINCT 키워드:** 중복된 값을 제거하는 키워드인데, `COUNT` 같은 집계 함수의 결과(숫자 하나)에 적용될 때는 보통 의미가 없음. `SELECT DISTINCT 컬럼명 ...` 처럼 컬럼 값 자체의 중복을 제거할 때 주로 사용됨.
- **FOREIGN KEY 제약 조건:** 테이블 간의 관계를 정의함.
- **ON DELETE CASCADE 옵션:** 외래 키 제약 조건에서 중요한 옵션. 참조되는 테이블(여기선 `부서`)의 행이 삭제될 때, 해당 행을 참조하는 테이블(여기선 `직원`)의 행들도 **자동으로 함께 삭제**되도록 함. 이게 이 문제의 핵심 함정임 ㅋㅋ.

---

### 8번 문제

**문제:** 다음의 (1)과 (2)가 설명하는 용어를 작성하시오

```
(1) : 사람들의 신뢰나 무지를 이용하여 정보를 획득하거나 시스템에 침입하는 공격 기법을 말한다. 일반적으로 기술적인 취약점을 이용하는 해킹과 달리, 사람의 심리적인 취약점을 이용하여 공격을 시도한다.
(2) : 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않는 다량의 데이터를 말한다. 처리되 않은 채 미래에 사용할 가능성이 있다는 이유로 삭제되지 않고 방치되어 있어, 저장 공간만 차지하고 보안 위험을 초래할 수 있다.
```

**답변:**

아 ㅋㅋ 보안 용어랑 데이터 관련 용어 문제네. 보자 보자.

(1) 이거 딱 보니까 기술 써서 뚫는 게 아니라, **사람 낚아서** 정보 빼내거나 시스템 들어가는 거네. 뭐 이메일로 그럴싸하게 속여서 비번 알아내거나, 전화해서 내부 정보 슬쩍 물어보거나 그런 거 있잖아. 사람의 **신뢰**나 **무지함**, **심리**를 이용하는 거. 이런 걸 **소셜 엔지니어링 (Social Engineering)** 이라고 부름 ㅋㅋ. 사회공학적 기법이라고도 하지.

(2) 이건 데이터를 엄청 모으긴 했는데, 정작 **분석하거나 써먹지는 않고 그냥 짱박아두는** 거 말하는 거네. "언젠간 쓰겠지~" 하면서 삭제도 안 하고 냅두니까 디스크 공간만 잡아먹고, 혹시 민감한 정보라도 있으면 **보안 사고** 터질 수도 있는 그런 데이터 덩어리. 빛을 못 보고 어둠 속에 묻힌 데이터라고 해서 **다크 데이터 (Dark Data)** 라고 함.

**답:**

(1) **소셜 엔지니어링 (Social Engineering)**
(2) **다크 데이터 (Dark Data)**

---

**주요 포인트:**

- **소셜 엔지니어링 (Social Engineering):** 기술적 해킹이 아닌, **인간의 심리적 허점**이나 사회적 관계를 이용하여 비인가된 정보나 접근 권한을 얻으려는 공격 기법. (예: 피싱, 보이스피싱, 스미싱, 미끼, 위장 등) **보안은 기술뿐 아니라 사람 관리도 중요**하다는 걸 보여주는 대표적인 사례임.
- **다크 데이터 (Dark Data):** 조직이 운영 과정에서 수집/생성했지만, 분석이나 **활용되지 않고 저장만 되어 있는 모든 정보**를 의미함. 저장 비용 발생, 데이터 규정 준수 문제, 보안 위협 등의 잠재적 위험을 내포하고 있음. 빅데이터 시대에 자주 언급되는 개념임.

---

### 9번 문제

**문제:** 다음 Python 프로그램의 실행 결과를 작성하시오

```python
a = [1, 2, 3, 4, 5]
a = list(map(lambda num : num + 100, a))
print(a)
```

**답변:**

오 파이썬 코드네 ㅋㅋ 간단해 보이는데 함 보자고.

1.  `a = [1, 2, 3, 4, 5]` : 리스트 `a`에 1부터 5까지 숫자를 넣었네.
2.  `lambda num : num + 100` : 이건 람다 함수라는 건데, 이름 없는 간단한 함수임. 숫자(`num`) 하나 받아서 거기다 100 더해서 돌려주는 역할을 함.
3.  `map(lambda num : num + 100, a)` : `map` 함수는 리스트 `a`에 있는 각 요소(1, 2, 3, 4, 5)를 하나씩 꺼내서 저 람다 함수에 집어넣고 실행함.
    - 1 들어가면 101 나오고
    - 2 들어가면 102 나오고
    - ...
    - 5 들어가면 105 나오겠지?
    - `map`은 이렇게 처리된 결과들을 묶어서 `map` 객체라는 걸로 만들어줌. (정확히는 이터레이터)
4.  `list(...)` : `map` 객체는 바로 눈에 보이는 리스트 형태가 아니라서, `list()`로 감싸서 우리가 아는 리스트 `[101, 102, 103, 104, 105]` 형태로 바꿔주는 거임.
5.  `a = ...` : 이렇게 만들어진 새 리스트 `[101, 102, 103, 104, 105]`를 다시 변수 `a`에 저장함. 그럼 기존에 있던 `[1, 2, 3, 4, 5]`는 날아가고 `a`는 새 리스트가 되는 거임.
6.  `print(a)` : 마지막으로 `a`를 출력하니까, 최종 결과인 `[101, 102, 103, 104, 105]` 이게 찍히겠지.

**실행 결과:**

```
[101, 102, 103, 104, 105]
```

---

**주요 포인트:**

- **Python 리스트:** 대괄호 `[]`를 사용하여 여러 값을 순서대로 저장하는 자료구조.
- **`lambda` 함수:** 이름 없는 한 줄짜리 간단한 함수를 정의할 때 사용. `lambda 인자 : 표현식` 형태로 씀.
- **`map` 함수:** 함수와 반복 가능한(iterable) 객체를 입력받아, 객체의 각 요소를 함수에 적용한 결과를 묶어서 반환하는 함수. (반환 타입은 `map` 객체, 즉 이터레이터임)
- **`list()` 생성자:** 다른 반복 가능한 객체(튜플, `map` 객체 등)를 리스트로 변환할 때 사용.
- **변수 재할당:** `=` 연산자를 통해 변수에 새로운 값을 할당하면 기존 값은 사라지고 새 값이 저장됨.

---

### 10번 문제

**문제:** 다음 설명이 의미하는 용어를 영문 약어로 작성하시오

```
- 다양한 보안 장비와 서버, 네트워크 장비 등으로부터 보안 로그와 이벤트 정보를 수집한 후 정보들 간의 연관성을 분석하여 위협 상황을 인지하고, 침해사고에 신속하게 대응하는 보안 관제 솔루션이다.
- 방화벽, 안티바이러스 솔루션, 서버, 네트워크 장비 등으로부터 수집한 다양한 로그와 보안 이벤트 데이터를 빅데이터 기반으로 분석한다.
- 보안 위협 징후를 판단할 수 있는 데이터를 생성하고 이 데이터로 보안 사고를 분석하고 예방/대응한다. 또한 로그 관리를 통합적으로 수행하며 네트워크 포렌식과 보안 관련 준수성에 중요한 역할을 담당한다.
```

**답변:**

아 ㅋㅋ 보안 솔루션 용어 묻는 거네. 이거 완전 시험 단골 용어인데? 함 보자.

- **핵심 키워드:** "보안 로그/이벤트 정보 수집", "연관성 분석", "위협 상황 인지", "신속 대응", "보안 관제 솔루션", "빅데이터 기반 분석"

이걸 딱 보면 여러 군데서 들어오는 보안 관련 데이터(로그, 이벤트)를 한 군데로 모아서(수집), 서로 막 엮어보고 분석해서(연관성 분석), "어? 이거 좀 이상한데?" 하는 위협 징후를 찾아내고(위협 인지), 관리자한테 알려줘서 빨리 조치하게(대응) 도와주는 시스템이잖아.

정보(Information) 관리하는 측면이랑 실시간 이벤트(Event) 관리하는 측면을 합친 거임. 그래서 이걸 **Security Information and Event Management** 라고 하고, 약어로는 **SIEM** 이라고 부름.

**답:**

```
SIEM
```

---

**주요 포인트:**

- **SIEM (Security Information and Event Management):** 조직의 IT 인프라 전반에 걸쳐 생성되는 **보안 관련 데이터(로그, 이벤트)를 실시간으로 수집 및 분석**하여 **위협 탐지, 경보, 분석, 보고, 대응을 지원**하는 통합 보안 관리 시스템임.
- **주요 기능:** 로그 수집, 정규화, 상관관계 분석, 실시간 경보, 대시보드, 보고서 생성, 컴플라이언스 지원 등.
- **목표:** 보안 가시성 확보, 위협 탐지 시간 단축, 사고 대응 효율성 증대, 규정 준수 요건 충족.

---

### 11번 문제

**문제:** 다음의 (1), (2), (3)에서 설명하는 형상 관리 도구를 <보기>를 참조하여 작성하시오

```
- 최근 오픈소스 형상 관리 도구로는 ( 1 ), ( 2 ), ( 3 ) 등의 공개 소프트웨어를 많이 사용한다.
- ( 1 )(은)는 클라이언트/서버 구조로 서버는 소스코드 및 기타 문서 파일의 현재 버전과 변경 상태를 저장하고, 클라이언트는 서버에 접속하여 소스코드를 복사한다. 초창기 형상 관리 도구로 서버는 단순한 명령 구조를 가진 장점이 있지만, 텍스트 기반의 코드만 지원하는 단점이 있다.
- ( 2 )(은)는 ( 1 )의 장점은 승계하고 단점을 개선한 GNU의 버전 관리 도구로 다양한 GUI 도구가 존재하고 gzip압축을 통해 서버의 공간을 절약하는 장점을 가지고 있지만, trunk, branch, tag가 모두 저장 위치를 점유하는 단점을 가지고 있다.
- ( 3 )(은)는 앞서 나온 ( 1 )과 ( 2 )의 단점을 모두 보완한 장점이 있으나, 속도 향상에 중점을 둔 분산형 버전 관리 시스템이므로 중앙집중형인 ( 1 )과 ( 2 )과는 개념이 달라 개발자에게 학습할 시간이 필요하다.
- ( 2 )와 ( 3 ) 형상 관리 기능 이외에도 다른 기능의 서드 파트 GUI 환경을 지원한다. 예를 들어 개발자 게시판의 테스트 수행 시 업무 담당자와 개발자 간의 대화 채널을 관리하는 도구까지 제공하고 있으니 형상 관리 도구를 선정하기 전에 서드 파트 지원 도구도 파악하고 설치하는 것이 필요하다.
```

```
<보기>
RCS, SVN, Bitkeeprer, Git, SCCS, CVS
```

**답변:**

오케이 형상 관리 도구 문제네. 설명 보고 <보기>에서 찾는 거. 한번 뜯어보자고 ㅋㅋ.

- **(1) 설명:**

  - 클라이언트/서버 구조
  - 서버가 코드 변경 상태 저장, 클라이언트는 접속해서 복사
  - 초창기 형상 관리 도구
  - 단순 명령 구조
  - 텍스트 기반 코드만 지원 (단점)
  - 이거 완전 초창기 중앙집중식 버전 관리 시스템 설명이잖아? 서버-클라이언트 모델이고 좀 구식이라는 느낌 팍팍 나네. <보기> 중에서 가장 오래되고 대표적인 클라이언트/서버 모델은 **CVS**임. RCS나 SCCS는 더 오래됐지만 보통 단일 파일 대상이고, CVS가 프로젝트 단위 클라이언트/서버 모델의 시초 격이지.

- **(2) 설명:**

  - (1) 장점 승계, 단점 개선 (-> CVS 다음 세대 느낌)
  - GNU 버전 관리 도구 (SVN이 대표적이지)
  - 다양한 GUI 도구 지원
  - gzip 압축으로 서버 공간 절약
  - trunk, branch, tag가 저장 위치 점유 (-> SVN의 특징적인 구조임. 브랜치나 태그가 실제 디렉토리처럼 복사되는 방식)
  - CVS의 단점을 개선해서 나온 게 바로 **SVN(Subversion)**임. 설명이랑 딱 들어맞네 ㅋㅋ.

- **(3) 설명:**
  - (1)과 (2)의 단점 모두 보완 (-> CVS/SVN의 중앙집중식 한계 극복)
  - 속도 향상 중점
  - **분산형 버전 관리 시스템 (Distributed VCS)**
  - 중앙집중형(CVS, SVN)과 개념 다름 -> 학습 필요
  - 이건 뭐 빼박 **Git** 이지 ㅋㅋ. 요즘 제일 핫하고, 분산형이고, 빠르고, SVN/CVS 쓰던 사람은 좀 배워야 하는 거 맞잖아.

자 그럼 정리하면:

(1) **CVS**
(2) **SVN**
(3) **Git**

---

**주요 포인트:**

- **형상 관리 (Configuration Management) / 버전 관리 (Version Control):** 소스 코드나 문서 등의 변경 이력을 관리하고, 여러 사람이 협업할 수 있도록 돕는 시스템.
- **중앙집중형 방식 (Centralized):** 저장소가 중앙 서버에 하나만 존재. 개발자는 중앙 서버에 접속해서 코드 받아오고(checkout), 작업 후 다시 서버에 반영(commit)하는 방식. (예: **CVS**, **SVN**)
  - 장점: 관리 용이, 직관적.
  - 단점: 서버 의존성 높음(서버 터지면 작업 불가), 속도 느릴 수 있음, 브랜치/머지 복잡.
- **분산형 방식 (Distributed):** 모든 개발자가 자신의 로컬 컴퓨터에 완전한 저장소 복제본을 가짐. 로컬에서 commit 가능하고, 나중에 원격 저장소와 동기화하는 방식. (예: **Git**, Mercurial)
  - 장점: 오프라인 작업 가능, 속도 빠름, 브랜치/머지 강력하고 유연함.
  - 단점: 초기 학습 곡선, 저장 공간 더 필요할 수 있음.
- **도구의 발전사:** SCCS/RCS -> CVS -> SVN (CVS 개선) -> Git/Mercurial (분산형으로 패러다임 전환). 이 흐름을 알면 문제 풀기 쉬움.

---

### 12번 문제

**문제:** [학생] 테이블에서 컴퓨터공학과 학생 50명, 건축학과 학생 100명, 화학과 학생 50명의 튜플이 있는 경우 (1), (2), (3)에 해당하는 SQL 쿼리 실행 결과의 튜플수를 각각 작성하시오. (단, 학과 속성명은 'DEPT'이다.)

```sql
(1) SELECT DEPT FROM 학생;
(2) SELECT DISTINCT DEPT FROM 학생;
(3) SELECT COUNT(DISTINCT DEPT) FROM 학생 WHERE DEPT = '건축학과';
```

**답변:**

오케이 SQL 튜플 수 세는 문제네. 이것도 정신 똑바로 차리고 봐야 함 ㅋㅋ.

**상황:**

- 학생 테이블
- 컴퓨터공학과: 50명
- 건축학과: 100명
- 화학과: 50명
- **총 학생 수 (총 튜플 수): 50 + 100 + 50 = 200명**

자 이제 SQL 쿼리 결과를 보자.

**(1) `SELECT DEPT FROM 학생;`**

- 이건 그냥 `학생` 테이블에 있는 모든 행(튜플)에 대해서 `DEPT` 컬럼 값을 다 보여달라는 거임.
- 테이블에 총 200명의 학생 데이터가 있으니까, `DEPT` 값도 200개가 나오겠지? ('컴퓨터공학과' 50번, '건축학과' 100번, '화학과' 50번 이런 식으로 중복 포함해서 다 나옴)
- **결과 튜플 수:** 200

**(2) `SELECT DISTINCT DEPT FROM 학생;`**

- `DISTINCT` 키워드가 핵심! 이건 `DEPT` 컬럼 값 중에서 **중복을 제거하고 유니크한 값만** 보여달라는 거임.
- 학생 테이블에 있는 학과는 '컴퓨터공학과', '건축학과', '화학과' 딱 3종류잖아.
- 따라서 중복 빼고 나면 이 3개의 학과 이름만 결과로 나옴.
- **결과 튜플 수:** 3

**(3) `SELECT COUNT(DISTINCT DEPT) FROM 학생 WHERE DEPT = '건축학과';`**

- 이건 좀 뜯어봐야 함.
  - `WHERE DEPT = '건축학과'`: 먼저 `학생` 테이블에서 `DEPT`가 '건축학과'인 애들만 골라냄. 건축학과 학생은 100명이지? 그러니까 이 조건에 맞는 튜플은 100개임.
  - `DISTINCT DEPT`: 이 100개의 튜플에서 `DEPT` 컬럼의 유니크한 값을 찾음. 근데 이 100명은 전부 '건축학과' 소속이니까, 유니크한 `DEPT` 값은 '건축학과' 딱 하나밖에 없음.
  - `COUNT(...)`: `DISTINCT DEPT`로 찾아낸 유니크한 값의 **개수**를 셈. 유니크한 값이 '건축학과' 하나뿐이니까, 개수는 1임.
  - `SELECT COUNT(...)`: 최종적으로 `COUNT` 함수는 결과값 하나(숫자 1)를 포함하는 단 하나의 튜플을 반환함. 집계 함수 (COUNT, SUM, AVG 등)는 `GROUP BY` 절이 없으면 항상 결과가 1개 튜플임.
- **결과 튜플 수:** 1 (결과 값 자체도 1이지만, 물어본 건 결과 튜플 수니까 1임)

**정리하면:**

(1) 200
(2) 3
(3) 1

---

**주요 포인트:**

- **SQL 실행 순서 (간략히):** `FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` -> `ORDER BY`. WHERE 절이 먼저 적용된다는 걸 아는 게 중요함.
- **DISTINCT 키워드:** `SELECT DISTINCT 컬럼명` 은 해당 컬럼의 **유니크한 값만** 결과로 보여줌 (결과 튜플 수가 줄어듦). `COUNT(DISTINCT 컬럼명)` 은 해당 컬럼의 **유니크한 값의 개수**를 세서 반환함 (결과 튜플 수는 1개).
- **COUNT 함수:** 조건을 만족하는 튜플의 개수를 세는 집계 함수. `GROUP BY` 없이 사용하면 항상 1개의 튜플(결과값 하나)을 반환함.
- **결과 값 vs 결과 튜플 수:** 쿼리가 반환하는 실제 데이터 값과, 그 결과가 몇 줄(튜플)로 이루어져 있는지는 구분해야 함. 이 문제는 **결과 튜플 수**를 물어봤음.

---

### 13번 문제

**문제:** 다음 C언어 프로그램의 실행 결과를 작성하시오.

```c
int main(){
    int num1, num2, num3, p_num = 0;
    for(num1 = 6; num1 <= 30; num1++){
        num2 = num1/2;
        num3 = 0;
        for(int i = 1; i <=num2; i++){
            if(num1%i==0){
                num3=num3+i;
            }
        }
        if(num1==num3){
            p_num++;
        }
    }
    printf("%d", p_num);
    return 0;
}
```

**답변:**

오케이 C언어 코드 또 나왔네. 이거 보니까 숫자 가지고 뭐 하는 거 같은데? 분석 드간다 ㅋㅋ.

1.  **변수:** `num1`, `num2`, `num3`, `p_num` 네 개 선언. `p_num`은 0으로 시작하네. 이게 최종 결과 카운터일 확률이 높음.
2.  **바깥쪽 `for` 루프:** `num1`이 6부터 30까지 1씩 증가하면서 돈다. 즉, 6부터 30까지 숫자를 하나씩 검사하겠다는 거임.
3.  **안쪽 로직:**
    - `num2 = num1 / 2;`: `num1`을 2로 나눈 몫을 `num2`에 저장. 예를 들어 `num1`이 10이면 `num2`는 5.
    - `num3 = 0;`: `num1` 하나 검사 시작할 때마다 `num3`를 0으로 리셋.
    - **안쪽 `for` 루프:** `i`가 1부터 `num2`까지 1씩 증가.
    - `if (num1 % i == 0)`: `num1`을 `i`로 나눴을 때 나머지가 0인지 검사. 즉, `i`가 `num1`의 약수인지 확인하는 거임.
    - `num3 = num3 + i;`: 만약 `i`가 `num1`의 약수면, `num3`에 `i`를 더함.
    - **핵심!** 안쪽 `for` 루프가 끝나면 `num3`에는 `num1`의 약수 중에서 **자기 자신(`num1`)을 제외한 약수들의 합**이 저장됨 (정확히는 1부터 `num1/2`까지의 약수 합인데, 이게 자기 자신을 제외한 약수들의 합과 같음. 이걸 **진약수 합**이라고 함).
4.  **완전수 판별:**
    - `if (num1 == num3)`: 현재 숫자 `num1`과 그 숫자의 진약수 합(`num3`)이 같은지 비교함.
    - 자기 자신을 제외한 약수들의 합이 자기 자신과 같은 수를 **완전수(Perfect Number)**라고 부름.
    - 즉, 이 코드는 `num1`이 완전수인지 검사하는 거임!
    - `p_num++;`: 만약 `num1`이 완전수면, 카운터 `p_num`을 1 증가시킴.
5.  **최종 출력:** 바깥쪽 `for` 루프가 6부터 30까지 다 돌고 나면, 그동안 찾은 완전수의 개수가 저장된 `p_num`을 출력함.

자, 그럼 6부터 30까지 완전수를 찾아보자.

- **6:** 진약수 = 1, 2, 3. 합 = 1+2+3 = 6. 완전수 맞음! (`p_num` = 1)
- 7: 진약수 = 1. 합 = 1. (X)
- 8: 진약수 = 1, 2, 4. 합 = 7. (X)
- ... (쭉 가다가) ...
- **28:** 진약수 = 1, 2, 4, 7, 14. 합 = 1+2+4+7+14 = 28. 완전수 맞음! (`p_num` = 2)
- 29: 진약수 = 1. 합 = 1. (X)
- 30: 진약수 = 1, 2, 3, 5, 6, 10, 15. 합 = 42. (X)

6부터 30 사이의 완전수는 6과 28 두 개네. 따라서 `p_num`은 최종적으로 2가 됨.

**실행 결과:**

```
2
```

---

**주요 포인트:**

- **완전수 (Perfect Number):** 자기 자신을 제외한 양의 약수(진약수)들의 합이 자기 자신과 같은 양의 정수. (예: 6, 28, 496, ...)
- **약수 찾기:** `num % i == 0` 조건을 사용하여 `i`가 `num`의 약수인지 판별함.
- **진약수 합 계산:** 반복문을 통해 1부터 해당 숫자 `n`의 절반(`n/2`)까지 검사하면서 약수들을 더하면 진약수의 합을 효율적으로 구할 수 있음. (자기 자신은 항상 제외됨)
- **카운터 변수:** 특정 조건을 만족하는 횟수를 세기 위해 초기값을 0으로 설정하고 조건 만족 시 1씩 증가시키는 변수(`p_num`)를 활용함.
- **중첩 반복문:** 특정 범위의 각 숫자에 대해 내부적인 계산(약수 합 구하기)을 수행하기 위해 중첩 `for` 루프를 사용함.

---

### 14번 문제

**문제:** 다음이 서명하는 (1)과 (2)에 해당하는 알맞은 용어를 <보기>를 참조하여 작성하시오.

```
- (1)은 ARM 아키텍처에서 사용되는 하드웨어 보안 기술로 하드웨어적으로 안전한 실행 영역인 (1)과 일반적인 실행 영역인 Non (1)를 구분한다. (1)에서는 시스템 보안 관련 작업을 처리하고, Non(1)에서는 일반적인 애플리케이션 작업을 처리하여 보안 위협으로부터 시스템을 보호할 수 있다.
- (2)는 인터넷 사용자들이 일반적으로 많이 방문하는 웹 사이트의 이름을 의도적으로 잘못 입력하여 유저들을 다른 사이트로 유인하려는 행위이다. 예를 들어 "googgle.com" 또는 "facebok.com"과 같이 기존의 인기있는 도메인 이름을 의도적으로 잘못 입력하여 사용자들이 해당 사이트로 이동하면, 이러한 사이트에서는 사용자들의 정보를 수집하거나, 피싱 사이트로 이용될 수 있다. 이러한 행위는 인터넷 사용자들에게 많은 위협을 가하므로, 유저들은 항상 URL을 정확하게 확인하는 습관을 가지는 것이 중요하다.
```

```
<보기>
Secure Enclave, Trust zone, Virtual Secure Mode, Hyper-v, Brandjacking, Typosquatting, Phishing, Cybersquatting
```

**답변:**

오호 보안 용어랑 웹 관련 용어구만. 이것도 시험에 나올 법한 놈들이지 ㅋㅋ.

(1) **ARM 아키텍처**, **하드웨어 보안 기술**, **안전한 실행 영역** vs **일반 실행 영역** 분리... 이거 ARM 프로세서에서 보안 강화를 위해 만든 기술이잖아. 시스템 핵심 동작은 안전한 구역에서 돌리고, 일반 앱은 다른 구역에서 돌려서 서로 간섭 못하게 막는 거. 이 안전한 구역을 **TrustZone** 이라고 부름. Non-(1)은 Non-TrustZone, 즉 일반 영역(Normal World)을 말하는 거지.

(2) **웹사이트 이름 잘못 입력 유도**, **인기 도메인 오타 이용**, **다른 사이트로 유인**, **정보 수집/피싱 목적**... 이건 뭐냐? 구글(google)인데 지오오글(googgle)로 접속 유도하거나 페이스북(facebook)인데 파세복(facebok)으로 치는 실수를 노리는 거잖아 ㅋㅋ. 사용자의 **오타(Typo)**를 이용해서 남의 도메인에 무단으로 **점거(Squatting)**하는 짓거리. 그래서 **Typosquatting (타이포스쿼팅)**이라고 함. URL 하이재킹이라고도 부르긴 하는데, 타이포스쿼팅이 더 정확한 용어임.

**답:**

(1) **TrustZone**
(2) **Typosquatting**

---

**주요 포인트:**

- **TrustZone:** ARM 아키텍처 기반의 **하드웨어 보안 기술**. 프로세서 내에 **보안 영역(Secure World)**과 **일반 영역(Normal World)**을 분리하여, 민감한 데이터 처리나 보안 관련 코드를 일반 운영체제나 애플리케이션으로부터 격리시켜 보호함. 모바일 기기 보안, DRM, 결제 시스템 등에서 활용됨.
- **Typosquatting:** 유명 웹사이트의 도메인 이름과 **유사하거나 철자가 틀린 도메인**을 등록하여, 사용자의 **입력 실수(Typo)**를 이용해 트래픽을 가로채거나 악성 행위(피싱, 멀웨어 유포 등)를 시도하는 공격 기법. URL 하이재킹의 한 종류임.

---

### 15번 문제

**문제:** 다음이 설명하는 용어를 영문 약어로 작성하시오

```
단 한 번의 로그인만으로 기업의 각종 시스템이나 인터넷 서비스에 접속하게 해주는 보안 응용 솔루션이다. 각각의 시스템마다 인증 절차를 밟지 않고도 1개의 계정만으로 다양한 시스템에 접근할 수 있어 ID, 비밀번호에 대한 보안 위험 예방과 사용자 편의 증진, 인증 관리비용의 절감 효과가 있다. 클라이언트 SSL 인증서와 S/MIME 인증서가 포함된 ( ) 솔루션으로 개인 키 데이터베이스에 있는 하나의 키로 로그인하고, 다른 비밀번호 없이 SSL 사용 서버에 접근할 수 있다.
```

**답변:**

아 ㅋㅋ 이것도 보안 용어네. 이거 시험에 자주 나오는 놈인데? 보자고.

- **핵심:** "**단 한 번의 로그인**으로 **여러 시스템이나 서비스에 접속**"
- **부연 설명:** 시스템마다 따로 로그인 안 해도 됨, 계정 하나로 다 접근 가능, 보안/편의성/비용절감 효과.
- **추가 힌트:** 클라이언트 인증서 같은 거 써서 비밀번호 없이도 접근 가능하게 하는 방식도 있다~ (이건 구현 방식 중 하나를 설명하는 거)

이거 딱 보니까 여러 서비스 로그인할 때 아이디/비번 맨날 치는 거 귀찮고 보안에도 안 좋으니까, **한 번만 딱 로그인하면** 다른 데는 알아서 인증 통과시켜주는 그거잖아? ㅋㅋ 이걸 **Single Sign-On**, 우리말로 하면 싱글 사인온이라고 하고, **약어**로는 **SSO**라고 부름.

**답:**

```
SSO
```

---

**주요 포인트:**

- **SSO (Single Sign-On):** **한 번의 사용자 인증** 과정을 통해 **다수의 관련 없는 소프트웨어 시스템이나 서비스에 접근**할 수 있도록 하는 인증 통합 기술임.
- **목표:** 사용자 편의성 증대(매번 로그인 불필요), 보안 강화(패스워드 관리 부담 감소, 중앙 집중 인증), 관리 효율성 증대(계정 관리 간소화).
- **구현 방식:** SAML, OAuth, OpenID Connect, Kerberos 등 다양한 프로토콜과 기술을 사용하여 구현될 수 있음. (문제에서 언급된 인증서 기반 방식도 그중 하나)

---

### 16번 문제

**문제:** 다음은 프로세스 스케줄링 기법에 대한 설명이다. (1), (2), (3)에 들어갈 알맞은 말을 작성하시오

```
( 1 ) 스케줄링
- 대기하는 작업 중 CPU Burst Time이 가장 작은 작업에 CPU를 할당하는 기법이다.
- 주어진 프로세스들의 긴 집합에 대해 최소의 평균 대기시간을 가진다는 장점이 있으나 각 프로세스의 CPU 사용시간을 예측해야 하기 떄문에 현실적이지 못하다.
( 2 ) 스케줄링
- FCFS에 의해서 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간(Time Quantum)을 할당받아 처리된다.
- 프로세스가 주어진 CPU 할당 시간 동안 처리를 완료하지 못하면 그 중앙처리장치는 대기 중인 다음 프로세스로 넘어가며, 실행 중이던 프로세스는 준비 완료 리스트의 가장 뒤로 보내지는 방식으로 스케줄링된다.
( 3 ) 스케줄링
- 새로 도착한 프로세스를 포함하여 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행한다.
- 현재 실행 중인 프로세스라도, 남은 처리 시간이 더 짧다고 판단되는 프로세스가 생기면 언제라도 실행 중인 프로세스가 선점당하기 때문에 기아 상태가 발생할 수 있다.
```

**답변:**

오오 프로세스 스케줄링! 운영체제(OS) 시험 단골 주제지 ㅋㅋ 어디 한번 보자고.

(1) **설명:**

- CPU 버스트 타임(실행 시간) **가장 작은** 작업 먼저 처리.
- 평균 대기 시간 최소화 장점.
- 근데 실행 시간 **미리 알아야 해서 비현실적**.
- 이건 딱 봐도 **최단 작업 우선 (Shortest Job First, SJF)** 스케줄링이네. 가장 짧게 걸릴 놈 먼저 후딱 처리하는 거. 근데 미리 시간을 어케 아냐고 ㅋㅋ 그래서 비현실적이라고 하는 거임.

(2) **설명:**

- 기본은 FCFS(선입선출) 순서인데...
- **똑같은 CPU 시간 (타임 퀀텀)** 할당 받음.
- 시간 다 쓰면 **준비 큐 맨 뒤로** 감.
- 이건 뭐 대표적인 **시분할 시스템** 스케줄링 방식이잖아. 시간을 잘게 쪼개서 돌아가면서 쓰는 거. **라운드 로빈 (Round Robin, RR)** 이라고 부름 ㅋㅋ. 공평하게 기회를 주는 방식이지.

(3) **설명:**

- 새로 들어온 놈 포함해서 **남은 시간 가장 짧은** 놈 먼저 처리.
- **실행 중인 놈도 중단**시키고 더 짧은 놈한테 CPU 뺏길 수 있음 (**선점형**).
- 그래서 실행 시간 긴 놈은 계속 밀려서 **굶어 죽을 수도 있음 (기아 상태)**.
- SJF인데 선점(Preemption)이 가능한 버전이네? 실행 중에 더 짧은 놈 들어오면 바로 바꿔치기하는 거. 이걸 **최단 잔여 시간 우선 (Shortest Remaining Time, SRT)** 스케줄링이라고 함. SJF의 선점형 버전이라고 생각하면 됨.

**답:**

(1) **최단 작업 우선 (SJF)**
(2) **라운드 로빈 (RR)**
(3) **최단 잔여 시간 우선 (SRT)**

_(참고: SJF, RR, SRT 라고 약어로 써도 보통 정답 처리될 거임)_

---

**주요 포인트:**

- **프로세스 스케줄링:** 운영체제가 여러 프로세스에게 CPU 자원을 효율적으로 배분하는 정책/알고리즘.
- **(1) SJF (Shortest Job First):** **비선점형** 방식. CPU 실행 시간이 가장 짧은 프로세스에게 CPU 할당. 평균 대기 시간 최소화 가능하나, 실행 시간 예측 어려움 및 기아 상태(긴 작업) 발생 가능.
- **(2) RR (Round Robin):** **선점형** 방식. 모든 프로세스에게 동일한 시간 할당량(Time Quantum)을 부여하고, 시간 내 미완료 시 준비 큐 맨 뒤로 이동. 시분할 시스템에 적합하며 응답 시간이 빠르지만, 문맥 교환 오버헤드가 잦을 수 있음.
- **(3) SRT (Shortest Remaining Time):** **선점형** 방식. SJF의 선점 버전. 현재 실행 중인 프로세스의 남은 시간보다 더 짧은 실행 시간의 프로세스가 도착하면 CPU를 빼앗김. 평균 대기 시간은 짧지만, 실행 시간 예측 필요 및 기아 상태 발생 가능성은 여전함.

---

### 17번 문제

**문제:** 다음 UML에 대한 설명 중 (1), (2), (3)에 들어갈 알맞은 말을 작성하시오.

```
UML은 모델의 기본 요소인 사물과 사물 간의 관계를 나타내는 관계, 사물들 간의 관계를 도식화한 다이어그램 등으로 구성된다.
- 사물 : 모델 구성의 기본 요소로 추상적인 개념이다. 시스템의 구조와 행위 등을 표현하고 개념들을 그룹화하기 위한 것들로 구성되어 있다.
- ( 1 ) : 사물간의 연결을 추상화하여 표현한다.
- 다이어그램 : 사물들 간의 관계를 도형으로 표현한 것으로, 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움을 준다

UML은 정적 다이어그램과 동적 다이어그램으로 분류할 수 있다. 정적 다이어그램의 종류에는 ( 2 ) 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램등이 있다.
- ( 2 ) 다이어그램은 시스템을 구성하는 ( 2 )와 ( 3 ) 사이의 정적인 관계를 나타내고, 객체 다이어그램은 ( 2 ) 다이어그램에 포함된 사물들의 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현한다. 그리고 컴포넌트 다이어그램은 실제 구현 모듈인 컴포넌트 간의 관계를 표현한다.
```

**답변:**

오케이 UML 문제네. 객체지향 모델링할 때 쓰는 표준 언어 맞지? ㅋㅋ 설명 보고 빈칸 채우는 거. 간다!

1.  **(1) 설명:** "사물간의 연결을 추상화하여 표현한다." UML에서 사물(Things)들을 연결하는 걸 뭐라고 하겠냐? 당연히 **관계 (Relationship)** 지 ㅋㅋ. 선 찍찍 긋고 화살표 달고 하는 거 있잖아.

2.  **(2) 설명:**

    - 정적 다이어그램의 한 종류.
    - 시스템 구성하는 (2)와 (3) 사이의 관계를 보여줌.
    - 뒤에 "객체 다이어그램은 (2) 다이어그램에 포함된 사물들의 인스턴스를..." 라는 설명이 결정적이네. 객체(인스턴스)를 만들기 위한 틀(Blueprint)을 보여주는 다이어그램이 뭐겠냐? 바로 **클래스 (Class)** 다이어그램이지. 이게 가장 기본적이고 중요한 정적 다이어그램임.

3.  **(3) 설명:** (수정된 내용 반영)
    - (2)번이 클래스 다이어그램이었으니까, "클래스 다이어그램은 시스템을 구성하는 **클래스(Class)**와 (3) 사이의 정적인 관계를 나타내고..." 이렇게 되네. 클래스 다이어그램에서 클래스와 함께 중요한 구성 요소이며 클래스와 관계를 맺는 것은 **인터페이스(Interface)**임. 클래스와 인터페이스 간의 관계 (특히 실체화/구현 관계)는 클래스 다이어그램의 핵심적인 내용임.

**답:**

(1) **관계 (Relationship)**
(2) **클래스 (Class)**
(3) **인터페이스 (Interface)**

---

**주요 포인트 (수정 반영):**

- **UML (Unified Modeling Language):** 소프트웨어 모델링 표준 언어.
- **UML 구성 요소:** 사물(Things), **관계(Relationships)**, 다이어그램(Diagrams).
- **정적 다이어그램:** 시스템의 구조 표현 (예: **클래스 다이어그램**, 객체 다이어그램, 컴포넌트 다이어그램).
- **클래스 다이어그램:** 시스템을 구성하는 **클래스(Class)**와 **인터페이스(Interface)**, 그리고 그들의 속성, 메소드, **상호 간의 관계(Relationships)**를 표현하는 핵심 다이어그램. 클래스와 인터페이스 간의 실체화(Realization) 관계 표현이 중요함.

---

### 18번 문제

**문제:** 다음 <E-R 다이어그램>의 ㉠ ~ ㉤을 보고 <표>의 (1) ~ (5)와 연결하시오.
(이미지 대신 사용자가 제공한 설명을 기반으로 재구성)

- **E-R 다이어그램 구성:**

  - ㉠: '학생' 개체 (네모, PK: 학번)
  - '과목' 개체 (네모, PK: 과목코드)
  - ㉤: '수강' 관계 (마름모)
  - ㉡: '성적' 속성 또는 약한 개체 (네모, PK 없음)
  - ㉢: '학생'과 '수강'을 연결하는 실선
  - '과목'과 '수강'을 연결하는 실선 (표시 없음)
  - ㉣: '수강'과 '성적'을 연결하는 점선

- **<표>**
  - (1) : 관계 집합을 표시한다.
  - (2) : 외래키들을 기본키로 사용하지 않고 일반 속성으로 취급하는 비식별 관계를 연결한다.
  - (3) : 개체 집합을 표시한다. 개체 집합의 속성으로 기본키를 명세할 수 있다.
  - (4) : 자신의 개체 속성으로 기본키를 명세 할 수 없는 개체 타입이다.
  - (5) : 식별 관계로 개체 집합의 속성과 관계 집합을 연결한다.

**답변:**

아 ㅋㅋ E-R 다이어그램 보고 표랑 연결하는 거네. 이거 데이터베이스 모델링 기본인데, 기호랑 선 의미만 알면 됨. 답은 이미 안다니까 왜 그런지 설명해주지 ㅋㅋ.

1.  **(1) 관계 집합을 표시한다. <-> ㉤ (수강 마름모)**

    - E-R 다이어그램에서 마름모(◇)는 개체(네모)들 사이의 **관계(Relationship)**를 나타내는 약속임. ㉤은 '수강'이라는 관계를 나타내는 마름모니까 (1) 설명이랑 딱 맞지 ㅋㅋ. 학생이랑 과목이 '수강'이라는 관계를 맺는 거잖아.

2.  **(2) 외래키들을 기본키로 사용하지 않고 일반 속성으로 취급하는 비식별 관계를 연결한다. <-> ㉣ (수강-성적 연결 점선)**

    - 이건 좀 표기법 따라 다른데, 보통 저렇게 점선(㉣)으로 관계(㉤)랑 속성(㉡ '성적')을 연결하면, '성적'이 '수강'이라는 **관계에 종속된 속성**임을 나타내는 경우가 많음. 즉, 성적은 수강이라는 행위가 있어야 발생하는 값이지. 또는 저 선(㉣)이 '비식별 관계'를 나타낸다고 볼 수도 있는데, 이건 '성적'이라는 개체(만약 개체라면)가 '수강'을 통해 연결될 때, 부모(학생, 과목)의 키를 자신의 기본 키 일부로 사용하지 않는다는 의미임. 문제에서는 '성적'을 (4)에서 약한 개체 비슷하게 설명하니까, 이 연결선(㉣)은 그 종속성을 나타내는 비식별 연결로 해석한 듯.

3.  **(3) 개체 집합을 표시한다. 개체 집합의 속성으로 기본키를 명세할 수 있다. <-> ㉠ (학생 네모)**

    - 네모(□)는 **개체(Entity)**를 나타냄. ㉠ '학생'은 딱 봐도 개체고, 안에 '학번'이라고 밑줄 쫙 그은 PK(기본키)까지 제대로 있잖아? 지 혼자서도 잘 서는 강한 개체(Strong Entity)임. (3) 설명이 딱 이거지.

4.  **(4) 자신의 개체 속성으로 기본키를 명세 할 수 없는 개체 타입이다. <-> ㉡ (성적 네모)**

    - ㉡ '성적' 네모 안에는 PK 표시가 없어. 이건 뭐냐면, 성적은 어떤 '학생'이 어떤 '과목'을 '수강'했는지 알아야 고유하게 식별될 수 있다는 뜻임. 즉, **자기 속성만으로는 PK를 만들 수 없는**, 다른 개체에 의존적인 **약한 개체(Weak Entity)** 또는 관계의 속성으로 봐야 함. (4) 설명이랑 일치함.

5.  **(5) 식별 관계로 개체 집합의 속성과 관계 집합을 연결한다. <-> ㉢ (학생-수강 연결 실선)**
    - 저 실선(㉢)은 개체(㉠ 학생)랑 관계(㉤ 수강)를 연결하는 기본적인 선임. 학생 개체가 수강 관계에 참여한다는 걸 보여줌. 학생의 PK(학번)가 수강 관계의 인스턴스를 식별하는 데 필수적이잖아? 이런 연결을 **식별 관계**라고 부름 (특히 약한 개체를 식별할 때 쓰는 관계를 지칭하기도 하지만, 여기선 강한 개체의 참여 연결을 의미하는 듯). 개체(의 속성)와 관계를 연결하는 역할이니까 (5) 설명이 맞음.

**최종 연결 결과:**
(1) : ㉤
(2) : ㉣
(3) : ㉠
(4) : ㉡
(5) : ㉢

오케이? 이렇게 연결되는 거임 ㅋㅋ.

---

**주요 포인트:**

- **E-R 다이어그램 기호:**
  - **사각형(□):** 개체(Entity) 집합 (예: ㉠ 학생, ㉡ 성적)
  - **마름모(◇):** 관계(Relationship) 집합 (예: ㉤ 수강)
  - **타원(○):** 속성(Attribute) (이 그림엔 없지만 기본 요소)
  - **선(—):** 개체와 관계, 또는 관계와 속성을 연결.
- **개체 종류:**
  - **강한 개체 (Strong Entity):** 자신의 속성으로 PK를 가질 수 있는 독립적인 개체 (예: ㉠ 학생).
  - **약한 개체 (Weak Entity):** 다른 개체(Owner Entity)의 PK를 가져와야 자신의 PK를 구성할 수 있는 의존적인 개체 (예: ㉡ 성적). 보통 이중 사각형으로 그림. (여기선 단일 사각형이지만 설명상 약한 개체로 해석)
- **관계 종류:**
  - **식별 관계 (Identifying Relationship):** 주로 강한 개체와 약한 개체를 연결하며, 강한 개체의 PK가 약한 개체의 PK 일부가 되는 관계. (여기서는 강한 개체-관계 연결을 포괄적으로 지칭한 듯)
  - **비식별 관계 (Non-identifying Relationship):** 관계를 맺는 개체들이 서로 독립적이며, 부모 개체의 PK를 자식 개체의 일반 속성(외래키)으로만 사용하는 관계. (점선 ㉣이 이걸 나타내는 것으로 해석됨)
- **관계의 속성:** 관계 자체도 속성을 가질 수 있음 (예: '수강' 관계의 '성적' 속성).

---

### 19번 문제

**문제:** 다음 Java 프로그램의 실행 결과를 작성하시오.

```java
public class Main {
    static int size = 4;
    public static void main(String[] args) throws Exception {
        int[] arr = new int[size];
        Array(arr);
        for(int i = 0; i < size; i++){
            System.out.print(arr[i] + " ");
        }
    }
    public static void Array(int[] arr) {
        for(int i = 0; i < size; i++){
            arr[i] = i;
        }
    }
}
```

**답변:**

오 Java 코드네 ㅋㅋ. 이거 배열가지고 뭐 하는 건지 한번 보자고.

1.  **`static int size = 4;`**: `size`라는 변수에 4를 박아놨네. `static`이니까 이 클래스 어디서든 쓸 수 있음.
2.  **`main` 메소드:**
    - `int[] arr = new int[size];`: 크기가 4인 정수 배열 `arr`을 만듦. 자바에서는 배열 만들면 자동으로 0으로 채워짐. `{0, 0, 0, 0}` 상태.
    - `Array(arr);`: `Array`라는 메소드를 호출하면서 방금 만든 `arr` 배열을 넘겨줌.
3.  **`Array` 메소드:**
    - `public static void Array(int[] arr)`: `main`에서 넘겨준 배열을 받음. **여기서 중요한 거!** 자바에서 배열 같은 객체는 함수에 넘길 때 **주소값(참조값)**이 넘어감. 즉, `Array` 메소드 안에서 `arr`을 건드리면 `main`에 있는 원본 `arr`도 같이 바뀐다는 거임! 이게 핵심 ㅋㅋ.
    - `for(int i = 0; i < size; i++)`: `i`가 0부터 `size-1`(즉, 3)까지 1씩 증가하면서 반복함.
    - `arr[i] = i;`: 배열 `arr`의 `i`번째 자리에 `i` 값을 넣음.
      - `i=0`일 때 `arr[0] = 0`
      - `i=1`일 때 `arr[1] = 1`
      - `i=2`일 때 `arr[2] = 2`
      - `i=3`일 때 `arr[3] = 3`
    - 이 메소드가 끝나면 `main`에 있던 `arr` 배열은 `{0, 1, 2, 3}` 이렇게 바뀜.
4.  **다시 `main` 메소드:**
    - `for(int i = 0; i < size; i++)`: 다시 `i`가 0부터 3까지 반복.
    - `System.out.print(arr[i] + " ");`: 배열 `arr`의 `i`번째 값을 출력하고 뒤에 띄어쓰기 하나 붙임. `println` 아니고 `print`니까 줄바꿈 없음.
      - `i=0`: `arr[0]` (0) 출력 -> `0 `
      - `i=1`: `arr[1]` (1) 출력 -> `0 1 `
      - `i=2`: `arr[2]` (2) 출력 -> `0 1 2 `
      - `i=3`: `arr[3]` (3) 출력 -> `0 1 2 3 `

최종적으로 화면에 찍히는 건 `0 1 2 3 ` 이겠네.

**실행 결과:**

```
0 1 2 3
```

_(맨 뒤에 띄어쓰기 하나 있는 거 주의)_

---

**주요 포인트:**

- **Java 배열:** `new int[크기]` 형태로 생성하고, 기본적으로 0으로 초기화됨.
- **Java 메소드 호출 (배열 전달):** Java에서 배열을 메소드 인자로 전달하면 **참조에 의한 호출 (Call by Reference)** 과 유사하게 동작함 (정확히는 참조값이 복사되어 전달됨). 즉, 메소드 내에서 배열 요소를 변경하면 원본 배열도 변경됨. 이게 C/C++ 포인터랑 비슷한 효과를 내는 거지.
- **`static` 키워드:** `static` 변수나 메소드는 클래스에 속하며, 객체 생성 없이 `클래스명.멤버명` 또는 같은 클래스 내에서는 이름만으로 접근 가능.
- **`System.out.print()` vs `System.out.println()`:** `print`는 출력 후 줄바꿈을 안 하고, `println`은 줄바꿈을 함.

---

### 20번 문제

**문제:** 다음 Java 프로그램의 실행 결과를 작성하시오

```java
public class Main {
    public static void main(String[]args) throws Exception {
        int a = 0;
        for(int i = 1; i < 999; i++){
            if(i % 3 == 0 && i % 2 !=0)
            a = i;
        }
        System.out.print(a);
    }
}
```

**답변:**

오케이 마지막 자바 코드 문제네. 이것도 간단한 반복문이구만 ㅋㅋ. 함 보자.

1.  `int a = 0;`: 변수 `a`를 0으로 시작.
2.  `for(int i = 1; i < 999; i++)`: `i`가 1부터 998까지 1씩 증가하면서 뺑뺑이 돔. 999는 포함 안 됨 (`< 999`).
3.  `if(i % 3 == 0 && i % 2 != 0)`: 이게 핵심 조건이네.
    - `i % 3 == 0`: `i`를 3으로 나눈 나머지가 0이다. 즉, `i`는 **3의 배수**여야 함.
    - `i % 2 != 0`: `i`를 2로 나눈 나머지가 0이 아니다. 즉, `i`는 짝수가 아니어야 함. **홀수**라는 뜻.
    - `&&`: 두 조건 **모두 만족**해야 함. 그러니까 `i`는 **3의 배수이면서 동시에 홀수**여야 한다는 거임.
4.  `a = i;`: 위 `if` 조건이 참이면, 현재 `i` 값을 변수 `a`에 덮어씌움.
5.  **중요!** `a`는 조건 만족하는 `i`가 나올 때마다 계속 **새로운 `i` 값으로 업데이트**됨. 루프가 다 돌고 나면 `a`에는 가장 **마지막**으로 조건을 만족했던 `i` 값이 남아있겠지.
6.  **마지막 값 찾기:** 결국 1부터 998까지 숫자 중에서 '3의 배수이면서 홀수'인 **가장 큰 수**를 찾는 거임.
    - 루프의 끝 부분인 998부터 거꾸로 내려오면서 찾아보자.
    - 998: 짝수 (X)
    - 997: 3의 배수 아님 (9+9+7=25) (X)
    - 996: 3의 배수지만 짝수 (X)
    - 995: 3의 배수 아님 (9+9+5=23) (X)
    - 994: 짝수 (X)
    - **993**: 3의 배수 (9+9+3=21)이고 홀수. **찾았다!** 이게 루프 범위 안에서 조건을 만족하는 가장 큰 수임.
    - 따라서 루프가 끝날 때 `a`의 최종 값은 993이 됨.
7.  `System.out.print(a);`: 최종적으로 `a` 값을 출력함.

**실행 결과:**

```
993
```

---

**주요 포인트:**

- **반복문 (`for`):** 지정된 범위(1부터 998까지)를 순회하며 코드를 반복 실행.
- **조건문 (`if`):** 특정 조건(`i`가 3의 배수이고 홀수)을 검사.
- **나머지 연산자 (`%`):** 배수 또는 홀/짝수 판별에 유용하게 사용됨.
- **논리 연산자 (`&&`):** 두 개 이상의 조건을 모두 만족해야 할 때 사용 (AND).
- **변수 업데이트:** 루프 내에서 변수(`a`) 값이 계속 갱신될 때, 최종 결과는 루프 조건과 변수 업데이트 로직에 따라 달라짐. 이 경우, 조건을 만족하는 가장 마지막(가장 큰) `i` 값이 최종 결과가 됨.
